This is liquidwar6.info, produced by makeinfo version 5.2 from
liquidwar6.texi.

Liquid War 6, a unique multiplayer wargame.

   Copyright (c) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013,
2014, 2015 Christian Mauduit <ufoot@ufoot.org>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts and no
     Back-Cover Texts.  A copy of the license is included in the section
     entitled "GNU Free Documentation License".
START-INFO-DIR-ENTRY
* Liquid War 6: (liquidwar6).   A unique multiplayer wargame.
END-INFO-DIR-ENTRY


File: liquidwar6.info,  Node: libdat,  Next: libdef,  Prev: libcnx,  Up: C API

5.14 libdat
===========

5.14.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/dat/index.html>.

5.14.2 API
----------

 -- Function: lw6dat_miss_t * lw6dat_miss_new (lw6sys_context_t *
          SYS_CONTEXT, u_int64_t FROM_ID, int SERIAL_MIN, int
          SERIAL_MAX)
     FROM_ID: who needs to resend the message

     SERIAL_MIN: serial range begin (included)

     SERIAL_MAX: serial range end (included)

     Creates a miss structure, simply allocates memory and pumps values
     into the right fields.

     *Return value:* new dynamically allocated object

 -- Function: void lw6dat_miss_free (lw6sys_context_t * SYS_CONTEXT,
          lw6dat_miss_t * MISS)
     MISS: structure to free

     Frees a miss structure, simply unallocates memory.

     *Return value:* none.

 -- Function: void lw6dat_miss_sync (lw6sys_context_t * SYS_CONTEXT,
          lw6dat_miss_t * DST, lw6dat_miss_t * SRC)
     DST: target object

     SRC: source object

     Writes the contents of src to dst

     *Return value:* none.

 -- Function: int lw6dat_miss_is_same (lw6sys_context_t * SYS_CONTEXT,
          lw6dat_miss_t * A, lw6dat_miss_t * B)
     A: first element to compare

     B: second element to compare

     Compares two miss objects, returning true if they are the same.

     *Return value:* 1 if same, else 0.

 -- Function: int lw6dat_miss_is_included (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_miss_t * A, lw6dat_miss_t * B)
     A: first element to compare

     B: second element to compare

     Compares two miss objects, returning true if a is included in b.

     *Return value:* 1 if included, else 0.

 -- Function: int lw6dat_miss_overlaps (lw6sys_context_t * SYS_CONTEXT,
          lw6dat_miss_t * A, lw6dat_miss_t * B)
     A: first element to compare

     B: second element to compare

     Compares two miss objects, returning true if a overlaps with b.

     *Return value:* 1 if included, else 0.

 -- Function: int lw6dat_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libdat module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6dat_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'dat' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6dat_warehouse_init (lw6sys_context_t * SYS_CONTEXT,
          lw6dat_warehouse_t * WAREHOUSE, u_int64_t LOCAL_NODE_ID,
          int64_t SEQ_0)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to initialize

     LOCAL_NODE_ID: id of local node, used to handle local messages

     SEQ_0: initial seq number

     Initializes a warehouse object.  Won't free anything, will just
     erase values if they're here

     *Return value:* new object, allocated dynamically

 -- Function: lw6dat_warehouse_t * lw6dat_warehouse_new
          (lw6sys_context_t * SYS_CONTEXT, u_int64_t LOCAL_NODE_ID,
          int64_t SEQ_0)
     SYS_CONTEXT: global system context

     LOCAL_NODE_ID: id of local node, used to handle local messages

     SEQ_0: initial seq number

     Creates a new warehouse object.

     *Return value:* new object, allocated dynamically

 -- Function: void lw6dat_warehouse_free (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: the object to free

     Frees a warehouse object.

     *Return value:* new object, allocated dynamically

 -- Function: void lw6dat_warehouse_clear (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: the object to clear

     Clears a warehouse object.  Clears means emptying everything and
     resetting the current seq_id to the minimal/start value.

     *Return value:* none.

 -- Function: void lw6dat_warehouse_purge (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: the object to purge

     Purges a warehouse object.  Purges means emptying everything but
     keeping the current seq_id and the nodes list unchanged.

     *Return value:* none.

 -- Function: int lw6dat_warehouse_get_nb_nodes (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: the warehouse object to query.

     Tells how many nodes are registered in the object.

     *Return value:* integer, number of nodes

 -- Function: u_int64_t lw6dat_warehouse_get_local_id (lw6sys_context_t
          * SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: the warehouse object to query.

     Returns the local id.

     *Return value:* 64-bit id.

 -- Function: int lw6dat_warehouse_get_local_serial (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: the warehouse object to query.

     Returns the latest (highest) serial number given for local node.

     *Return value:* integer, latest serial number

 -- Function: int64_t lw6dat_warehouse_get_local_seq_0 (lw6sys_context_t
          * SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: the warehouse object to query

     Gives the warehouse seq_0 number, any seq below does not make
     sense.

     *Return value:* long integer.

 -- Function: void lw6dat_warehouse_set_local_seq_0 (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE, int64_t SEQ_0)
     SYS_CONTEXT: global system context

     WAREHOUSE: the warehouse object to modify

     SEQ_0: the new seq value

     Set the warehouse seq_0 number, any seq below does not make sense.

     *Return value:* none.

 -- Function: int64_t lw6dat_warehouse_get_local_seq_last
          (lw6sys_context_t * SYS_CONTEXT, lw6dat_warehouse_t *
          WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: the warehouse object to query

     Gives the warehouse seq_last number, this is the seq that
     corresponds to the last local message put in this warehouse.  This
     is usefull to get the last seq used and, for instance, put a NOP
     message just for keepalive purposes.

     *Return value:* long integer.

 -- Function: int lw6dat_warehouse_register_node (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE, u_int64_t
          NODE_ID, int SERIAL_0, int64_t SEQ_0)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to update

     NODE_ID: id of node to register

     SERIAL_0: serial number of first message

     SEQ_0: initial seq number

     Registers a node, in practice this is automatically done when
     receiving a data message but it might be interesting to do it
     elsewhere and force it.

     *Return value:* the stack index of the registered node, <0 is
     invalid.

 -- Function: int lw6dat_warehouse_is_node_registered (lw6sys_context_t
          * SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE, u_int64_t
          NODE_ID)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to update

     NODE_ID: id of node to register

     Tells wether a node is registered or not in our list.

     *Return value:* 1 if registered, 0 if not.

 -- Function: int lw6dat_warehouse_put_atom_str (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE, u_int64_t
          LOGICAL_FROM, const char * FULL_STR)
     SYS_CONTEXT: global system context

     WAREHOUSE: warehouse object to use

     LOGICAL_FROM: from who the message came from originally

     FULL_STR: message of the form serial i n seq from cmd

     Puts an atomic string in the object, this kind of string is
     typically received on the network.

     *Return value:* 1 on success, 0 on error

 -- Function: int lw6dat_warehouse_calc_serial_draft_and_reference
          (lw6sys_context_t * SYS_CONTEXT, lw6dat_warehouse_t *
          WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to work on

     The various 'get_seq' functions can perform slowly if we don't
     pre-calculate the serial number of draft and reference atoms.  So
     this calculation is not within the functions themselves but can be
     cached by using this function.  Just call it and after you might
     query the object for reference and draft info.

     *Return value:* 1 if some valid informations were found, else 0,
     which means no interesting (complete) atoms where found, and
     there's probably nothing to do yet.

 -- Function: int lw6dat_warehouse_put_local_msg (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE, const char * MSG)
     SYS_CONTEXT: global system context

     WAREHOUSE: warehouse object to use

     MSG: message

     Puts a message in the object.  The message will be splitted into
     several atoms if needed, it can be arbitrary long.

     *Return value:* 1 on success, 0 on error

 -- Function: int64_t lw6dat_warehouse_get_seq_min (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to query

     Tells the lowest seq referenced in the warehouse.  Does not mean
     this is the lowest ever received, only we really have no chances of
     going below that point, nothing is stored, either complete or
     partial, below that.

     *Return value:* integer.

 -- Function: int64_t lw6dat_warehouse_get_seq_max (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to query

     Tells the highest seq referenced in the warehouse.  Does not mean
     an actual message can be built from it, only we've got some traces
     of such a high seq.

     *Return value:* integer.

 -- Function: int64_t lw6dat_warehouse_get_seq_draft (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to query

     Tells the highest seq that can be considered as a valid draft.
     This is not exactly the maximimum seq encountered, for here we want
     at least one complete message and not just one chunk of data (an
     atom) referring to a high seq, we want the complete stuff.  However
     there can be missing messages in between.

     *Return value:* integer.

 -- Function: int64_t lw6dat_warehouse_get_seq_reference
          (lw6sys_context_t * SYS_CONTEXT, lw6dat_warehouse_t *
          WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to query

     Tells the highest seq that can be considered as a reference.  Being
     considered as a reference means we received all messages for this
     seq *and* at least one message from the following seq, and this for
     every node involved.  This being said, we're sure to have the right
     information, nothing is missing.

     *Return value:* integer.

 -- Function: lw6sys_list_t * lw6dat_warehouse_get_msg_list_by_seq
          (lw6sys_context_t * SYS_CONTEXT, lw6dat_warehouse_t *
          WAREHOUSE, int64_t SEQ_MIN, int64_t SEQ_MAX, int
          FOR_REFERENCE, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to query

     SEQ_MIN: lowest sequence number (round or chat index)

     SEQ_MAX: highest sequence number (round or chat index)

     FOR_REFERENCE: set to 1 if this is for reference building else 0
     for draft

     PROGRESS: progress indicator (read/write).

     Gets the list of messages for a given sequence (round or chat
     index), polling all the nodes.  The from and to boundaries are
     included.

     *Return value:* a list of strings.

 -- Function: lw6sys_list_t *
          lw6dat_warehouse_get_atom_str_list_not_sent (lw6sys_context_t
          * SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE, u_int64_t
          LOGICAL_TO)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to query

     LOGICAL_TO: the id of the node that we want to send data to

     Returns all the messages that were not sent for the given
     warehouse.

     *Return value:* a list of strings, containing atoms.

 -- Function: lw6sys_list_t * lw6dat_warehouse_get_miss_list
          (lw6sys_context_t * SYS_CONTEXT, lw6dat_warehouse_t *
          WAREHOUSE, int MAX_RANGE, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to query

     MAX_RANGE: max range of the returned list (-1 if none)

     PROGRESS: progress indicator, to show advancement to end-user

     Returns a list of 'lw6dat_miss_t' objects which contains
     informations about the messages which need to be re-sent by peers.
     The function will always return something, the list is not cleared
     if it's called several times, so one should not poll this too
     often.  Additionnally, the max_range parameter can be used to limit
     the size of the returned ranges, to avoid querying for too many
     messages at once.

     *Return value:* a list of pointers to 'lw6dat_miss_t' structs, NULL
     on failure.

 -- Function: void lw6dat_warehouse_miss_invalidate (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE, u_int64_t
          FROM_ID, u_int64_t TO_ID, int SERIAL_MIN, int SERIAL_MAX)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to modify

     FROM_ID: node which needs to resend data

     TO_ID: node which needs to get the data

     SERIAL_MIN: minimum serial number to send

     SERIAL_MAX: maximum serial number to send

     Re-sends messages in a given serial range.  Actually, does not
     really resend messages, but marks them as needing to be sent again.
     We might, or not, have those messages in stock, if we have them we
     send them, if not we just do nothing, someone else might have them.

     *Return value:* none

 -- Function: void lw6dat_warehouse_update_serial_miss_max
          (lw6sys_context_t * SYS_CONTEXT, lw6dat_warehouse_t *
          WAREHOUSE, u_int64_t REMOTE_ID, int SERIAL)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to update

     REMOTE_ID: id of remote host to update (which stack)

     SERIAL: new max serial value

     *Return value:* none

 -- Function: void lw6dat_warehouse_reset_nb_atom_parts_since_last_poll
          (lw6sys_context_t * SYS_CONTEXT, lw6dat_warehouse_t *
          WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: data warehouse to reset

     Resets the nb_atom_parts_since_last_poll attribute of every stack.

     *Return value:* none

 -- Function: int lw6dat_warehouse_get_nb_atom_parts_since_last_poll
          (lw6sys_context_t * SYS_CONTEXT, lw6dat_warehouse_t *
          WAREHOUSE, u_int64_t REMOTE_ID)
     SYS_CONTEXT: global system context

     WAREHOUSE: data warehouse to get info from

     REMOTE_ID: remote id to get info about

     Returns the nb_atom_parts_since_last_poll attribute of the stack
     concerning the remote_id.  The idea is to track down, since the
     last call to the companion reset function, how many "atom parts"
     have been received, by "atom part" we mean atoms representing a
     splitted message.  Usually this corresponds to very long messages
     and if this number of splitted messages is large enough, we don't
     send MISS commands, as it would overload the network for nothing.

     *Return value:* number of atom parts received since last reset.

 -- Function: int lw6dat_warehouse_meta_put (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE, int64_t SEQ)
     SYS_CONTEXT: global system context

     WAREHOUSE: data warehouse to put message into

     SEQ: seq to use to stamp the message

     Puts a META message in the warehouse.  The META message purpose is
     to tell other warehouses (on other nodes, peers) that the list of
     peers is updated.  This typically happens when a node joins in.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6dat_warehouse_meta_get (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE,
          lw6msg_meta_array_t * META_ARRAY, int64_t SEQ)
     SYS_CONTEXT: global system context

     WAREHOUSE: data warehouse to put message into

     META_ARRAY: current informations sendable by a meta message

     SEQ: seq to use to stamp the message

     Gets the data required for a META message.  Note that this function
     can be called in other contexts to know who is registered within
     the warehouse, which, as an opaque type, doesn't export that info
     otherwise.

     *Return value:* 1 on success, 0 if failed.

 -- Struct: lw6dat_miss_s

     Used to get informations about "what messages are missing", The
     struct typically contains informations to send a MISS message on
     the network, that is, who needs to resend the information, and the
     message serial range.  The informations "who needs it" need not be
     stored as this is logically our local node.

 -- Member of lw6dat_miss_s: from_id
     *Type:* 'u_int64_t'

     *Definition:* 'u_int64_t lw6dat_miss_s::from_id'

     Id of node which needs to resend the information.

 -- Member of lw6dat_miss_s: serial_min
     *Type:* 'int'

     *Definition:* 'int lw6dat_miss_s::serial_min'

     Minimum serial, included in the range.

 -- Member of lw6dat_miss_s: serial_max
     *Type:* 'int'

     *Definition:* 'int lw6dat_miss_s::serial_max'

     Maximum serial, included in the range.

 -- Struct: lw6dat_warehouse_s

     Contains all recent messages sent to peers, and received from them,
     int fact this is a local database, think of it as a giant array,
     containing all messages.  This is usefull both resend messages if
     one peer wants one and also to check wether informations are
     consistent and nobody is cheating.  This structure is hiddent,
     casted to the real stuff internally if needed, so that other parts
     of the code don't rely on specific implementation.

 -- Member of lw6dat_warehouse_s: dummy
     *Type:* 'int'

     *Definition:* 'int lw6dat_warehouse_s::dummy'

     Dummy field, unused.


File: liquidwar6.info,  Node: libdef,  Next: libdsp,  Prev: libdat,  Up: C API

5.15 libdef
===========

5.15.1 Overview
---------------

5.15.2 API
----------

There are no functions in 'libdef', only a header file with constants.


File: liquidwar6.info,  Node: libdsp,  Next: libdyn,  Prev: libdef,  Up: C API

5.16 libdsp
===========

5.16.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/dsp/index.html>.

5.16.2 API
----------

 -- Function: lw6dsp_backend_t * lw6dsp_create_backend (lw6sys_context_t
          * SYS_CONTEXT, int ARGC, const char * [] ARGV, const char *
          GFX_BACKEND_NAME)
     SYS_CONTEXT: global system context

     ARGC: argc as passed to 'main'

     ARGV: argv as passed to 'main'

     GFX_BACKEND_NAME: the id/name of the gfx backend to use

     Creates a dsp_backend object.  The created object won't be
     displaying things until 'lw6dsp_init' is called.  No thread is
     created, but the graphics backend is loaded into memory.  If video
     mode is not available, it will appear later, when trying to start
     displaying things, this function only allocates memory and checks
     code is available in case of a dynamically loaded gfx backend.

     *Return value:* a newly allocated object.

 -- Function: void lw6dsp_destroy_backend (lw6sys_context_t *
          SYS_CONTEXT, lw6dsp_backend_t * DSP_BACKEND)
     SYS_CONTEXT: global system context

     DSP_BACKEND: the dsp_backend object to free

     Frees all ressources used by a dsp_backend object.  Note that you
     must call this on a inactive 'stopped' dsp_backend object.

     *Return value:* none.

 -- Function: char * lw6dsp_repr (lw6sys_context_t * SYS_CONTEXT, const
          lw6dsp_backend_t * DSP_BACKEND)
     SYS_CONTEXT: global system context

     DSP_BACKEND: the object to represent

     Gives a short human-readable description of the object.

     *Return value:* a newly allocated string, must be freed.

 -- Function: int lw6dsp_init (lw6sys_context_t * SYS_CONTEXT,
          lw6dsp_backend_t * DSP_BACKEND, const lw6dsp_param_t * PARAM,
          lw6gui_resize_callback_func_t RESIZE_CALLBACK)
     SYS_CONTEXT: global system context

     DSP_BACKEND: the dsp_backend to start

     PARAM: parameters to pass to the display funcs

     RESIZE_CALLBACK: a function which will be called when there's a
     resize event

     Starts a dsp_backend object, that is, fire a separate thread and
     start rendering.  This will set up a video mode, so it's very
     likely to fail if for some reason the video context isn't right,
     for instance if you try to set up graphical stuff but only have
     console access.

     *Return value:* 1 if success, 0 if error.

 -- Function: void lw6dsp_quit (lw6sys_context_t * SYS_CONTEXT,
          lw6dsp_backend_t * DSP_BACKEND)
     SYS_CONTEXT: global system context

     DSP_BACKEND: the dsp_backend to stop

     Stops a dsp_backend, that is, cancel rendering and unset the video
     mode, hardware shouldn't be used any more after this call.

     *Return value:* none.

 -- Function: int lw6dsp_update (lw6sys_context_t * SYS_CONTEXT,
          lw6dsp_backend_t * DSP_BACKEND, const lw6dsp_param_t * PARAM)
     SYS_CONTEXT: global system context

     DSP_BACKEND: the dsp_backend to update

     PARAM: parameters to pass to the dsp_backend funcs

     Passes a new set of parameters to the display function.  This is in
     fact the only way to pass informations to the dsp_backend object
     once it's been started.  This function will acquire a mutex, copy
     parameters, then give control back to the main thread while display
     keeps on going with new parameters in the background.  It will get
     input informations.  You really must call it often otherwise the
     screen won't get updated, or, at least, it will always display the
     same informations.  It should be reasonnable to call this 10 or 20
     times per second, the display itself can be faster, run at 60 or
     100 fps to show smooth animation (eye candy).

     *Return value:* 1 if success, 0 if error.

 -- Function: int lw6dsp_get_nb_frames (lw6sys_context_t * SYS_CONTEXT,
          lw6dsp_backend_t * DSP_BACKEND)
     SYS_CONTEXT: global system context

     DSP_BACKEND: the dsp_backend to query

     Returns the number of frames displayed since the display was
     started.

     *Return value:* the number of frames displayed.

 -- Function: int lw6dsp_get_last_frame_rendering_time (lw6sys_context_t
          * SYS_CONTEXT, lw6dsp_backend_t * DSP_BACKEND)
     DSP_BACKEND: the dsp_backend to query

     Returns the rendering time of the last frame.  Gives clues about
     performance.

     *Return value:* the number of milliseconds it took to draw screen

 -- Function: int lw6dsp_get_instant_fps (lw6sys_context_t *
          SYS_CONTEXT, lw6dsp_backend_t * DSP_BACKEND)
     SYS_CONTEXT: global system context

     DSP_BACKEND: the dsp_backend to query

     Returns the current frames per sec display rate.  This is the
     instant value, it changes very often even if display seems smooth.

     *Return value:* the current instant display rate.

 -- Function: int lw6dsp_get_average_fps (lw6sys_context_t *
          SYS_CONTEXT, lw6dsp_backend_t * DSP_BACKEND)
     SYS_CONTEXT: global system context

     DSP_BACKEND: the dsp_backend to query

     Returns the current frames per sec display rate.  This is not
     absolutely accurate but fits for displaying info to the player,
     it's an average.

     *Return value:* the current averaged display rate.

 -- Function: int lw6dsp_get_video_mode (lw6sys_context_t * SYS_CONTEXT,
          lw6dsp_backend_t * DSP_BACKEND, lw6gui_video_mode_t *
          VIDEO_MODE)
     SYS_CONTEXT: global system context

     DSP_BACKEND: the dsp_backend to query

     VIDEO_MODE: a structure which will contain the results

     Returns the current video mode, the one obtained by the driver.
     This function is also a way to know wether display is running
     correcly or not, by testing its return value.

     *Return value:* 1 if ok, 0 if failure (mode not set)

 -- Function: int lw6dsp_get_fullscreen_modes (lw6sys_context_t *
          SYS_CONTEXT, lw6dsp_backend_t * DSP_BACKEND,
          lw6gui_fullscreen_modes_t * FULLSCREEN_MODES)
     SYS_CONTEXT: global system context

     DSP_BACKEND: the dsp_backend to query

     FULLSCREEN_MODES: a structure which will contain the results

     Returns the current available fullscreen modes.  Note that this one
     will only work if display is started, unlike
     'lw6gfx_get_fullscreen_modes' which is used internally.  The reason
     is that in this dsp module context, we need the thread to be
     launched, and the thread does start/stop display on its own.

     *Return value:* 1 if ok, 0 if failure (mode not set)

 -- Function: void lw6dsp_param_zero (lw6sys_context_t * SYS_CONTEXT,
          lw6dsp_param_t * PARAM)
     SYS_CONTEXT: global system context

     PARAM: the structure to initialize

     Fills a display param struct with zeros, this is mandatory before
     any use.  Think of it as a raw memset.

     *Return value:* none.

 -- Function: int lw6dsp_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libdsp module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6dsp_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'dsp' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6dsp_backend_s

     The dsp backend is the first argument passed to any dsp function,
     it contains reference to all the functions which can be used as
     well as a pointer on associated data.  In OO, this would just be an
     object, with members and methods, using polymorphism through opaque
     pointers.

 -- Member of lw6dsp_backend_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6dsp_backend_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6dsp_backend_s: thread
     *Type:* 'lw6sys_thread_handler_t *'

     *Definition:* 'lw6sys_thread_handler_t* lw6dsp_backend_s::thread'

     Thread running the display code.  In fact running in a separate
     thread is the whole point of this display object.

 -- Member of lw6dsp_backend_s: data
     *Type:* 'void *'

     *Definition:* 'void* lw6dsp_backend_s::data'

     Data used by the display code.  This is an opaque pointer, the
     internal structure will store details such as mutexes, parameters,
     information about the graphics backend, and so on.

 -- Member of lw6dsp_backend_s: input
     *Type:* 'lw6gui_input_t *'

     *Definition:* 'lw6gui_input_t* lw6dsp_backend_s::input'

     Input structure, will be updated by the display thread, so that it
     contains up-to-date information.  This is actually the only way to
     get input from the user.

 -- Struct: lw6dsp_misc_s

     Miscellaneous parameters for display.  One of the idea with this
     structure is that one must be able to compare two of them with a
     simple memcmp.  Even the progress pointer can be compared this way,
     the rest is just plain data.

 -- Member of lw6dsp_misc_s: mask
     *Type:* 'int'

     *Definition:* 'int lw6dsp_misc_s::mask'

     Display mask, define what must be displayed.

 -- Member of lw6dsp_misc_s: target_fps
     *Type:* 'int'

     *Definition:* 'int lw6dsp_misc_s::target_fps'

     How many frames per second the engine needs to display.

 -- Member of lw6dsp_misc_s: gfx_cpu_usage
     *Type:* 'float'

     *Definition:* 'float lw6dsp_misc_s::gfx_cpu_usage'

     How much CPU need be used, the maximum is 1.0f, the idea behind
     this parameter is that if you set it to a low value, the display
     thread will yield timeslices letting other threads speed up.  On a
     single-core CPU this can be usefull if the main calculation thread,
     the one that updates the game state, is falling behind.

 -- Member of lw6dsp_misc_s: dirty_read
     *Type:* 'int'

     *Definition:* 'int lw6dsp_misc_s::dirty_read'

     Dirty read mode.

 -- Member of lw6dsp_misc_s: capture
     *Type:* 'int'

     *Definition:* 'int lw6dsp_misc_s::capture'

     Wether we want to capture screen and dump it on disk.

 -- Member of lw6dsp_misc_s: gfx_debug
     *Type:* 'int'

     *Definition:* 'int lw6dsp_misc_s::gfx_debug'

     Wether to enable GFX debug mode.

 -- Member of lw6dsp_misc_s: debug_team_id
     *Type:* 'int'

     *Definition:* 'int lw6dsp_misc_s::debug_team_id'

     Parameter for debug mode, team ID to show info about.

 -- Member of lw6dsp_misc_s: debug_layer_id
     *Type:* 'int'

     *Definition:* 'int lw6dsp_misc_s::debug_layer_id'

     Parameter for debug mode, layer ID to show info about.

 -- Member of lw6dsp_misc_s: repeat_settings
     *Type:* 'lw6gui_repeat_settings_t'

     *Definition:* 'lw6gui_repeat_settings_t
     lw6dsp_misc_s::repeat_settings'

     Repeat settings, used by the input module.

 -- Member of lw6dsp_misc_s: log_timeout
     *Type:* 'int'

     *Definition:* 'int lw6dsp_misc_s::log_timeout'

     Delay after which messages disappear, in milliseconds.

 -- Member of lw6dsp_misc_s: progress
     *Type:* 'float *'

     *Definition:* 'volatile float* lw6dsp_misc_s::progress'

     Pointer on progress float, provides feedback to user.

 -- Struct: lw6dsp_param_s

     Parameters used by the display thread.  Be carefull, those need be
     modify with adequate functions, else a (serious) race condition
     could occur.

 -- Member of lw6dsp_param_s: misc
     *Type:* 'lw6dsp_misc_t'

     *Definition:* 'lw6dsp_misc_t lw6dsp_param_s::misc'

     Miscellaneous parameters, things that didn't fit elsewhere.

 -- Member of lw6dsp_param_s: video_mode
     *Type:* 'lw6gui_video_mode_t'

     *Definition:* 'lw6gui_video_mode_t lw6dsp_param_s::video_mode'

     Video mode.  This is separated from the misc parameters for it
     requires special handling, indeed changing resolution might need
     calls to special functions to set up a new graphical context.

 -- Member of lw6dsp_param_s: look
     *Type:* 'lw6gui_look_t *'

     *Definition:* 'lw6gui_look_t* lw6dsp_param_s::look'

     Visual parameters.

 -- Member of lw6dsp_param_s: menu
     *Type:* 'lw6gui_menu_t *'

     *Definition:* 'lw6gui_menu_t* lw6dsp_param_s::menu'

     Menu object, the main interface to gather and transmit informations
     to the user, when not playing.

 -- Member of lw6dsp_param_s: level
     *Type:* 'lw6map_level_t *'

     *Definition:* 'lw6map_level_t* lw6dsp_param_s::level'

     The level, as loaded from disk.

 -- Member of lw6dsp_param_s: game_struct
     *Type:* 'lw6ker_game_struct_t *'

     *Definition:* 'lw6ker_game_struct_t* lw6dsp_param_s::game_struct'

     The game struct, that is the level post-processed to be usable by
     game algorithms.

 -- Member of lw6dsp_param_s: game_state
     *Type:* 'lw6ker_game_state_t *'

     *Definition:* 'lw6ker_game_state_t* lw6dsp_param_s::game_state'

     Changeable state of the game.  Not that this pointer must really
     always be available, you can technically change its value but any
     value passed to it must be available and valid as long as the
     display is running, else you end up with a good old segfault.

 -- Member of lw6dsp_param_s: pilot
     *Type:* 'lw6pil_pilot_t *'

     *Definition:* 'lw6pil_pilot_t* lw6dsp_param_s::pilot'

     If in dirty-read mode, then game_state will be fetched from this
     object.  It can be NULL if you don't want to use the pilot.


File: liquidwar6.info,  Node: libdyn,  Next: libgen,  Prev: libdsp,  Up: C API

5.17 libdyn
===========

5.17.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/dyn/index.html>.

5.17.2 API
----------

 -- Function: lw6dyn_dl_handle_t * lw6dyn_dlopen_backend_so
          (lw6sys_context_t * SYS_CONTEXT, const char * SO_FILE)
     SYS_CONTEXT: global system context

     Opens a .so file directly, using a valid (full) path name.

     *Return value:* a handle to the module, once it's opened.  You
     might still need to call a module specific 'init' function, but
     it's another story.

 -- Function: lw6dyn_dl_handle_t * lw6dyn_dlopen_shared_so
          (lw6sys_context_t * SYS_CONTEXT, const char * SO_FILE)
     SYS_CONTEXT: global system context

     Opens a .so file directly, using a valid (full) path name.

     *Return value:* a handle to the shared code, once it's opened.  You
     might still need to call a module specific 'init' function, but
     it's another story.

 -- Function: lw6dyn_dl_handle_t * lw6dyn_dlopen_backend
          (lw6sys_context_t * SYS_CONTEXT, int ARGC, const char * []
          ARGV, const char * TOP_LEVEL_LIB, const char * BACKEND_NAME)
     SYS_CONTEXT: global system context

     ARGC: the number of command-line arguments as passed to 'main'

     TOP_LEVEL_LIB: the top-level library concerned, this means is it
     "cli", "gfx", "snd" or "srv".  This will tell the function to
     search for the .so file in the correct subdirectory.  Think of this
     as a category.

     Opens a .so file corresponding to the given backend, it is capable
     to search for system libraries installed after "make install" but
     if not found, it will also search in the current build directory,
     finding the .so files in hidden .libs subdirectories.

     *Return value:* a handle to the module, once it's opened.  You
     might still need to call a module specific 'init' function, but
     it's another story.

 -- Function: lw6dyn_dl_handle_t * lw6dyn_dlopen_shared
          (lw6sys_context_t * SYS_CONTEXT, int ARGC, const char * []
          ARGV, const char * TOP_LEVEL_LIB, const char * SHARED_NAME)
     SYS_CONTEXT: global system context

     ARGC: the number of command-line arguments as passed to 'main'

     TOP_LEVEL_LIB: the top-level library concerned, this means is it
     "cli", "gfx", "snd" or "srv".  This will tell the function to
     search for the .so file in the correct subdirectory.  Think of this
     as a category.

     Opens a .so file corresponding to the given shared code, it is
     capable to search for system libraries installed after "make
     install" but if not found, it will also search in the current build
     directory, finding the .so files in hidden .libs subdirectories.

     *Return value:* a handle to the shared code, once it's opened.
     This is different from a real module, there's no real prototype, it
     just loads code.

 -- Function: int lw6dyn_dlclose_backend (lw6sys_context_t *
          SYS_CONTEXT, lw6dyn_dl_handle_t * HANDLE)
     SYS_CONTEXT: global system context

     HANDLE: the backend to close.

     Closes an opened backend.  Note that you must call any backend
     specific clear, destroy, deinit, exit, function before.

     *Return value:* 1 if success, 0 on error.

 -- Function: int lw6dyn_dlclose_shared (lw6sys_context_t * SYS_CONTEXT,
          lw6dyn_dl_handle_t * HANDLE)
     SYS_CONTEXT: global system context

     HANDLE: the shared code library to close.

     Closes an opened shared code library.  Note that you must call any
     shared code library specific clear, destroy, deinit, exit, function
     before.

     *Return value:* 1 if success, 0 on error.

 -- Function: void * lw6dyn_dlsym (lw6sys_context_t * SYS_CONTEXT,
          lw6dyn_dl_handle_t * HANDLE, const char * FUNC_NAME)
     SYS_CONTEXT: global system context

     HANDLE: the backend concerned

     FUNC_NAME: the function name, as a NULL terminated string

     Finds a C function in the given backend.

     *Return value:* a pointer to the function, NULL if not found.

 -- Function: lw6sys_assoc_t * lw6dyn_list_backends (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV, const char *
          TOP_LEVEL_LIB)
     SYS_CONTEXT: global system context

     ARGC: the number of command line args, as passed to main

     ARGV: the commind line args, as passed to main

     TOP_LEVEL_LIB: the library category to query (gfx, snd, cli, srv
     ...)

     Returns an assoc which lists all the available modules.  The key of
     the assoc entries in the module internal name such as 'gl' and the
     value associated is a NULL terminated string describing the module,
     for instance 'OpenGL'.

     *Return value:* an assoc object containing key/label pairs.

 -- Function: char * lw6dyn_path_find_backend (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV, const char *
          TOP_LEVEL_LIB, const char * BACKEND_NAME)
     SYS_CONTEXT: global system context

     ARGC: the number of command-line arguments as passed to 'main'

     TOP_LEVEL_LIB: the top-level library concerned, this means is it
     "cli", "gfx", "snd" or "srv".  This will tell the function to
     search for the .so file in the correct subdirectory.  Think of this
     as a category.

     BACKEND_NAME: the actual name of the backend, this is the name of
     the .so file, between "libmod_" and ".so".  For instance, to find
     "libmod_gl.so", the right argument is "gl1".

     Get the full path to a .so file corresponding to the given backend,
     it is capable to search for system libraries installed after "make
     install" but if not found, it will also search in the current build
     directory, finding the .so files in hidden .libs subdirectories.

     *Return value:* the full path of the .so file, needs to be freed.

 -- Function: char * lw6dyn_path_find_shared (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV, const char *
          TOP_LEVEL_LIB, const char * SHARED_NAME)
     SYS_CONTEXT: global system context

     ARGC: the number of command-line arguments as passed to 'main'

     TOP_LEVEL_LIB: the top-level library concerned, this means is it
     "cli", "gfx", "snd" or "srv".  This will tell the function to
     search for the .so file in the correct subdirectory.  Think of this
     as a category.

     SHARED_NAME: the actual name of the shared code, this is the name
     of the .so file, between "libshared_" and ".so".  For instance, to
     find "libshared_sdl.so", the right argument is "sdl".

     Get the full path to a .so file corresponding to the given shared
     code entry, it is capable to search for system libraries installed
     after "make install" but if not found, it will also search in the
     current build directory, finding the .so files in hidden .libs
     subdirectories.  This is different from the standard module loader,
     since it will search for .so files with a slightly different name.
     The idea is to distinguish modules that are truely loadable and
     shared code that can't be used standalone and can't either be
     stuffed in the main binary since it refers to external dynamic
     library which will only be loaded at runtime.

     *Return value:* the full path of the .so file, needs to be freed.

 -- Function: int lw6dyn_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libdyn module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6dyn_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'dyn' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6dyn_dl_handle_s

     Handle on dynamic library.  Well, actually, ltdl does already
     provide something like, so why use our own wrapper?  It happens
     storing the library path, that's to say what .so files it comes
     from, is usefull for debugging, so this structure bundles those two
     informations together.

 -- Member of lw6dyn_dl_handle_s: handle
     *Type:* 'lt_dlhandle'

     *Definition:* 'lt_dlhandle lw6dyn_dl_handle_s::handle'

     Libtool handler.

 -- Member of lw6dyn_dl_handle_s: library_path
     *Type:* 'char *'

     *Definition:* 'char* lw6dyn_dl_handle_s::library_path'

     Path to .so file containing the code, or whatever file is relevant
     on the current platform, the idea is to keep track of where the
     library comes from.

 -- Member of lw6dyn_dl_handle_s: is_backend
     *Type:* 'int'

     *Definition:* 'int lw6dyn_dl_handle_s::is_backend'

     True (1) if the handle is a backend or false (0) if it's just some
     shared code.

 -- Member of lw6dyn_dl_handle_s: is_dlclose_safe
     *Type:* 'int'

     *Definition:* 'int lw6dyn_dl_handle_s::is_dlclose_safe'

     True (1) if one can safely call dlclose on this backend.  Set to
     false (0) if low level dlclose must be skipped.  For some reason,
     some (external) libraries really do not behave well when unloaded
     on the fly, even if we stop threads using them and don't use them
     anymore.  The workarround is to have this flag defined, to skip the
     internal close to dlclose.  LW will still free the memory, but
     won't call libtool dlclose for real.  Libtool keeps track of this
     internally and won't reload it on next call, maintain reference
     counts etc.  so there's no real harm.  Except it just looks ugly
     not to be able to truely unload the module.


File: liquidwar6.info,  Node: libgen,  Next: libgfx,  Prev: libdyn,  Up: C API

5.18 libgen
===========

5.18.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/gen/index.html>.

5.18.2 API
----------

 -- Function: lw6map_level_t * lw6gen_create_from_seed (lw6sys_context_t
          * SYS_CONTEXT, const char * SEED, int MAP_W, int MAP_H)
     SYS_CONTEXT: global system context

     SEED: a random seed used to generate the map

     MAP_W: width of the screen, in pixels

     MAP_H: height of the screen, in pixels

     Builds a complete, usable map from the string passed in seed.  Each
     triplet composed of seed/map_w/map_h should build the same map on
     any computer, in any context, for a given version of the game (no
     backwards compatibility).

     *Return value:* new map on success, NULL on failure.

 -- Function: char * lw6gen_seed_new (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Generate a new random seed.  The seed is composed of letters and
     numbers.

     *Return value:* newly allocated string.

 -- Function: char * lw6gen_seed_normalize (lw6sys_context_t *
          SYS_CONTEXT, const char * SEED)
     SYS_CONTEXT: global system context

     SEED: the seed to normalize

     Builds a normalized seed from an arbitrary string.  The idea is to
     avoid sending strange stuff on the network and/or storing strange
     stuff in config files, so we process correct strings only

     *Return value:* newly allocated string.

 -- Function: char lw6gen_seed_char (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns a random char suitable for seed (letter or digit).

     *Return value:* a single char

 -- Function: int lw6gen_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libgen module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6gen_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'gen' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: libgfx,  Next: mod-gl1,  Prev: libgen,  Up: C API

5.19 libgfx
===========

5.19.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/gfx/index.html>.

5.19.2 API
----------

 -- Function: int lw6gfx_init (lw6sys_context_t * SYS_CONTEXT,
          lw6gfx_backend_t * BACKEND, lw6gui_video_mode_t * VIDEO_MODE,
          lw6gui_resize_callback_func_t RESIZE_CALLBACK)
     SYS_CONTEXT: global system context

     BACKEND: the graphical backend to use

     VIDEO_MODE: the video mode to use at start up

     RESIZE_CALLBACK: a callback function which will be called at each
     resize event

     Sets up the graphical backend for good, initializing a video mode
     and allocating ressources.  This call can typically fail if there's
     no device available, if the user doesn't have enough rights to
     access the hardware, and so on.

     *Return value:* 1 on success, 0 if not

 -- Function: void lw6gfx_quit (lw6sys_context_t * SYS_CONTEXT,
          lw6gfx_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: the backend to quit

     Uninitializes the backend, that is, exits the graphical mode.  All
     threads that use graphics must be closed when this is called.

     *Return value:* none.

 -- Function: char * lw6gfx_repr (lw6sys_context_t * SYS_CONTEXT, const
          lw6gfx_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: the backend to represent

     Returns a readable version of the backend object.

     *Return value:* a newly allocated pointer.

 -- Function: int lw6gfx_set_video_mode (lw6sys_context_t * SYS_CONTEXT,
          lw6gfx_backend_t * BACKEND, lw6gui_video_mode_t * VIDEO_MODE)
     SYS_CONTEXT: global system context

     BACKEND: the backend to use

     VIDEO_MODE: the new video mode

     This function changes the video mode.  Note that the first time you
     set up the graphical environment you must call 'lw6gfx_init' but to
     change the current mode, use this function.  It should reload
     backend data automatically if needed (textures for instance).  Note
     that before giving up and failing this function will try alternate
     video modes, and you're not garanteed to have the right mode after
     the call, even if it returns true.  To check this, use
     'lw6gfx_get_video_mode'.

     *Return value:* 1 on success, 0 on failure;

 -- Function: int lw6gfx_get_video_mode (lw6sys_context_t * SYS_CONTEXT,
          lw6gfx_backend_t * BACKEND, lw6gui_video_mode_t * VIDEO_MODE)
     SYS_CONTEXT: global system context

     BACKEND: the backend to use

     VIDEO_MODE: the current video mode (will be overwritten, out
     parameter)

     This function returns the current video mode.

     *Return value:* 1 on success, 0 on failure;

 -- Function: int lw6gfx_get_fullscreen_modes (lw6sys_context_t *
          SYS_CONTEXT, lw6gfx_backend_t * BACKEND,
          lw6gui_fullscreen_modes_t * FULLSCREEN_MODES)
     SYS_CONTEXT: global system context

     BACKEND: the backend to use

     FULLSCREEN_MODES: the available fullscreen modes (will be
     overwritten, out parameter)

     This function returns the current video mode.

     *Return value:* 1 on success, 0 on failure;

 -- Function: lw6gui_input_t * lw6gfx_pump_events (lw6sys_context_t *
          SYS_CONTEXT, lw6gfx_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: the backend to use

     This function "pumps" events, that is gets pending events, puts
     them in queues, maintains internal states up to date.  You really
     must call this very often or no input will be processed at all.

     *Return value:* a pointer on the internal input state, musn't be
     freed.

 -- Function: int lw6gfx_display (lw6sys_context_t * SYS_CONTEXT,
          lw6gfx_backend_t * BACKEND, int MASK, const lw6gui_look_t *
          LOOK, const lw6map_level_t * LEVEL, const lw6ker_game_struct_t
          * GAME_STRUCT, const lw6ker_game_state_t * GAME_STATE,
          lw6pil_local_cursors_t * LOCAL_CURSORS, lw6gui_menu_t * MENU,
          float PROGRESS, float FPS, float MPS, const char ** LOG_LIST,
          int CAPTURE, int GFX_DEBUG, int DEBUG_TEAM_ID, int
          DEBUG_LAYER_ID)
     SYS_CONTEXT: global system context

     BACKEND: the graphical backend to use

     MASK: display flag, tells what to display

     LOOK: the look, the skin, contains display options

     LEVEL: the level to display

     GAME_STRUCT: the game_struct associated with the level

     GAME_STATE: the game_state associated with the level

     LOCAL_CURSORS: the cursor to center the focus on

     MENU: the menu to display

     PROGRESS: the value of the progress indicator

     FPS: the number of frames per second to display

     MPS: the number of moves per second to display

     LOG_LIST: log messages to display

     CAPTURE: wether to enable capture mode or not

     GFX_DEBUG: wether to enable gfx debugging tools

     DEBUG_TEAM_ID: for debug display, team to display informations
     about

     DEBUG_LAYER_ID: for debug display, layer to display

     This is the major drawing function, the one that encapsulates all
     others.  As the program uses a separate thread to display things,
     we just pass this function many parameters, and let it do its job
     alone.  So many parameters might sometimes be useless.  It also
     allows the graphics backend decide wether menus and hud and
     background should interact.  Or not.

     *Return value:* 1 on success, 0 on failure.

 -- Function: lw6sys_assoc_t * lw6gfx_get_backends (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc, as passed to 'main'

     ARGV: argv, as passed to 'main'

     List available gfx backends.  The hash contains pairs with id and
     name for each backend.  The id is the technical key you can use to
     load the backend, the name is something more readable you can
     display in an interface.  The backend objects themselves are not
     instanciated by this (in fact, they are, but released on the fly)
     you need to load and initialize them afterwards.

     *Return value:* hash containing id/name pairs.

 -- Function: lw6gfx_backend_t * lw6gfx_create_backend (lw6sys_context_t
          * SYS_CONTEXT, int ARGC, const char * [] ARGV, const char *
          NAME)
     SYS_CONTEXT: global system context

     ARGC: argc, as passed to 'main'

     ARGV: argv, as passed to 'main'

     NAME: string containing gfx key, typically got from
     'lw6gfx_get_backends'

     Creates a gfx backend, this is just about loading the dynamic
     library if needed, and/or check gfx engine is available, and
     connect to it.  It does not perform initialization.

     *Return value:* gfx backend.

 -- Function: void lw6gfx_destroy_backend (lw6sys_context_t *
          SYS_CONTEXT, lw6gfx_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: gfx backend to destroy

     Frees the ressources associated to a gfx, which must have been
     properly uninitialized before.

     *Return value:* none.

 -- Function: int lw6gfx_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libgfx module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6gfx_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'gfx' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6gfx_backend_s

     The gfx backend is the first argument passed to any gfx function,
     it contains reference to all the functions which can be used as
     well as a pointer on associated data.  In OO, this would just be an
     object, with members and methods, using polymorphism through opaque
     pointers.

 -- Member of lw6gfx_backend_s: dl_handle
     *Type:* 'lw6dyn_dl_handle_t *'

     *Definition:* 'lw6dyn_dl_handle_t* lw6gfx_backend_s::dl_handle'

     Handle on dynamic library (if it makes sense).

 -- Member of lw6gfx_backend_s: gfx_context
     *Type:* 'void *'

     *Definition:* 'void* lw6gfx_backend_s::gfx_context'

     Gfx specific data, what is behind this pointer really depends on
     the gfx engine.

 -- Member of lw6gfx_backend_s: argc
     *Type:* 'int'

     *Definition:* 'int lw6gfx_backend_s::argc'

     The argc value passed to main.

 -- Member of lw6gfx_backend_s: argv
     *Type:* 'const char **'

     *Definition:* 'const char** lw6gfx_backend_s::argv'

     The argv value passed to main.

 -- Member of lw6gfx_backend_s: call_lock
     *Type:* 'lw6sys_mutex_t *'

     *Definition:* 'lw6sys_mutex_t* lw6gfx_backend_s::call_lock'

     Lock used to avoid concurrent access to underlying libs.

 -- Member of lw6gfx_backend_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6gfx_backend_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6gfx_backend_s: init
     *Type:* 'void *(*'

     *Definition:* 'void*(* lw6gfx_backend_s::init)(lw6sys_context_t
     *sys_context, int argc, const char *argv[], lw6gui_video_mode_t
     *video_mode, lw6gui_resize_callback_func_t resize_callback)'

     Pointer on lw6gfx_init callback code.

 -- Member of lw6gfx_backend_s: quit
     *Type:* 'void(*'

     *Definition:* 'void(* lw6gfx_backend_s::quit)(lw6sys_context_t
     *sys_context, void *gfx_context)'

     Pointer on lw6gfx_quit callback code.

 -- Member of lw6gfx_backend_s: repr
     *Type:* 'char *(*'

     *Definition:* 'char*(* lw6gfx_backend_s::repr)(lw6sys_context_t
     *sys_context, void *gfx_context, u_int32_t id)'

     Pointer on lw6gfx_repr callback code.

 -- Member of lw6gfx_backend_s: set_video_mode
     *Type:* 'int(*'

     *Definition:* 'int(*
     lw6gfx_backend_s::set_video_mode)(lw6sys_context_t *sys_context,
     void *gfx_context, lw6gui_video_mode_t *video_mode)'

     Pointer on lw6gfx_set_video_mode callback code.

 -- Member of lw6gfx_backend_s: get_video_mode
     *Type:* 'int(*'

     *Definition:* 'int(*
     lw6gfx_backend_s::get_video_mode)(lw6sys_context_t *sys_context,
     void *gfx_context, lw6gui_video_mode_t *video_mode)'

     Pointer on lw6gfx_get_video_mode callback code.

 -- Member of lw6gfx_backend_s: get_fullscreen_modes
     *Type:* 'int(*'

     *Definition:* 'int(*
     lw6gfx_backend_s::get_fullscreen_modes)(lw6sys_context_t
     *sys_context, void *gfx_context, lw6gui_fullscreen_modes_t *modes)'

     Pointer on lw6gfx_get_fullscreen_modes callback code.

 -- Member of lw6gfx_backend_s: pump_events
     *Type:* 'lw6gui_input_t *(*'

     *Definition:* 'lw6gui_input_t*(*
     lw6gfx_backend_s::pump_events)(lw6sys_context_t *sys_context, void
     *gfx_context)'

     Pointer on lw6gfx_pump_events code.

 -- Member of lw6gfx_backend_s: display
     *Type:* 'int(*'

     *Definition:* 'int(* lw6gfx_backend_s::display)(lw6sys_context_t
     *sys_context, void *gfx_context, int mask, const lw6gui_look_t
     *look, const lw6map_level_t *level, const lw6ker_game_struct_t
     *game_struct, const lw6ker_game_state_t *game_state,
     lw6pil_local_cursors_t *local_cursors, lw6gui_menu_t *menu, float
     progress, float fps, float mps, const char **log_list, int capture,
     int gfx_debug, int debug_team_id, int debug_layer_id)'

     Pointer on lw6gfx_display code.


File: liquidwar6.info,  Node: mod-gl1,  Next: mod-gles2,  Prev: libgfx,  Up: C API

5.20 mod-gl1
============

5.20.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/gfx/mod-gl1/gl-utils/index.html>
(as there are many sub-directories in this module, please refer to the
test coverage directory index
(http://www.ufoot.org/liquidwar/v6/doc/coverage/index.html) for complete
information).

5.20.2 API
----------

 -- Function: void mod_gl1_is_GPL_compatible ()

     Defined to tell mod_gl1 is compatible with GNU General Public
     License Of course it is.  This function does nothing, but the fact
     it's declared makes its GPL compatibility obvious.  Having this
     declared is required.

     *Return value:* none

 -- Function: lw6sys_module_pedigree_t * mod_gl1_get_pedigree
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the pedigree for mod-gl1, giving details about the module,
     including name, description, licence, date/time of compilation.

     *Return value:* dynamically allocated object.

 -- Function: lw6gfx_backend_t * mod_gl1_create_backend
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a mod-gl1 backend.

     *Return value:* backend pointer.


File: liquidwar6.info,  Node: mod-gles2,  Next: mod-soft,  Prev: mod-gl1,  Up: C API

5.21 mod-gles2
==============

5.21.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/gfx/mod-gles2/index.html>
(as there are many sub-directories in this module, please refer to the
test coverage directory index
(http://www.ufoot.org/liquidwar/v6/doc/coverage/index.html) for complete
information).

5.21.2 API
----------

 -- Function: void mod_gles2_is_GPL_compatible ()

     Defined to tell mod_gles2 is compatible with GNU General Public
     License Of course it is.  This function does nothing, but the fact
     it's declared makes its GPL compatibility obvious.  Having this
     declared is required.

     *Return value:* none

 -- Function: lw6sys_module_pedigree_t * mod_gles2_get_pedigree
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the pedigree for mod-gles2, giving details about the
     module, including name, description, licence, date/time of
     compilation.

     *Return value:* dynamically allocated object.

 -- Function: lw6gfx_backend_t * mod_gles2_create_backend
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a mod-gles2 backend.

     *Return value:* backend pointer.


File: liquidwar6.info,  Node: mod-soft,  Next: shared-sdl,  Prev: mod-gles2,  Up: C API

5.22 mod-soft
=============

5.22.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/gfx/mod-soft/index.html>
(as there are many sub-directories in this module, please refer to the
test coverage directory index
(http://www.ufoot.org/liquidwar/v6/doc/coverage/index.html) for complete
information).

5.22.2 API
----------

 -- Function: void mod_soft_is_GPL_compatible ()

     Defined to tell mod_soft is compatible with GNU General Public
     License Of course it is.  This function does nothing, but the fact
     it's declared makes its GPL compatibility obvious.  Having this
     declared is required.

     *Return value:* none

 -- Function: lw6sys_module_pedigree_t * mod_soft_get_pedigree
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the pedigree for mod-soft, giving details about the module,
     including name, description, licence, date/time of compilation.

     *Return value:* dynamically allocated object.

 -- Function: lw6gfx_backend_t * mod_soft_create_backend
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a mod-soft backend.

     *Return value:* backend pointer.


File: liquidwar6.info,  Node: shared-sdl,  Next: mod-caca,  Prev: mod-soft,  Up: C API

5.23 shared-sdl
===============

5.23.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/gfx/shared-sdl/index.html>
(as there are many sub-directories in this module, please refer to the
test coverage directory index
(http://www.ufoot.org/liquidwar/v6/doc/coverage/index.html) for complete
information).

5.23.2 API
----------

 -- Function: void shared_sdl_is_GPL_compatible ()

     Defined to tell shared_sdl is compatible with GNU General Public
     License Of course it is.  This function does nothing, but the fact
     it's declared makes its GPL compatibility obvious.  Having this
     declared is required.

     *Return value:* none


File: liquidwar6.info,  Node: mod-caca,  Next: libglb,  Prev: shared-sdl,  Up: C API

5.24 mod-caca
=============

5.24.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/gfx/mod-caca/index.html>
(as there are many sub-directories in this module, please refer to the
test coverage directory index
(http://www.ufoot.org/liquidwar/v6/doc/coverage/index.html) for complete
information).

5.24.2 API
----------

 -- Function: void mod_caca_is_GPL_compatible ()

     Defined to tell mod_caca is compatible with GNU General Public
     License Of course it is.  This function does nothing, but the fact
     it's declared makes its GPL compatibility obvious.  Having this
     declared is required.

     *Return value:* none

 -- Function: lw6sys_module_pedigree_t * mod_caca_get_pedigree
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the pedigree for mod-caca, giving details about the module,
     including name, description, licence, date/time of compilation.

     *Return value:* dynamically allocated object.

 -- Function: lw6gfx_backend_t * mod_caca_create_backend
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a mod-caca backend.

     *Return value:* backend pointer.


File: liquidwar6.info,  Node: libglb,  Next: libgui,  Prev: mod-caca,  Up: C API

5.25 libglb
===========

5.25.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/glb/index.html>.

5.25.2 API
----------

 -- Function: char * lw6glb_base64_encode_bin (lw6sys_context_t *
          SYS_CONTEXT, const char * BUF, int SIZE)
     SYS_CONTEXT: global system context

     BUF: the data to encode

     SIZE: the size of data to encode

     Encodes data into base64.  Memory allocation is done automatically.

     *Return value:* newly allocated string.

 -- Function: char * lw6glb_base64_decode_bin (lw6sys_context_t *
          SYS_CONTEXT, int * SIZE, const char * BASE64_STR)
     SYS_CONTEXT: global system context

     SIZE: the size of the decoded data

     BASE64_STR: the string to decode

     Decodes data from base64.  Memory allocation is done automatically.
     Note that this function only works for strings, other data might
     not be handled correctly.

     *Return value:* newly allocated pointer, NULL on error.

 -- Function: char * lw6glb_base64_encode_str (lw6sys_context_t *
          SYS_CONTEXT, const char * STR)
     SYS_CONTEXT: global system context

     STR: the string to encode

     Encodes a string into base64.

     *Return value:* newly allocated string.

 -- Function: char * lw6glb_base64_decode_str (lw6sys_context_t *
          SYS_CONTEXT, const char * STR)
     SYS_CONTEXT: global system context

     STR: the string to decode

     Decodes a string from base64.

     *Return value:* newly allocated string, NULL on error.

 -- Function: char * lw6glb_base64_encode_bin_prefix (lw6sys_context_t *
          SYS_CONTEXT, const char * BUF, int SIZE, const char * PREFIX)
     SYS_CONTEXT: global system context

     BUF: the data to encode

     SIZE: the size of data to encode

     PREFIX: a prefix string

     Encodes data into base64.  Memory allocation is done automatically.
     The encoded string will be prefixed with 'prefix'.

     *Return value:* newly allocated string.

 -- Function: char * lw6glb_base64_decode_bin_prefix (lw6sys_context_t *
          SYS_CONTEXT, int * SIZE, const char * BASE64_STR, const char *
          PREFIX)
     SYS_CONTEXT: global system context

     SIZE: the size of the decoded data

     BASE64_STR: the string to decode

     PREFIX: a prefix string

     Decodes data from base64.  Memory allocation is done automatically.
     Note that this function only works for strings, other data might
     not be handled correctly.  The encoded is expected to start with
     prefix 'prefix' and then contain base64 data.

     *Return value:* newly allocated pointer, NULL on error.

 -- Function: char * lw6glb_base64_encode_str_prefix (lw6sys_context_t *
          SYS_CONTEXT, const char * STR, const char * PREFIX)
     SYS_CONTEXT: global system context

     STR: the string to encode

     PREFIX: a prefix string

     Encodes a string into base64.  The encoded string will be prefixed
     with 'prefix'.

     *Return value:* newly allocated string.

 -- Function: char * lw6glb_base64_decode_str_prefix (lw6sys_context_t *
          SYS_CONTEXT, const char * STR, const char * PREFIX)
     SYS_CONTEXT: global system context

     STR: the string to decode

     PREFIX: a prefix string

     Decodes a string from base64.  The encoded is expected to start
     with prefix 'prefix' and then contain base64 data.

     *Return value:* newly allocated string, NULL on error.

 -- Function: char * lw6glb_sha1_hmac_80_bin (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY, int KEY_SIZE, const char * BUF,
          int BUF_SIZE)
     SYS_CONTEXT: global system context

     KEY: the key buffer 'key_size'

     BUF: the data to analyse

     BUF_SIZE: the size of data to analyse

     Calculates an SHA-1 sum of buffer, using key to seed calc.

     *Return value:* newly allocated string, containing 20 chars
     checksum.

 -- Function: char * lw6glb_sha1_hmac_80_str (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY, const char * STR)
     SYS_CONTEXT: global system context

     KEY: a key (string)

     STR: the string to calculate the checksum for

     Calculates an SHA-1 sum of a string, using key to seed calc.

     *Return value:* newly allocated string, containing 20 chars
     checksum.

 -- Function: u_int32_t lw6glb_sha1_hmac_32_bin (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY, int KEY_SIZE, const char * BUF,
          int BUF_SIZE)
     SYS_CONTEXT: global system context

     KEY: the key buffer

     KEY_SIZE: the key buffer size

     BUF: the data to analyse

     BUF_SIZE: the size of data to analyse

     Calculates an SHA-1 sum of buffer, using key to seed calc.

     *Return value:* a 32-bit unsigned integer

 -- Function: u_int32_t lw6glb_sha1_hmac_32_str (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY, const char * STR)
     SYS_CONTEXT: global system context

     KEY: a key (string)

     STR: the string to calculate the checksum for

     Calculates an SHA-1 sum of a string, using key to seed calc.

     *Return value:* a 32-bit unsigned integer

 -- Function: int lw6glb_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libglb module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6glb_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'glb' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: libgui,  Next: libhlp,  Prev: libglb,  Up: C API

5.26 libgui
===========

5.26.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/gui/index.html>.

5.26.2 API
----------

 -- Function: void lw6gui_button_register_down (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_button_t * BUTTON, int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     BUTTON: the button to update

     TIMESTAMP: the current ticks (milliseconds)

     Registers a "down" (press) event on a button.

     *Return value:* none.

 -- Function: void lw6gui_button_register_up (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_button_t * BUTTON)
     SYS_CONTEXT: global system context

     BUTTON: the button to update

     Registers a "up" (release) event on a button.

     *Return value:* none.

 -- Function: int lw6gui_button_is_pressed (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_button_t * BUTTON)
     SYS_CONTEXT: global system context

     BUTTON: the button to query

     Tells wether a button is pressed or not.

     *Return value:* 1 if pressed, 0 if not.

 -- Function: int lw6gui_button_pop_press (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_button_t * BUTTON)
     SYS_CONTEXT: global system context

     BUTTON: the button to query

     Tells how many times the button has been pressed.  Typical usage:
     the button is pressed, released, pressed, released several times.
     Then, after all this, you want to know how many times it has been
     pressed.  Querying its state with 'lw6gui_button_is_pressed' won't
     tell you much but this 'pop_press' function will return 1 for each
     press there's been.

     *Return value:* 1 if there's a press event in the queue, 0 if
     empty.

 -- Function: int lw6gui_button_pop_simple_click (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_button_t * BUTTON)
     SYS_CONTEXT: global system context

     BUTTON: the button to query

     Tells how many times the button has been simpleclicked.  This is
     different from a simple press, in fact, there's a delay, we must
     wait until the double-click delay is elapsed to make sure this is a
     simple click...  Designed for use with mouse to differentiate fire
     and alternate fire.

     *Return value:* 1 if there's a simpleclick event in the queue, 0 if
     empty.

 -- Function: int lw6gui_button_pop_double_click (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_button_t * BUTTON)
     SYS_CONTEXT: global system context

     BUTTON: the button to query

     Tells how many times the button has been doubleclicked.  Typical
     usage: the button is doubleclicked, released, doubleclicked,
     released several times.  Then, after all this, you want to know how
     many times it has been doubleclicked.

     *Return value:* 1 if there's a doubleclick event in the queue, 0 if
     empty.

 -- Function: int lw6gui_button_pop_triple_click (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_button_t * BUTTON)
     SYS_CONTEXT: global system context

     BUTTON: the button to query

     Tells how many times the button has been tripleclicked.  Typical
     usage: the button is tripleclicked, released, tripleclicked,
     released several times.  Then, after all this, you want to know how
     many times it has been tripleclicked.

     *Return value:* 1 if there's a tripleclick event in the queue, 0 if
     empty.

 -- Function: void lw6gui_button_update_repeat (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_button_t * BUTTON,
          lw6gui_repeat_settings_t * REPEAT_SETTINGS, int64_t TIMESTAMP,
          int AUTO_RELEASE_ENABLED)
     SYS_CONTEXT: global system context

     BUTTON: the button to update

     REPEAT_SETTINGS: the repeat settings

     TIMESTAMP: the current ticks (milliseconds)

     Updates the repeat informations for a button, must be called
     regularly, as often as possible.

     *Return value:* none.

 -- Function: int lw6gui_button_sync (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_button_t * DST, lw6gui_button_t * SRC)
     SYS_CONTEXT: global system context

     DST: the target button object

     SRC: the source button object

     Synchronizes two button objects.  This is typically used to pass
     data from one thread to another.  This is not a simple copy, it
     will handle data such as "when was it pressed last" it an
     intelligent manner, popping src data to put it in dst, and clearing
     src.

     *Return value:* 1 if success, O if failure.

 -- Function: int lw6gui_coord_calc_xy (lw6sys_context_t * SYS_CONTEXT,
          float * DST_X, float * DST_Y, float DST_X0, float DST_Y0,
          float DST_W, float DST_H, float SRC_X, float SRC_Y, float
          SRC_X0, float SRC_Y0, float SRC_W, float SRC_H)
     SYS_CONTEXT: global system context

     DST_X: the x coord to return

     DST_Y: the y coord to return

     DST_X0: the x coord of point 0 in destination coord system

     DST_Y0: the y coord of point 0 in destination coord system

     DST_W: the width of the area in destination coord system

     DST_H: the width of the area in destination coord system

     SRC_X: the x coord in source coord system

     SRC_Y: the y coord in source coord system

     SRC_X0: the x coord of point 0 in source coord system

     SRC_Y0: the y coord of point 0 in source coord system

     SRC_W: the width of the area in source coord system

     SRC_H: the width of the area in source coord system

     Registers a "down" (press) event on a button.

     *Return value:* 1 if OK, 0 if error (unable to calculate).

 -- Function: void lw6gui_coords_fix_xy_float (lw6sys_context_t *
          SYS_CONTEXT, float * X, float * Y, int * X_FLIP, int * Y_FLIP,
          float W, float H, int X_POLARITY, int Y_POLARITY)
     SYS_CONTEXT: global system context

     X: x coord (in/out param)

     Y: y coord (in/out param)

     X_FLIP: flip on x (out param, -1 or +1)

     Y_FLIP: flip on y (out param, -1 or +1)

     W: width

     H: height

     X_POLARITY: x polarity (-1, 0 or 1)

     Y_POLARITY: y polarity (-1, 0 or 1)

     Same as 'lw6map_fix_coords' except it operates on floats.  Usefull
     for cursor and other rendering operations.  Additionnally, will
     keep track of inversions, that is to say if map is flip in one or
     another way.  Be carefull, the flip values are -1 or 1 so that it's
     easy to multiply an offset by it, for instance, but this means
     testing if flip is not 0 will always return true, you must test if
     flip is stritly positive or negative.

     *Return value:* none

 -- Function: int lw6gui_input_init (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_input_t * INPUT)
     SYS_CONTEXT: global system context

     INPUT: the input struct to initialise

     Initialises an input structure, don't use twice, it won't free a
     previous init.

     *Return value:* a pointer to the newly allocated object.

 -- Function: void lw6gui_input_quit (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_input_t * INPUT)
     SYS_CONTEXT: global system context

     INPUT: the input struct to uninitialise

     Unitialises an input structure, need to call it to free event
     queue.

     *Return value:* a pointer to the newly allocated object.

 -- Function: lw6gui_input_t * lw6gui_input_new (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates an input structure, which can be used to handle input state
     & buffer.

     *Return value:* a pointer to the newly allocated object.

 -- Function: void lw6gui_input_free (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_input_t * INPUT)
     SYS_CONTEXT: global system context

     INPUT: the input object to free.

     Deletes an input structure.

     *Return value:* none.

 -- Function: int lw6gui_input_reset (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_input_t * INPUT)
     SYS_CONTEXT: global system context

     INPUT: the input struct to reset

     Resets an input structure.  Must have been initialized before.  It
     will empty all queues and mark everything as unpressed.

     *Return value:* 1 on success, 0 if failure.

 -- Function: void lw6gui_input_update_repeat (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_input_t * INPUT, lw6gui_repeat_settings_t
          * REPEAT_SETTINGS, int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     INPUT: the input to update

     REPEAT_SETTINGS: the repeat settings (delay + interval)

     TIMESTAMP: the current ticks (milliseconds)

     Updates the repeat informations for an input, must be called
     regularly, as often as possible.

     *Return value:* none.

 -- Function: void lw6gui_input_register_change (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_input_t * INPUT)
     SYS_CONTEXT: global system context

     INPUT: the input to update

     Tells an input object that one of its descendants has been
     modified.  This will affect the return value of
     'lw6gui_input_need_sync'

     *Return value:* none.

 -- Function: int lw6gui_input_need_sync (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_input_t * INPUT)
     SYS_CONTEXT: global system context

     INPUT: the input to test

     Tests wether an input object contains was modified and needs
     synchronisation.

     *Return value:* 1 if sync is need, 0 if not.

 -- Function: int lw6gui_input_sync (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_input_t * DST, lw6gui_input_t * SRC)
     SYS_CONTEXT: global system context

     DST: the target input object

     SRC: the source input object

     Synchronizes two input objects.  This is typically used to pass
     data from one thread to another.  This is not a copy, it will
     brute-force copy the static data such as mouse position, but
     anything like a queue will be treated in a "empty source and fill
     target with data" scheme.  So source will be affected by this, the
     key buffer will be emptied, and so on.  And if there are key in the
     target buffer, they won't be overwritten but kept in front of the
     FIFO list.

     *Return value:* 1 if success, O if failure.

 -- Function: void lw6gui_input_enable_auto_release (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_input_t * INPUT)
     SYS_CONTEXT: global system context

     INPUT: input object to modify

     Enables auto_release mode, in this mode, it's assummed after some
     time any key is automatically released.

     *Return value:* none.

 -- Function: int lw6gui_joystick_check_index (lw6sys_context_t *
          SYS_CONTEXT, int I)
     SYS_CONTEXT: global system context

     I: index to check

     Checks wether the index is correct.  Does not mean the joystick
     exists, it's just to avoid out of bounds errors.

     *Return value:* 1 if within range, 0 if not.

 -- Function: void lw6gui_joystick_update_axis_x (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_joystick_t * JOYSTICK, int X, int LIMIT,
          int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     JOYSTICK: joystick to update

     X: x-axis position, as returned by the driver

     LIMIT: the limit, under this, buttons are considered unpressed.

     TIMESTAMP: current ticks (timestamp in ms)

     Updates the x axis of a joystick, this will convert an information
     of analog type such as "joystick is here" to a pad-like information
     such as "pressed in that direction".

     *Return value:* 1 if within range, 0 if not.

 -- Function: void lw6gui_joystick_update_axis_y (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_joystick_t * JOYSTICK, int Y, int LIMIT,
          int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     JOYSTICK: joystick to update

     LIMIT: the limit, under this, buttons are considered unpressed.

     TIMESTAMP: current ticks (timestamp in ms)

     Updates the y axis of a joystick, this will convert an information
     of analog type such as "joystick is here" to a pad-like information
     such as "pressed in that direction".

     *Return value:* 1 if within range, 0 if not.

 -- Function: void lw6gui_joystick_update_repeat (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_joystick_t * JOYSTICK,
          lw6gui_repeat_settings_t * REPEAT_SETTINGS, int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     JOYSTICK: the joystick to update

     REPEAT_SETTINGS: the repeat settings (delay + interval)

     TIMESTAMP: the current ticks (milliseconds)

     Updates the repeat informations for a joystick, must be called
     regularly, as often as possible.

     *Return value:* none.

 -- Function: int lw6gui_joystick_sync (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_joystick_t * DST, lw6gui_joystick_t * SRC)
     SYS_CONTEXT: global system context

     DST: the target joystick object

     SRC: the source joystick object

     Synchronizes two joystick objects.  This is typically used to pass
     data from one thread to another.

     *Return value:* 1 if success, O if failure.

 -- Function: void lw6gui_joystick_get_move_pad (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_joystick_t * JOYSTICK,
          lw6gui_move_pad_t * MOVE_PAD)
     SYS_CONTEXT: global system context

     JOYSTICK: the joystick to query

     MOVE_PAD: the structure which will contain the results

     Returns the state of the joystick in a uniform, non-device specific
     structure containing only the up/down/left/right information.

     *Return value:* none, the value are stored in 'move_pad'.

 -- Function: int lw6gui_keyboard_check_keysym (lw6sys_context_t *
          SYS_CONTEXT, int KEYSYM)
     SYS_CONTEXT: global system context

     KEYSYM: the keysym to check

     Tells wether the keysym is valid or not.

     *Return value:* 1 if valid, 0 if not

 -- Function: lw6gui_keypress_t * lw6gui_keyboard_pop_keypress
          (lw6sys_context_t * SYS_CONTEXT, lw6gui_keyboard_t * KEYBOARD)
     SYS_CONTEXT: global system context

     KEYBOARD: the keyboard structure which stores keyboard state

     Pops (in FIFO mode) a keypress stored in the keyboard buffer.  You
     must free the obtained keypress object after you're done with it.

     *Return value:* a newly allocated pointer, or NULL if no keypress
     pending.

 -- Function: int lw6gui_keyboard_is_pressed (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_keyboard_t * KEYBOARD, int KEYSYM)
     SYS_CONTEXT: global system context

     KEYBOARD: the keyboard structure which stores keyboard state

     Tells wether a key is pressed or not.  The function will test out
     of bound values.

     *Return value:* 1 if pressed, 0 if not.

 -- Function: int lw6gui_keyboard_register_key_down (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_keyboard_t * KEYBOARD, int KEYSYM, int
          UNICODE, char * LABEL, int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     KEYBOARD: the keyboard structure which will store the keypress

     KEYSYM: the keysym for the keypress

     UNICODE: the ASCII/unicode code for the keypress

     LABEL: the label for the keypress

     TIMESTAMP: the current ticks (timestamp in ms)

     Registers a keypress event, that is, puts it in the event queue.
     This function does not take an 'lw6gui_keypress_t' structure but
     separated args, this is because it will construct the object
     internally.  You may free 'label' after calling this, an internal
     copy will be done.  This function will also maintain the array of
     key states up to date.

     *Return value:* 1 if success, O if failure.

 -- Function: int lw6gui_keyboard_register_key_up (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_keyboard_t * KEYBOARD, int KEYSYM)
     SYS_CONTEXT: global system context

     KEYBOARD: the keyboard structure which will store the keypress

     KEYSYM: the keysym for the keypress

     Registers a key release event.

     *Return value:* 1 if success, O if failure.

 -- Function: void lw6gui_keyboard_update_repeat (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_keyboard_t * KEYBOARD,
          lw6gui_repeat_settings_t * REPEAT_SETTINGS, int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     KEYBOARD: the keyboard to update

     REPEAT_SETTINGS: the repeat settings (delay + interval)

     TIMESTAMP: the current ticks (milliseconds)

     Updates the repeat informations for a keyboard, must be called
     regularly, as often as possible.

     *Return value:* none.

 -- Function: int lw6gui_keyboard_sync (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_keyboard_t * DST, lw6gui_keyboard_t * SRC)
     SYS_CONTEXT: global system context

     DST: the target keyboard object

     SRC: the source keyboard object

     Synchronizes two keyboard objects.  This is typically used to pass
     data from one thread to another.  Will pop the src queue to fill
     the dst queue.

     *Return value:* 1 if success, O if failure.

 -- Function: void lw6gui_keyboard_get_move_pad (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_keyboard_t * KEYBOARD,
          lw6gui_move_pad_t * MOVE_PAD)
     SYS_CONTEXT: global system context

     KEYBOARD: the keyboard to query

     MOVE_PAD: the structure which will contain the results

     Returns the state of the keyboard in a uniform, non-device specific
     structure containing only the up/down/left/right information.

     *Return value:* none, the value are stored in 'move_pad'.

 -- Function: lw6gui_keypress_t * lw6gui_keypress_new (lw6sys_context_t
          * SYS_CONTEXT, int KEYSYM, int UNICODE, const char * LABEL)
     SYS_CONTEXT: global system context

     KEYSYM: the keysym to use

     UNICODE: the unicode value for this keysym

     LABEL: the label (optional, might be NULL)

     Creates a keypress structure, the only reason for needing a
     contructor is that the label field needs be duplicated.

     *Return value:* a pointer to the newly allocated object.

 -- Function: void lw6gui_keypress_free (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_keypress_t * KEYPRESS)
     SYS_CONTEXT: global system context

     KEYPRESS: the keypress object to free.

     Deletes a keypress structure.

     *Return value:* none.

 -- Function: char * lw6gui_keypress_repr (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_keypress_t * KEYPRESS)
     SYS_CONTEXT: global system context

     KEYPRESS: the keypress to work on

     Returns a human-readable representation of the keypress.

     *Return value:* a newly allocated string

 -- Function: lw6gui_look_t * lw6gui_look_new (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_style_t * MAP_STYLE)
     SYS_CONTEXT: global system context

     MAP_STYLE: map_style to use as a base

     Create a new look object, a look is basically a style plus some
     dynamic parameters.

     *Return value:* newly created object.

 -- Function: void lw6gui_look_free (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_look_t * LOOK)
     SYS_CONTEXT: global system context

     LOOK: look object to free

     Frees a look and all its members.

     *Return value:* none.

 -- Function: int lw6gui_look_memory_footprint (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_look_t * LOOK)
     SYS_CONTEXT: global system context

     LOOK: look object to query

     Gives the memory taken by this object in memory.

     *Return value:* number of bytes.

 -- Function: char * lw6gui_look_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6gui_look_t * LOOK)
     SYS_CONTEXT: global system context

     LOOK: look object to describe

     Returns a readable description of the object.

     *Return value:* newly allocated string.

 -- Function: int lw6gui_look_set (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_look_t * LOOK, char * KEY, char * VALUE)
     SYS_CONTEXT: global system context

     LOOK: look object to modify

     KEY: the key to change

     VALUE: the new value for the key

     Sets a new value for a given key in the look.  The value is always
     a string, it will be converted/casted to the right type if needed.

     *Return value:* 1 on success, 0 on failure.

 -- Function: char * lw6gui_look_get (lw6sys_context_t * SYS_CONTEXT,
          const lw6gui_look_t * LOOK, char * KEY)
     SYS_CONTEXT: global system context

     LOOK: look object to query

     KEY: the key to get

     Gets a new value for a given key in the look.  The value is always
     a string, it will be converted/casted from the right type if
     needed.

     *Return value:* dynamically allocated string.

 -- Function: int lw6gui_look_is_same (lw6sys_context_t * SYS_CONTEXT,
          const lw6gui_look_t * LOOK_A, const lw6gui_look_t * LOOK_B)
     SYS_CONTEXT: global system context

     LOOK_A: first object to compare

     LOOK_B: second object to compare

     Compares two look objects, doing recursive comparisons.  This can
     be very usefull if, for instance, a graphics renderer is using some
     contextual objects that depend on the look (colors?)  and need to
     be updated/regenerated on a look change

     *Return value:* 1 if they are the same, 0 if not.

 -- Function: lw6gui_look_t * lw6gui_look_dup (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_look_t * LOOK)
     SYS_CONTEXT: global system context

     LOOK: object to duplicate

     Duplicates a look object, performing recursive copies.

     *Return value:* newly allocated object.

 -- Function: void lw6gui_look_fix (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_look_t * LOOK)
     SYS_CONTEXT: global system context

     LOOK: look object to modify

     Peforms sanity checks and modifies the look if needed, to make all
     values fit within acceptable ranges, among other things.

     *Return value:* none.

 -- Function: int lw6gui_look_zoom_in (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_look_t * LOOK, float ZOOM_STEP)
     SYS_CONTEXT: global system context

     LOOK: look object to act upon

     ZOOM_STEP: how much we should zoom, 2.0 means 2 times bigger

     Zooms in, the function does not only multiplicates the current
     zoom, it also performs sanity checks.

     *Return value:* 1 if zoom was changed, 0 if not.

 -- Function: int lw6gui_look_zoom_out (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_look_t * LOOK, float ZOOM_STEP)
     SYS_CONTEXT: global system context

     LOOK: look object to act upon

     ZOOM_STEP: how much we should zoom, 2.0 means 2 times smaller

     Zooms out, the function does not only divides the current zoom, it
     also performs sanity checks.

     *Return value:* 1 if zoom was changed, 0 if not.

 -- Function: lw6gui_menu_t * lw6gui_menu_new (lw6sys_context_t *
          SYS_CONTEXT, const char * TITLE, const char * HELP, const char
          * POPUP, const char * ESC, int ENABLE_ESC)
     SYS_CONTEXT: global system context

     TITLE: the string to be displayed, what the user sees.  Can be
     freed after the call is done, function will make a copy internally.

     HELP: a string introducing the menu, describing what it does,
     giving hints on how to use it.

     POPUP: a string to be displayed in popup mode when menu is
     displayed for the first time.

     ESC: the label to be displayed in the ESC button

     ENABLE_ESC: wether to enable the escape button.

     Constructs a new menu object.  Note that you can always call other
     functions to modify it afterwards.

     *Return value:* a pointer to the newly allocated object.

 -- Function: void lw6gui_menu_free (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * MENU)
     SYS_CONTEXT: global system context

     MENU: a pointer to the menu.

     Frees the menu, checking if things are OK before doing so.

     *Return value:* none.

 -- Function: int lw6gui_menu_memory_footprint (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU)
     SYS_CONTEXT: global system context

     MENU: a pointer to the menu.

     Gets the memory occupied by the menu.  Could be usefull to help a
     garbage collector taking decisions or reporting erros, for
     instance.

     *Return value:* the number of bytes used.

 -- Function: char * lw6gui_menu_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6gui_menu_t * MENU)
     SYS_CONTEXT: global system context

     MENU: a pointer to the menu.

     Constructs a readable description of the object.  Usefull for
     debugging, or to introspect things using scripts, at run-time.
     Does not necessarly describe all the informations about the object,
     but helps knowing what it is.

     *Return value:* a string describing the object, must be freed.

 -- Function: void lw6gui_menu_set_title (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, const char * TITLE)
     SYS_CONTEXT: global system context

     MENU: a pointer to the menu.

     TITLE: the new title, you can free it after calling the function,
     an internal copy will be made.

     Change the title of the menu.  Use this function to change the
     title, don't try to access the struct directly.  The idea is to
     have safe memory management.

     *Return value:* none

 -- Function: void lw6gui_menu_set_help (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * MENU, const char * HELP)
     SYS_CONTEXT: global system context

     MENU: a pointer to the menu.

     HELP: the new help, you can free it after calling the function, an
     internal copy will be made.

     Change the help of the menu.  Use this function to change the help,
     don't try to access the struct directly.  The idea is to have safe
     memory management.

     *Return value:* none

 -- Function: void lw6gui_menu_set_popup (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, const char * POPUP)
     SYS_CONTEXT: global system context

     MENU: a pointer to the menu.

     POPUP: the new popup, you can free it after calling the function,
     an internal copy will be made.

     Change the popup of the menu.  That is to say, its popup.  Use this
     function to change the popup, don't try to access the struct
     directly.  The idea is to have safe memory management.

     *Return value:* none

 -- Function: void lw6gui_menu_close_popup (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU)
     SYS_CONTEXT: global system context

     MENU: a pointer to the menu.

     Closes the popup, in practice, this is equivalent to setting the
     popup string to "" or NULL.

     *Return value:* none

 -- Function: int lw6gui_menu_has_popup (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * MENU)
     SYS_CONTEXT: global system context

     MENU: a pointer to the menu.

     Tells wether a popup is defined.  Behavior is simplistic, at
     creation (when a non-NULL non-empty popup string has been set) then
     the popup is displayed.  In this state, popup is considered to be
     defined.  Then it can be close, and after this action the popup
     ain't here anymore, program continues the way it started.

     *Return value:* 1 if has popup, 0 if does not

 -- Function: lw6gui_menuitem_t * lw6gui_menu_get_item (lw6sys_context_t
          * SYS_CONTEXT, lw6gui_menu_t * MENU, int POSITION)
     SYS_CONTEXT: global system context

     MENU: the menu we want to query

     POSITION: the order of the item we want

     Gets the menu item at the given position.  First item is 0, last is
     N-1.  Returns a pointer on the real object, not a copy.

     *Return value:* a pointer to a menu item, NULL if out of range.

 -- Function: int lw6gui_menu_select (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * MENU, int POSITION, int ALLOW_SCROLL, int64_t
          NOW)
     SYS_CONTEXT: global system context

     MENU: the menu we want to modify

     POSITION: the position of the item we want to select

     ALLOW_SCROLL: wether scrolling should be allowed when displaying it

     NOW: the current time, as a timestamp.

     Selects the item at the given position.  Use this function to be
     sure that only one item is selected, and all other states are
     consistent.  Timestamp is needed for the sake of eye-candy.

     *Return value:* 1 if success, 0 if failure (out of range).

 -- Function: void lw6gui_menu_select_esc (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, int STATE, int64_t NOW)
     SYS_CONTEXT: global system context

     MENU: the menu we want to modify

     STATE: 1 to select, 0 to unselect

     NOW: the current time, as a timestamp.

     Selects the escape item, this does not affect other items, it's
     mostly.  to handle eye candy.

     *Return value:* none.

 -- Function: void lw6gui_menu_enable_esc (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, int STATE, int64_t NOW)
     SYS_CONTEXT: global system context

     MENU: the menu we want to modify

     STATE: 1 to enable, 0 to disable

     NOW: the current time, as a timestamp.

     Enables the escape item, this does not affect other items, it's
     mostly.  to handle eye candy.

     *Return value:* none.

 -- Function: int lw6gui_menu_scroll_up (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * MENU)
     SYS_CONTEXT: global system context

     MENU: the menu to scroll

     Scrolls a menu up, used as a callback for mouse wheel up for
     instance.  The idea is just to decrement the first displayed item
     index.

     *Return value:* 1 if OK, 0 if failed (out of range).

 -- Function: int lw6gui_menu_scroll_down (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU)
     SYS_CONTEXT: global system context

     MENU: the menu to scroll

     Scrolls a menu down, used as a callback for mouse wheel down for
     instance.  The idea is just to increment the first displayed item
     index.

     *Return value:* 1 if OK, 0 if failed (out of range).

 -- Function: int lw6gui_menu_set_breadcrumbs (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, lw6sys_list_t *
          BREADCRUMBS)
     SYS_CONTEXT: global system context

     MENU: the menu to scroll

     BREADCRUMBS: list of strings containing breadcrumbs

     Set the breadcrumbs, that's to say the readable, logical path to
     get to a given menu.  This is just eye candy, not linked to any
     logic at this level.

     *Return value:* 1 if OK, 0 if failed.

 -- Function: void lw6gui_menu_center (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * MENU, int POSITION, int MAX_DISPLAYED_ITEMS)
     SYS_CONTEXT: global system context

     MENU: the menu to center

     POSITION: the position of the menuitem to be put in the center

     MAX_DISPLAYED_ITEMS: the maximum number of items displayed

     Centers the menu on a given menuitem.  Typically used when pushing
     a menu with a menuitem selected 'anywhere' in the list.

     *Return value:* none.

 -- Function: int lw6gui_menu_insert (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * MENU, lw6gui_menuitem_t * MENUITEM, int
          POSITION, int64_t NOW)
     SYS_CONTEXT: global system context

     MENU: the menu we want to modify

     MENUITEM: the item to insert

     POSITION: the position the new item will occupy ("insert before"
     mode)

     NOW: the current time, as a timestamp.

     Inserts the given item in the menu.  All items starting at the
     insert position will be "pushed" (that is, their position
     incremented by 1).  Once the menuitem is inserted, the menu object
     will take care of memory management and automatically free it when
     needed.

     *Return value:* 1 if success, 0 if failure (memory problem, out of
     range).

 -- Function: int lw6gui_menu_append (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * MENU, lw6gui_menuitem_t * MENUITEM, int64_t
          NOW)
     SYS_CONTEXT: global system context

     MENU: the menu we want to modify

     MENUITEM: the item to insert

     NOW: the current time, as a timestamp.

     Appends the given item to the menu.  Once the menuitem is appended,
     the menu object will take care of memory management and
     automatically free it when needed.

     *Return value:* 1 if success, 0 if failure (memory problem).

 -- Function: int lw6gui_menu_remove (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * MENU, int POSITION, int64_t NOW)
     SYS_CONTEXT: global system context

     MENU: the menu we want to modify

     POSITION: the item to insert

     NOW: the current time, as a timestamp.

     Removes an item from the menu.  It will automatically be freed.

     *Return value:* 1 if success, 0 if failure (out of range).

 -- Function: int lw6gui_menu_remove_all (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, int64_t NOW)
     SYS_CONTEXT: global system context

     MENU: the menu we want to modify

     NOW: the current time, as a timestamp.

     Removes all items from the menu, usefull when one wants to
     repopulate the items completely, from scratch.

     *Return value:* 1 if success, 0 if failure.

 -- Function: void lw6gui_menu_update_display_range (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, int MAX_DISPLAYED_ITEMS)
     SYS_CONTEXT: global system context

     MENU: the menu concerned

     MAX_DISPLAYED_ITEMS: the maximum number of items to display at once

     Updates the display range.  The reason for having this is that the
     first item, that is, how far we scroll in a very long menu, depends
     on the previous position.  Plus you have to handle limit cases
     (begin/end).  Thus, this function, which will automatically pick-up
     a suitable position.  Of course, 'first_item_displayed' is not
     necessarly equal to 'selected_item'.

     *Return value:* none.

 -- Function: int lw6gui_menu_insert_for_id_use (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, char * LABEL, char *
          TOOLTIP, int VALUE, int ENABLED, int SELECTED, int COLORED,
          int POSITION, int64_t NOW)
     SYS_CONTEXT: global system context

     MENU: the menu to work on

     LABEL: the label of the menuitem to append

     TOOLTIP: the tooltip of the menuitem to append

     VALUE: the value of the menuitem to append

     ENABLED: wether the inserted menuitem should be enabled

     SELECTED: wether the inserted menuitem should be selected

     COLORED: wether the inserted menuitem should use value as its color

     NOW: current time (timestamp)

     Inserts a menu item at the given position.  The idea is that the
     menu item object is automatically constructed on the fly, and an id
     is returned, which can be passed to '_using_id' menu-related
     functions.  This is typically for using in scripts.  The idea is
     that the script just keeps a copy of the id returned, and can this
     way operate directly on the menuitem without keeping a pointer, a
     smob or anything internally.  From the C point of view, having a
     real C structure enables persistent data from one display to the
     other, and this is nice and conveninent.  I acknowledge the
     prototype is scary.

     *Return value:* 0 if error, or else an id which will later be used
     with '_using_id' functions.

 -- Function: int lw6gui_menu_append_for_id_use (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, char * LABEL, char *
          TOOLTIP, int VALUE, int ENABLED, int SELECTED, int COLORED,
          int64_t NOW)
     SYS_CONTEXT: global system context

     MENU: the menu to work on

     LABEL: the label of the menuitem to append

     TOOLTIP: the tooltip of the menuitem to append

     VALUE: the value of the menuitem to append

     ENABLED: wether the appended menuitem should be enabled

     SELECTED: wether the appended menuitem should be selected

     COLORED: wether the appended menuitem should use value as its color

     NOW: current time (timestamp)

     Appends a menuitem using the same logic as
     'lw6gui_menu_insert_for_id_use' that is to say a parameter is
     returned which can later be used to directly operate on a given
     menuitem, without having its pointer, and even if its position
     changes.

     *Return value:* 0 if error, or else an id which will later be used
     with '_using_id' functions.

 -- Function: int lw6gui_menu_remove_using_id (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, int MENUITEM_ID, int64_t
          NOW)
     SYS_CONTEXT: global system context

     MENU: the menu to work on

     MENUITEM_ID: the id of the menuitem to remove

     NOW: current time (timestamp)

     Deletes the menuitem with the given id.  Very important: the id is
     not the position.  Id are arbitrary numbers that stick to
     menuitems, but they are not directly linked with the position.
     This function is practical to use if, for some reason, you don't
     have the pointer on the menuitem.

     *Return value:* 1 if success, 0 if failure (out of range).

 -- Function: void lw6gui_menu_sync_using_id (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, int MENUITEM_ID, char *
          LABEL, char * TOOLTIP, int VALUE, int ENABLED, int SELECTED,
          int COLORED, int64_t NOW)
     SYS_CONTEXT: global system context

     MENU: the menu to work on

     MENUITEM_ID: the id of the menuitem to synchronize

     LABEL: menu label

     TOOLTIP: menu tooltip

     VALUE: value

     ENABLED: wether it's usable or not

     SELECTED: 1 if the menuite is current item

     COLORED: wether to use color

     NOW: current time (timestamp)

     Updates the menuitem with the given id.  Very important: the id is
     not the position.  Id are arbitrary numbers that stick to
     menuitems, but they are not directly linked with the position.
     This function is practical to use if, for some reason, you don't
     have the pointer on the menuitem.  In practice, it's heavily used
     in the game to transmit informations from the scripts to the core C
     engine.  Additionnaly, this function will automatically synchronize
     the 'selected_item' field of the menu struct.

     *Return value:* 1 if success, 0 if failure (out of range).

 -- Function: int lw6gui_menu_is_same (lw6sys_context_t * SYS_CONTEXT,
          const lw6gui_menu_t * MENU_A, const lw6gui_menu_t * MENU_B)
     SYS_CONTEXT: global system context

     MENU_A: first item to compare

     MENU_B: second item to compare

     Compares two menus.

     *Return value:* 1 if they are the same, 0 if not

 -- Function: lw6gui_menu_t * lw6gui_menu_dup (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_menu_t * MENU)
     SYS_CONTEXT: global system context

     MENU: the menu to duplicate

     Duplicates a menu structure.

     *Return value:* a pointer to the new menu.

 -- Function: int lw6gui_menu_sync (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * DST, lw6gui_menu_t * SRC)
     SYS_CONTEXT: global system context

     DST: the target menu

     SRC: the source menu

     Synchronizes two menus, this supposes that they represent the same
     menu, but simply in a different state.  This function does not
     really copy src to dst, it has a special behavior, indeed
     everything is copied from src to dst, except the
     'first_item_displayed' and 'nb_items_displayed' which are taken
     from dst and copied to src.  This is because in practise, those
     values are updated in the display loop/thread, which is the one
     which uses the target.  This is not very orthodox, but should work.

     *Return value:* 1 if success, 0 if failure

 -- Function: lw6gui_menuitem_t * lw6gui_menuitem_new (lw6sys_context_t
          * SYS_CONTEXT, const char * LABEL, const char * TOOLTIP, int
          VALUE, int ENABLED, int SELECTED, int COLORED)
     SYS_CONTEXT: global system context

     LABEL: the string to be displayed, what the user sees.  Can be
     freed after the call is done, function will make a copy internally.

     TOOLTIP: the string to be displayed as a tooltip, describing the
     menu item in detail.  Can be NULL if you don't want to use this
     feature.

     VALUE: the value.  No GUI function uses this, this is the "real"
     value associated to the item.

     ENABLED: wether the menu item can be selected, used, and so on

     SELECTED: wether the menu item is the item selected among all menu
     items.

     COLORED: wetherr the menu item must, when drawn, be colored
     according to its value.

     Constructs a new menuitem object.  Note that you can always call
     other functions to modify these values afterwards, this might
     change rendering since 'lw6gui_menuitem_set_value' or
     'lw6gui_menuitem_set_label' will, for instance, modify the "when
     was that item last modified" information.

     *Return value:* a pointer to the newly allocated object.

 -- Function: void lw6gui_menuitem_free (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menuitem_t * MENUITEM)
     SYS_CONTEXT: global system context

     MENUITEM: a pointer to the menuitem.

     Frees the menuitem, checking if things are OK before doing so.

     *Return value:* none.

 -- Function: int lw6gui_menuitem_memory_footprint (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menuitem_t * MENUITEM)
     SYS_CONTEXT: global system context

     MENUITEM: a pointer to the menuitem.

     Gets the memory occupied by the menuitem.  Could be usefull to help
     a garbage collector taking decisions or reporting erros, for
     instance.

     *Return value:* the number of bytes used.

 -- Function: char * lw6gui_menuitem_repr (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_menuitem_t * MENUITEM)
     SYS_CONTEXT: global system context

     MENUITEM: a pointer to the menuitem.

     Constructs a readable description of the object.  Usefull for
     debugging, or to introspect things using scripts, at run-time.
     Does not necessarly describe all the informations about the object,
     but helps knowing what it is.

     *Return value:* a string describing the object, must be freed.

 -- Function: void lw6gui_menuitem_set_label (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menuitem_t * MENUITEM, const char * LABEL,
          int64_t NOW)
     SYS_CONTEXT: global system context

     MENUITEM: a pointer to the menuitem.

     LABEL: the new label, you can free it after calling the function,
     an internal copy will be made.

     NOW: the current time, as a timestamp.

     Change the label of the menu item.  That is to say, what the user
     sees.  Use this function to change the menuitem value, don't try to
     access the struct directly.  The idea is 1) to have safe memory
     management and 2) to keep the 'last_change' member up to date.  It
     can be later used for eye-candy effects.

     *Return value:* none

 -- Function: void lw6gui_menuitem_set_tooltip (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menuitem_t * MENUITEM, const char *
          TOOLTIP, int64_t NOW)
     SYS_CONTEXT: global system context

     MENUITEM: a pointer to the menuitem.

     TOOLTIP: the new tooltip, you can free it after calling the
     function, an internal copy will be made.

     NOW: the current time, as a timestamp.

     Change the tooltip of the menu item (the explanation of what the
     item is about) Use this function to change the menuitem value,
     don't try to access the struct directly.  The idea is 1) to have
     safe memory management and 2) to keep the 'last_change' member up
     to date.  It can be later used for eye-candy effects.

     *Return value:* none

 -- Function: void lw6gui_menuitem_set_value (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menuitem_t * MENUITEM, int VALUE, int64_t
          NOW)
     SYS_CONTEXT: global system context

     MENUITEM: a pointer to the menuitem.

     VALUE: the new value.

     NOW: the current time, as a timestamp.

     Changes the value of a menuitem.  This is the internal value, not
     what the user sees.  Use this function to change the menuitem
     value, don't try to access the struct directly.  The idea is to
     keep the 'last_change' member up to date.  It can be later used for
     eye-candy effects.

     *Return value:* none

 -- Function: void lw6gui_menuitem_select (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menuitem_t * MENUITEM, int STATE, int64_t
          NOW)
     SYS_CONTEXT: global system context

     MENUITEM: a pointer to the menuitem.

     STATE: 1 to select, 0 to unselect

     NOW: the current time, as a timestamp.

     Switches the menuitem to (un)selected state.  Use this function,
     don't try to modify the struct members directly.  The idea is to
     have the 'last_select' parameter up to date.  It can be later used
     for eye-candy effects.

     *Return value:* none

 -- Function: void lw6gui_menuitem_enable (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menuitem_t * MENUITEM, int STATE, int64_t
          NOW)
     SYS_CONTEXT: global system context

     MENUITEM: a pointer to the menuitem.

     STATE: 1 to enable, 0 to disable

     NOW: the current time, as a timestamp.

     Switches the menuitem to enabled/disabled state.  Use this
     function, don't try to modify the struct members directly.  The
     idea is to have the 'last_select' parameter up to date.  It can be
     later used for eye-candy effects.

     *Return value:* none

 -- Function: u_int32_t lw6gui_menuitem_checksum (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menuitem_t * MENUITEM, lw6gui_look_t *
          LOOK)
     SYS_CONTEXT: global system context

     MENUITEM: the menuitem we want to identify

     Returns a checksum which can be used to know, for instance, wether
     the menuitem has changed or not, and if we should redraw it.

     *Return value:* a checksum.

 -- Function: int lw6gui_menuitem_is_same (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_menuitem_t * MENUITEM_A, const
          lw6gui_menuitem_t * MENUITEM_B)
     SYS_CONTEXT: global system context

     MENUITEM_A: first item to compare

     MENUITEM_B: second item to compare

     Compares two menuitems.

     *Return value:* 1 if they are the same, 0 if not

 -- Function: lw6gui_menuitem_t * lw6gui_menuitem_dup (lw6sys_context_t
          * SYS_CONTEXT, const lw6gui_menuitem_t * MENUITEM)
     SYS_CONTEXT: global system context

     MENUITEM: the menuitem to duplicate

     The menuitem to duplicate.

     *Return value:* a pointer to the duplicted menuitem.

 -- Function: int lw6gui_menuitem_sync (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menuitem_t * DST, lw6gui_menuitem_t * SRC)
     SYS_CONTEXT: global system context

     DST: the target menuitem

     SRC: the source menuitem

     Synchronizes two menuitems, this supposes that they represent the
     same item, but simply in a different state.

     *Return value:* 1 if success, 0 if failure

 -- Function: void lw6gui_mouse_register_move (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_mouse_t * MOUSE, int SCREEN_POS_X, int
          SCREEN_POS_Y, int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     MOUSE: the mouse object to work on

     SCREEN_POS_X: the x position on screen

     SCREEN_POS_Y: the y position on screen

     TIMESTAMP: current timestamp

     Registers a mouse move event.

     *Return value:* note.

 -- Function: int lw6gui_mouse_poll_move (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_mouse_t * MOUSE, int * SCREEN_POS_X, int *
          SCREEN_POS_Y)
     SYS_CONTEXT: global system context

     MOUSE: the mouse object to poll

     SCREEN_POS_X: pointer to the x position (can be NULL), will be
     updated even if no move

     SCREEN_POS_Y: pointer to the y position (can be NULL), will be
     updated even if no move

     Asks wether the mouse has moved or not.

     *Return value:* 1 if mouse was moved since last call, 0 if not.

 -- Function: void lw6gui_mouse_update_repeat (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_mouse_t * MOUSE, lw6gui_repeat_settings_t
          * REPEAT_SETTINGS, int64_t TIMESTAMP)
     MOUSE: the mouse to update

     REPEAT_SETTINGS: the repeat settings (delay + interval)

     TIMESTAMP: the current ticks (milliseconds)

     Updates the repeat informations for a mouse, must be called
     regularly, as often as possible.

     *Return value:* none.

 -- Function: int lw6gui_mouse_sync (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_mouse_t * DST, lw6gui_mouse_t * SRC)
     SYS_CONTEXT: global system context

     DST: the target mouse object

     SRC: the source mouse object

     Synchronizes two mouse objects.  This is typically used to pass
     data from one thread to another.  Will handle "mouse move"
     attribute and clear it in src if needed while setting it in dst.

     *Return value:* 1 if success, O if failure.

 -- Function: void lw6gui_mouse_drag_begin (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_mouse_t * MOUSE)
     SYS_CONTEXT: global system context

     MOUSE: mouse struct to update

     To be called when one wants to start recording a drag session,
     typically when left button is pressed.

     *Return value:* none.

 -- Function: void lw6gui_mouse_drag_end (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_mouse_t * MOUSE)
     SYS_CONTEXT: global system context

     MOUSE: mouse struct to update

     To be called when one wants to stop recording a drag session,
     typically when left button is released.

     *Return value:* none.

 -- Function: int lw6gui_mouse_drag_pop (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_mouse_t * MOUSE, int * DELTA_X, int * DELTA_Y, int *
          POS_X, int * POS_Y, int * SPEED_X, int * SPEED_Y)
     SYS_CONTEXT: global system context

     MOUSE: mouse struct to query

     DELTA_X: x movement (on screen, out param can be NULL)

     DELTA_Y: y movement (on screen, out param can be NULL)

     POS_X: x pos (on screen, out param can be NULL)

     POS_Y: y pos (on screen, out param can be NULL)

     SPEED_X: x speed (on screen, out param can be NULL)

     SPEED_Y: y speed (on screen, out param can be NULL)

     To be called when one wants to stop recording a drag session,
     typically when left button is released.

     *Return value:* none.

 -- Function: int lw6gui_point_is_inside_rect (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_point_t POINT, const lw6gui_rect_t * RECT)
     SYS_CONTEXT: global system context

     POINT: point to test

     RECT: rectangle in which point is supposed to be

     Tests wether a point is inside a rectangle, this is typically used
     to know if a point is inside the right texture or if we're outside.

     *Return value:* 1 if OK, 0 if outside

 -- Function: int lw6gui_power_of_two_ge (lw6sys_context_t *
          SYS_CONTEXT, int INPUT)
     SYS_CONTEXT: global system context

     INPUT: the value to approach

     Finds the closest power of two, which is at least greater or equal
     to input.  Typically used to size textures.

     *Return value:* a power of two.

 -- Function: int lw6gui_power_of_two_le (lw6sys_context_t *
          SYS_CONTEXT, int INPUT)
     SYS_CONTEXT: global system context

     INPUT: the value to approach

     Finds the closest power of two, which is equal of inferior to
     input.  Typically used to size textures.

     *Return value:* a power of two.

 -- Function: int lw6gui_quad_is_inside_rect (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_quad_t * QUAD, const lw6gui_rect_t *
          RECT)
     SYS_CONTEXT: global system context

     QUAD: quad to test

     RECT: rectangle in which quad is supposed to be

     Tests wether a quad is inside a rectangle, this is typically used
     to know if a quad is inside the right texture or if we're outside.

     *Return value:* 1 if OK, 0 if outside

 -- Function: int lw6gui_rect_array_init (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_rect_array_t * RECT_ARRAY, int W, int H,
          int TILE_SIZE, int BORDER_SIZE)
     SYS_CONTEXT: global system context

     RECT_ARRAY: the rectangle array to initializae

     W: width of the zone to initialize

     H: height of the zone to initialize

     TILE_SIZE: tile size, that is, width and height of sub rectangles

     BORDER_SIZE: border to add so that sub rectangles overlap

     Initializes a rect array structure, this is usefull for texture
     handling, it builds an array of sub-rectangle which slightly
     overlap each other.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6gui_rect_array_get_tile_by_source_xy
          (lw6sys_context_t * SYS_CONTEXT, const lw6gui_rect_array_t *
          RECT_ARRAY, lw6gui_rect_t * RECT, int * I, int SOURCE_X, int
          SOURCE_Y)
     SYS_CONTEXT: global system context

     RECT_ARRAY: the rectangle array to initializae

     RECT: the sub-rectangle (out param)

     I: the index of the sub-rectangle (out param)

     SOURCE_X: the x position on the global rect array

     SOURCE_Y: the y position on the global rect array

     Finds out which sub-rectangle is the right one, given a source
     position.  The output values are a correctly initialized
     sub-rectangle with relative position set plus its index within the
     container rectangle array.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6gui_rect_array_get_tile_by_i (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_rect_array_t * RECT_ARRAY,
          lw6gui_rect_t * RECT, int I)
     SYS_CONTEXT: global system context

     RECT_ARRAY: the rectangle array to initializae

     RECT: the sub-rectangle (out param)

     I: the index of the sub-rectangle

     Finds out which sub-rectangle is the right one, given a source
     position.  The output value is a correctly initialized
     sub-rectangle with relative position set.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6gui_rect_array_get_tile_and_quad (lw6sys_context_t
          * SYS_CONTEXT, const lw6gui_rect_array_t * RECT_ARRAY,
          lw6gui_rect_t * RECT, int * I, lw6gui_quad_t * QUAD, const
          lw6gui_quad_t * SOURCE_QUAD, int X_POLARITY, int Y_POLARITY)
     SYS_CONTEXT: global system context

     RECT_ARRAY: the rectangle array to initializae

     RECT: the sub-rectangle (out param)

     I: the index of the sub-rectangle (out param)

     QUAD: the 4 corresponding points within the sub-rectangle (out
     param)

     SOURCE_QUAD: 4 points within the container rectangle array

     X_POLARITY: polarity along the X axis

     Y_POLARITY: polarity along the Y axis

     Finds out which sub-rectangle is the right one, given 4 points as
     an input, and places these 4 points on the sub-rectangle, taking in
     account the polarity.  This is typically used for texture mapping.
     Note that a rectangle array can't handle all requests, it need have
     the good size, granularity.

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6gui_rect_init_x1y1x2y2 (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_rect_t * RECT, int X1, int Y1, int X2, int
          Y2)
     SYS_CONTEXT: global system context

     RECT: the structure to initialize

     X1: x for top left corner

     Y1: y for top left corner

     X2: x for bottom right corner

     Y2: y for bottom right corner

     Initializes a rect structure, will calculate w & h.

     *Return value:* none.

 -- Function: void lw6gui_rect_init_xywh (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_rect_t * RECT, int X, int Y, int W, int H)
     SYS_CONTEXT: global system context

     RECT: the structure to initialize

     X: x for top left corner

     Y: y for top left corner

     W: width

     H: height

     Initializes a rect structure, will calculate x2 & y2.

     *Return value:* none.

 -- Function: void lw6gui_rect_clip (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_rect_t * DST, const lw6gui_rect_t * SRC, const
          lw6gui_rect_t * CLIP)
     SYS_CONTEXT: global system context

     DST: the structure which will contain the result

     SRC: the source rect

     CLIP: the clipping rect (boundaries)

     Clips a rect (think of rectangle clips).

     *Return value:* none.

 -- Function: int lw6gui_segment_is_inside_rect (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_segment_t * SEGMENT, const
          lw6gui_rect_t * RECT)
     SYS_CONTEXT: global system context

     SEGMENT: segment to test

     RECT: rectangle in which segment is supposed to be

     Tests wether a segment is inside a rectangle, this is typically
     used to know if a segment is inside the right texture or if we're
     outside.

     *Return value:* 1 if OK, 0 if outside

 -- Function: void lw6gui_smoother_init (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_smoother_t * SMOOTHER, float VALUE, int DURATION)
     SYS_CONTEXT: global system context

     SMOOTHER: the structure to initialize

     VALUE: the value to use for now

     DURATION: the duration of a standard move, in ticks (msec)

     Initializes a smoother object, with a default value.  The important
     point is the duration which will condition all the behavior of the
     object.

     *Return value:* none.

 -- Function: void lw6gui_smoother_immediate_force (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_smoother_t * SMOOTHER, float VALUE)
     SYS_CONTEXT: global system context

     SMOOTHER: the structure to use

     VALUE: the target value

     Forces a smoother object to immediately point on a value.

     *Return value:* none.

 -- Function: void lw6gui_smoother_set_target (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_smoother_t * SMOOTHER, float VALUE,
          int64_t NOW)
     SYS_CONTEXT: global system context

     SMOOTHER: the structure to use

     VALUE: the target value

     NOW: the current timestamp

     Sets a new target, will automatically calculate current speed to
     smooth the next returned values.

     *Return value:* none.

 -- Function: float lw6gui_smoother_get_value (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_smoother_t * SMOOTHER, int64_t NOW)
     SYS_CONTEXT: global system context

     SMOOTHER: the structure to use

     NOW: the current timestamp

     Returns the current value of the smoother.

     *Return value:* a float.

 -- Function: void lw6gui_smoother_fix_overflow (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_smoother_t * SMOOTHER, int STEP)
     SYS_CONTEXT: global system context

     SMOOTHER: object to modify

     STEP: step size, typically twice the map size

     Companion function of 'lw6pil_coords_fix_x10', this one will fix a
     smoother target to avoid crazy scrolls when cursor is on a map
     edge.

     *Return value:* none.

 -- Function: int lw6gui_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libgui module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6gui_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'gui' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6gui_triangle_is_inside_rect (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_triangle_t * TRIANGLE, const
          lw6gui_rect_t * RECT)
     SYS_CONTEXT: global system context

     TRIANGLE: triangle to test

     RECT: rectangle in which triangle is supposed to be

     Tests wether a triangle is inside a rectangle, this is typically
     used to know if a triangle is inside the right texture or if we're
     outside.

     *Return value:* 1 if OK, 0 if outside

 -- Function: int lw6gui_video_mode_find_closest (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_video_mode_t * CLOSEST, const
          lw6gui_video_mode_t * WISHED, lw6sys_list_t * AVAILABLE)
     SYS_CONTEXT: global system context

     CLOSEST: the closest video_mode found

     WISHED: the wished video_mode

     AVAILABLE: a list of available video_modes (list of
     lw6gui_video_mode_t *)

     Finds the closest video_mode available, this is just a small
     utility to cope with different screen shapes and avoid requesting
     640x480 when it's just not available but there's a 640x400 instead.

     *Return value:* 1 if the wished video_mode exists in available list
     and was found, else 0 if the wished video_mode doesn't exist and an
     approximative match was picked.

 -- Function: int lw6gui_video_mode_is_same (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_video_mode_t * MODE_A, const
          lw6gui_video_mode_t * MODE_B)
     SYS_CONTEXT: global system context

     MODE_A: first mode to compare

     MODE_B: second mode to compare

     Compares two video modes, to know if they're the same.

     *Return value:* 1 if equal, 0 if not.

 -- Function: int lw6gui_video_mode_sync_ratio (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_video_mode_t * DST, const
          lw6gui_video_mode_t * SRC)
     SYS_CONTEXT: global system context

     DST: the target video mode

     SRC: the source video mode

     Applies the ratio of src to dst, for instance if src is 16/9, then
     dst will be made 16/9 too, trying to keep the same surface.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6gui_viewport_init (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_viewport_t * VIEWPORT, int SCREEN_W, int SCREEN_H,
          float DRAWABLE_X1, float DRAWABLE_Y1, float DRAWABLE_X2, float
          DRAWABLE_Y2, float CENTER_X, float CENTER_Y, int MAP_W, int
          MAP_H, int X_POLARITY, int Y_POLARITY, int X_WRAP, int Y_WRAP,
          int KEEP_RATIO, float GLOBAL_ZOOM, float SCROLL_LIMIT, int
          USE_OLD_CENTER)
     SYS_CONTEXT: global system context

     VIEWPORT: the viewport to initalize

     SCREEN_W: screen width

     SCREEN_H: screen height

     DRAWABLE_X1: viewport min x

     DRAWABLE_Y1: viewport min y

     DRAWABLE_X2: viewport max x

     DRAWABLE_Y2: viewport max y

     CENTER_X: center of display (in map coordinates)

     CENTER_Y: center of display (in map coordinates)

     MAP_W: map width (shape)

     MAP_H: map height (shape)

     X_POLARITY: x polarity

     Y_POLARITY: y polarity

     X_WRAP: wether to wrap horizontally

     Y_WRAP: wether to wrap vertically

     KEEP_RATIO: wether to adapt to viewport shape or keep original

     GLOBAL_ZOOM: global zoom is style_zoom * dynamic_zoom

     SCROLL_LIMIT: inside this zone, don't scroll

     USE_OLD_CENTER: wether to take previous center in account

     Initializes all the (jumbo?)  viewport structure which will contain
     valuable informations for a simple "flat" display.  Special
     renderers might not find usefull some fields and handle wrapping
     and zooming their own way, but this offers a basic skeleton.

     *Return value:* 1 if ok, 0 on failure

 -- Function: void lw6gui_viewport_map_to_screen (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_viewport_t * VIEWPORT, float * SCREEN_X,
          float * SCREEN_Y, float MAP_X, float MAP_Y, int CLIP)
     SYS_CONTEXT: global system context

     VIEWPORT: the viewport to use

     SCREEN_X: the x coord on the screen

     SCREEN_Y: the y coord on the screen

     MAP_X: the x coord in map coordinates

     MAP_Y: the y coord in map coordinates

     CLIP: wether to clip returned values

     Translates from map coords to screen coords.  Returned values might
     be outside screen boundaries if clip is 0.  If screen coords are
     outside drawable area anc clip is 1, then they will be clipped.

     *Return value:* NULL

 -- Function: void lw6gui_viewport_screen_to_map (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_viewport_t * VIEWPORT, float * MAP_X,
          float * MAP_Y, float SCREEN_X, float SCREEN_Y, int WRAP)
     SYS_CONTEXT: global system context

     VIEWPORT: the viewport to use

     MAP_X: the x coord in map coordinates

     MAP_Y: the y coord in map coordinates

     SCREEN_X: the x coord on the screen

     SCREEN_Y: the y coord on the screen

     WRAP: wether to use polarity informations to wrap coords.

     Translates from screen coords to map coords.  If wrap is set, it
     will interpret coords the way 'lw6map_coords_fix_xy' would, only it
     can still be formally outside map boundaries for it can return a
     value exactly equal to w,h while in interger mode it would be
     w-1,h-1.

     *Return value:* NULL

 -- Function: void lw6gui_viewport_calc_drag (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_viewport_t * VIEWPORT, float * MAP_DST_X,
          float * MAP_DST_Y, float MAP_SRC_X, float MAP_SRC_Y, int
          SCREEN_DX, int SCREEN_DY)
     SYS_CONTEXT: global system context

     VIEWPORT: viewport to work on

     MAP_DST_X: map det x coord (out param)

     MAP_DST_Y: map dst y coord (out param)

     MAP_SRC_X: map src x coord

     MAP_SRC_Y: map src y coord

     SCREEN_DX: drag x (on screen)

     SCREEN_DY: drag y (on screen)

     Used to calculate the new "center" when in drag mode.

     *Return value:* none.

 -- Function: void lw6gui_zone_init_x1y1x2y2 (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_zone_t * ZONE, float X1, float Y1, float
          X2, float Y2)
     SYS_CONTEXT: global system context

     ZONE: the structure to initialize

     X1: x for top left corner

     Y1: y for top left corner

     X2: x for bottom right corner

     Y2: y for bottom right corner

     Initializes a zone structure, will calculate w & h.

     *Return value:* none.

 -- Function: void lw6gui_zone_init_xywh (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_zone_t * ZONE, float X, float Y, float W,
          float H)
     SYS_CONTEXT: global system context

     ZONE: the structure to initialize

     X: x for top left corner

     Y: y for top left corner

     W: width

     H: height

     Initializes a zone structure, will calculate x2 & y2.

     *Return value:* none.

 -- Function: void lw6gui_zone_clip (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_zone_t * DST, lw6gui_zone_t * SRC, lw6gui_zone_t *
          CLIP)
     SYS_CONTEXT: global system context

     DST: the structure which will contain the result

     SRC: the source zone

     CLIP: the clipping zone (boundaries)

     Clips a zone (think of rectangle clips).

     *Return value:* none.

 -- Struct: lw6gui_button_s

     Used to store a complete button state, along with repeat
     informations, queues.  It might be overkill for basic cases, having
     different types of buttons (union?)  for different cases might be a
     good idea.

 -- Member of lw6gui_button_s: is_pressed
     *Type:* 'int'

     *Definition:* 'int lw6gui_button_s::is_pressed'

     Wether button is pressed, 1 means pressed, 0 unpressed.

 -- Member of lw6gui_button_s: press_queue
     *Type:* 'int'

     *Definition:* 'int lw6gui_button_s::press_queue'

     Each time the button is pressed, this increases, each times one
     "pops" a press from it, it's decreased.  This allows for button
     buffering, as events might take some time to go through the
     pipeline given the heavily multithreaded nature of the dsp/gfx
     couple.

 -- Member of lw6gui_button_s: simple_click_queue
     *Type:* 'int'

     *Definition:* 'int lw6gui_button_s::simple_click_queue'

     Simple-click counter, as opposed to double-click.  A "simple-click"
     is validated when one has pressed the button, and then waiting long
     enough to discard the possibility to double-click.  This is not
     really buffered, queue will ignore simple-clicks if one is already
     buffered.

 -- Member of lw6gui_button_s: double_click_queue
     *Type:* 'int'

     *Definition:* 'int lw6gui_button_s::double_click_queue'

     Double-click counter.  This is not really buffered, queue will
     ignore double-clicks if one is already buffered.

 -- Member of lw6gui_button_s: triple_click_queue
     *Type:* 'int'

     *Definition:* 'int lw6gui_button_s::triple_click_queue'

     Triple-click counter.  This is not really buffered, queue will
     ignore triple-clicks if one is already buffered.

 -- Member of lw6gui_button_s: last_press
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6gui_button_s::last_press'

     Timestamp of last key press.

 -- Member of lw6gui_button_s: last_repeat
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6gui_button_s::last_repeat'

     Timestamp of last key repeat.

 -- Member of lw6gui_button_s: double_click_t1
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6gui_button_s::double_click_t1'

     Used to handle multiple-clicks, this is the timestamp of the click
     "2 clicks ago".

 -- Member of lw6gui_button_s: double_click_t2
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6gui_button_s::double_click_t2'

     Used to handle multiple-clicks, this is the timestamp of the click
     just before the last click.

 -- Member of lw6gui_button_s: double_click_t3
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6gui_button_s::double_click_t3'

     Used to handle multiple-clicks, this is the timestamp of the last
     click.

 -- Struct: lw6gui_fullscreen_modes_s

     Contains information about available fullscreen modes.

 -- Member of lw6gui_fullscreen_modes_s: low
     *Type:* 'lw6gui_video_mode_t'

     *Definition:* 'lw6gui_video_mode_t lw6gui_fullscreen_modes_s::low'

     Low resolution mode.

 -- Member of lw6gui_fullscreen_modes_s: standard
     *Type:* 'lw6gui_video_mode_t'

     *Definition:* 'lw6gui_video_mode_t
     lw6gui_fullscreen_modes_s::standard'

     Standard resolution mode.

 -- Member of lw6gui_fullscreen_modes_s: high
     *Type:* 'lw6gui_video_mode_t'

     *Definition:* 'lw6gui_video_mode_t lw6gui_fullscreen_modes_s::high'

     High resolution mode.

 -- Struct: lw6gui_input_s

     Global input state, contains informations about the keyboard, mouse
     and joystick.  This is the macro object used to exchange data and
     transmit input information from the rendering thread which gathers
     it to the logical thread which computes the game state.

 -- Member of lw6gui_input_s: need_sync
     *Type:* 'int'

     *Definition:* 'int lw6gui_input_s::need_sync'

     Wether this input struct has changed and needs to be synchronized.

 -- Member of lw6gui_input_s: keyboard
     *Type:* 'lw6gui_keyboard_t'

     *Definition:* 'lw6gui_keyboard_t lw6gui_input_s::keyboard'

     Keyboard information.

 -- Member of lw6gui_input_s: mouse
     *Type:* 'lw6gui_mouse_t'

     *Definition:* 'lw6gui_mouse_t lw6gui_input_s::mouse'

     Mouse information.

 -- Member of lw6gui_input_s: joysticks
     *Type:* 'lw6gui_joystick_t'

     *Definition:* 'lw6gui_joystick_t
     lw6gui_input_s::joysticks[LW6GUI_NB_JOYSTICKS]'

     Joysticks information.

 -- Struct: lw6gui_joystick_s

     Joystick information, contains detailed joystick state.  This
     structure uses a pad-like interface, there's no knowledge of analog
     interfaces, it transforms everything to a binary "up or down" and
     "left or right".  This interface only knows about 6 buttons, this
     is done on purpose, the logic behind it is that more than 6 buttons
     makes the control way too complicated.  Actually, most common
     functions are and should be available through the 4 first (a,b,c,d)
     buttons.  The e and f are here for additionnal not-so-important
     features.

 -- Member of lw6gui_joystick_s: pad_up
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_joystick_s::pad_up'

     Joystick up button state.

 -- Member of lw6gui_joystick_s: pad_down
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_joystick_s::pad_down'

     Joystick down button state.

 -- Member of lw6gui_joystick_s: pad_left
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_joystick_s::pad_left'

     Joystick left button state.

 -- Member of lw6gui_joystick_s: pad_right
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_joystick_s::pad_right'

     Joystick right button state.

 -- Member of lw6gui_joystick_s: button_a
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_joystick_s::button_a'

     Joystick a button state.

 -- Member of lw6gui_joystick_s: button_b
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_joystick_s::button_b'

     Joystick b button state.

 -- Member of lw6gui_joystick_s: button_c
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_joystick_s::button_c'

     Joystick c button state.

 -- Member of lw6gui_joystick_s: button_d
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_joystick_s::button_d'

     Joystick d button state.

 -- Member of lw6gui_joystick_s: button_e
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_joystick_s::button_e'

     Joystick e button state.

 -- Member of lw6gui_joystick_s: button_f
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_joystick_s::button_f'

     Joystick f button state.

 -- Struct: lw6gui_keyboard_s

     Stores a complete keyboard state.

 -- Member of lw6gui_keyboard_s: auto_release_enabled
     *Type:* 'int'

     *Definition:* 'int lw6gui_keyboard_s::auto_release_enabled'

     Wether auto_release mode is set.

 -- Member of lw6gui_keyboard_s: arrow_up
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_keyboard_s::arrow_up'

     State of keyboard up arrow.  This can be the combination of several
     keys, for instance the numeric pad up arrow, and the corresponding
     arrow pad key.

 -- Member of lw6gui_keyboard_s: arrow_down
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_keyboard_s::arrow_down'

     State of keyboard down arrow.  This can be the combination of
     several keys, for instance the numeric pad down arrow, and the
     corresponding arrow pad key.

 -- Member of lw6gui_keyboard_s: arrow_left
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_keyboard_s::arrow_left'

     State of keyboard left arrow.  This can be the combination of
     several keys, for instance the numeric pad left arrow, and the
     corresponding arrow pad key.

 -- Member of lw6gui_keyboard_s: arrow_right
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_keyboard_s::arrow_right'

     State of keyboard right arrow.  This can be the combination of
     several keys, for instance the numeric pad right arrow, and the
     corresponding arrow pad key.

 -- Member of lw6gui_keyboard_s: key_enter
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_keyboard_s::key_enter'

     State of keyboard ENTER key.  This can be the combination of
     several keys, for instance both the numeric pad ENTER and the
     standard, default one.

 -- Member of lw6gui_keyboard_s: key_esc
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_keyboard_s::key_esc'

     State of keyboard ESC key.  This can be the combination of several
     keys, for instance both the standard ESC key and another key.

 -- Member of lw6gui_keyboard_s: key_ctrl
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_keyboard_s::key_ctrl'

     State of keyboard ESC key.  This can be the combination of several
     keys, for instance both left and right CTRL keys.

 -- Member of lw6gui_keyboard_s: key_alt
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_keyboard_s::key_alt'

     State of keyboard ESC key.  This can be the combination of several
     keys, for instance both left and right ALT keys.

 -- Member of lw6gui_keyboard_s: key_pgup
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_keyboard_s::key_pgup'

     State of keyboard PAGE UP key.  This can be the combination of
     several keys.

 -- Member of lw6gui_keyboard_s: key_pgdown
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_keyboard_s::key_pgdown'

     State of keyboard PAGE UP key.  This can be the combination of
     several keys.

 -- Member of lw6gui_keyboard_s: queue
     *Type:* 'lw6sys_list_t *'

     *Definition:* 'lw6sys_list_t* lw6gui_keyboard_s::queue'

     List of events, contains keypress objects.

 -- Member of lw6gui_keyboard_s: keys_state
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t
     lw6gui_keyboard_s::keys_state[LW6GUI_NB_KEYS]'

     Array of button states, indexed by keycodes.

 -- Struct: lw6gui_keypress_s

     Keypress information, contains more than just a keycode but also
     meta/readable informations about it.

 -- Member of lw6gui_keypress_s: keysym
     *Type:* 'int'

     *Definition:* 'int lw6gui_keypress_s::keysym'

     The keysym, note that this is implementation specific.  In
     practice, SDL uniformizes this, but there's no garantee all
     graphics engine are SDL based, so don't rely on this too much
     outside the graphics backend.

 -- Member of lw6gui_keypress_s: unicode
     *Type:* 'int'

     *Definition:* 'int lw6gui_keypress_s::unicode'

     Unicode code for this letter/key.

 -- Member of lw6gui_keypress_s: label
     *Type:* 'char *'

     *Definition:* 'char* lw6gui_keypress_s::label'

     Readable label for the key, typically usable in a "choose keyboard
     settings" interface.

 -- Struct: lw6gui_look_s

     The look structure contains everything the renderer needs to skin
     the display.  This is where one specifies the color set, dynamic
     zoom effect, and possibly other things.

 -- Member of lw6gui_look_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6gui_look_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6gui_look_s: dynamic_zoom
     *Type:* 'float'

     *Definition:* 'float lw6gui_look_s::dynamic_zoom'

     Dynamic zoom, this is multiplicated by the map zoom, and gives the
     global zoom, the one finally used.

 -- Member of lw6gui_look_s: gfx_quality
     *Type:* 'int'

     *Definition:* 'int lw6gui_look_s::gfx_quality'

     Overall graphics quality, the higher the better, will trigger
     various parameters, depending on the renderer.

 -- Member of lw6gui_look_s: style
     *Type:* 'lw6map_style_t'

     *Definition:* 'lw6map_style_t lw6gui_look_s::style'

     A style structure which will override the one from the map,
     depending on the local options (config file, environnement,
     command-line options).

 -- Struct: lw6gui_menuitem_s

     Menu item object.  Basically, a menu is an array of these items,
     it's up to the gfx backend to render this as accurately as
     possible.  The most important field is probably the label.

 -- Member of lw6gui_menuitem_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6gui_menuitem_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6gui_menuitem_s: label
     *Type:* 'char *'

     *Definition:* 'char* lw6gui_menuitem_s::label'

     What is displayed in the menu item.

 -- Member of lw6gui_menuitem_s: tooltip
     *Type:* 'char *'

     *Definition:* 'char* lw6gui_menuitem_s::tooltip'

     An additionnal tooltip explaining what the item is about.

 -- Member of lw6gui_menuitem_s: value
     *Type:* 'int'

     *Definition:* 'int lw6gui_menuitem_s::value'

     The value for this item, can typically be used for booleans and
     integer values, in addition to the information conveyed by the
     label.  One special case is colored items, in that case the value
     will be used as a color index.

 -- Member of lw6gui_menuitem_s: enabled
     *Type:* 'int'

     *Definition:* 'int lw6gui_menuitem_s::enabled'

     Wether the item is valid and can be used.

 -- Member of lw6gui_menuitem_s: selected
     *Type:* 'int'

     *Definition:* 'int lw6gui_menuitem_s::selected'

     Wether the item is the current selection.

 -- Member of lw6gui_menuitem_s: colored
     *Type:* 'int'

     *Definition:* 'int lw6gui_menuitem_s::colored'

     Wether to colorize the item, and in that case, use the value field
     to know which color to use.

 -- Member of lw6gui_menuitem_s: last_change
     *Type:* 'int'

     *Definition:* 'int lw6gui_menuitem_s::last_change'

     Timestamp of last time the menu item was updated and changed.

 -- Member of lw6gui_menuitem_s: last_select
     *Type:* 'int'

     *Definition:* 'int lw6gui_menuitem_s::last_select'

     Timestamp of last time the menu was selected.

 -- Member of lw6gui_menuitem_s: last_unselect
     *Type:* 'int'

     *Definition:* 'int lw6gui_menuitem_s::last_unselect'

     Timestamp of last time the menu was unselected.

 -- Struct: lw6gui_menu_s

     Menu item object.  Basically, a menu is an array of menu items,
     it's up to the gfx backend to render this as accurately as
     possible.  The most important field is probably the items labels.
     The menu object also stores state information such as what was the
     first item displayed lately.

 -- Member of lw6gui_menu_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6gui_menu_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6gui_menu_s: title
     *Type:* 'char *'

     *Definition:* 'char* lw6gui_menu_s::title'

     Title of the menu, used for breadcrumbs.

 -- Member of lw6gui_menu_s: help
     *Type:* 'char *'

     *Definition:* 'char* lw6gui_menu_s::help'

     Additionnal help text, explaining what the menu is about.

 -- Member of lw6gui_menu_s: popup
     *Type:* 'char *'

     *Definition:* 'char* lw6gui_menu_s::popup'

     Popup text, will be displayed when the menu is first displayed, and
     then disappear.

 -- Member of lw6gui_menu_s: nb_items
     *Type:* 'int'

     *Definition:* 'int lw6gui_menu_s::nb_items'

     Number of items.

 -- Member of lw6gui_menu_s: esc_item
     *Type:* 'lw6gui_menuitem_t *'

     *Definition:* 'lw6gui_menuitem_t* lw6gui_menu_s::esc_item'

     Special item describing the ESC button.

 -- Member of lw6gui_menu_s: items
     *Type:* 'lw6gui_menuitem_t **'

     *Definition:* 'lw6gui_menuitem_t** lw6gui_menu_s::items'

     Array of items, containing all the menu items.

 -- Member of lw6gui_menu_s: selected_item
     *Type:* 'int'

     *Definition:* 'int lw6gui_menu_s::selected_item'

     The current selection.

 -- Member of lw6gui_menu_s: first_item_displayed
     *Type:* 'int'

     *Definition:* 'int lw6gui_menu_s::first_item_displayed'

     The first item displayed, this is mandatory if we want the menus to
     be displayable in different states, for instance with first item
     being 2 and items displayed from 2 to 10 or with first item being 5
     and items displayed from 2 to 10.  In the first case the 1st item
     is selected, in the second case it's the 4th.

 -- Member of lw6gui_menu_s: nb_items_displayed
     *Type:* 'int'

     *Definition:* 'int lw6gui_menu_s::nb_items_displayed'

     Number of items displayed.

 -- Member of lw6gui_menu_s: order_of_selected_on_display
     *Type:* 'int'

     *Definition:* 'int lw6gui_menu_s::order_of_selected_on_display'

     Index, display-based (that is, 0 here means first displayed and not
     necessarly first in the items array), of the selected item.

 -- Member of lw6gui_menu_s: allow_scroll
     *Type:* 'int'

     *Definition:* 'int lw6gui_menu_s::allow_scroll'

     Wether scrolling is allowed.

 -- Member of lw6gui_menu_s: breadcrumbs
     *Type:* 'lw6sys_list_t *'

     *Definition:* 'lw6sys_list_t* lw6gui_menu_s::breadcrumbs'

     List of strings containing the breadcrumbs, that is to say all the
     menu titles that one must use to get here.

 -- Struct: lw6gui_mouse_pointer_s

     Use to store mouse pointer information.

 -- Member of lw6gui_mouse_pointer_s: pos_x
     *Type:* 'int'

     *Definition:* 'int lw6gui_mouse_pointer_s::pos_x'

     Mouse X position (pixels).

 -- Member of lw6gui_mouse_pointer_s: pos_y
     *Type:* 'int'

     *Definition:* 'int lw6gui_mouse_pointer_s::pos_y'

     Mouse Y position (pixels).

 -- Member of lw6gui_mouse_pointer_s: speed_x
     *Type:* 'int'

     *Definition:* 'int lw6gui_mouse_pointer_s::speed_x'

     Mouse X speed.  The unit is pixels per second.  This is based on
     the last move, for instance if between two moves 100 msec have
     elapsed, and mouse moved 13 pixels, then speed is 130.

 -- Member of lw6gui_mouse_pointer_s: speed_y
     *Type:* 'int'

     *Definition:* 'int lw6gui_mouse_pointer_s::speed_y'

     Mouse Y speed.  The unit is pixels per second.  This is based on
     the last move, for instance if between two moves 100 msec have
     elapsed, and mouse moved 13 pixels, then speed is 130.

 -- Struct: lw6gui_mouse_s

     Mouse information, contains detailed mouse state, including mouse
     position and button states but also keeps track of mouse speed as
     well as its corresponding map coordinates.  That is, given the
     current screen position, what does it mean on the logical
     map/battlefield.

 -- Member of lw6gui_mouse_s: moved
     *Type:* 'int'

     *Definition:* 'int lw6gui_mouse_s::moved'

     Wether mouse was moved lately.  1 means yes, 0 no.

 -- Member of lw6gui_mouse_s: last_moved
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6gui_mouse_s::last_moved'

     Timestamp of last move.

 -- Member of lw6gui_mouse_s: screen_pointer
     *Type:* 'lw6gui_mouse_pointer_t'

     *Definition:* 'lw6gui_mouse_pointer_t
     lw6gui_mouse_s::screen_pointer'

     Information about the mouse pointer, using screen coordinates, the
     unit being pixels.

 -- Member of lw6gui_mouse_s: map_pointer
     *Type:* 'lw6gui_mouse_pointer_t'

     *Definition:* 'lw6gui_mouse_pointer_t lw6gui_mouse_s::map_pointer'

     Information about the mouse pointer, using map coordinates, the
     unit being the map slot.  This is possibly very different from
     screen coordinates, they can be inverted, have a different scale,
     and globally it's just something else, even if it refers to the
     same physical move.

 -- Member of lw6gui_mouse_s: screen_drag_start
     *Type:* 'lw6gui_mouse_pointer_t'

     *Definition:* 'lw6gui_mouse_pointer_t
     lw6gui_mouse_s::screen_drag_start'

     Information about the mouse pointer when drag mode was entered.
     The unit is screen pixels.

 -- Member of lw6gui_mouse_s: drag_mode
     *Type:* 'lw6gui_drag_mode_t'

     *Definition:* 'lw6gui_drag_mode_t lw6gui_mouse_s::drag_mode'

     The current drag state.

 -- Member of lw6gui_mouse_s: menu_position
     *Type:* 'int'

     *Definition:* 'int lw6gui_mouse_s::menu_position'

     The index of the menu item the mouse is on.  This is the only was
     to know when to select an item, one should not use mouse coords
     outside the gfx renderer code for this purpose, it's the renderer
     which has knowledge about where menu items are.

 -- Member of lw6gui_mouse_s: menu_scroll
     *Type:* 'int'

     *Definition:* 'int lw6gui_mouse_s::menu_scroll'

     Set to -1 if one needs to scroll up (decrease menu index) to +1 if
     one needs to scroll down (increase menu index) and 0 if one needs
     to do nothing as far as scrolling is concerned.

 -- Member of lw6gui_mouse_s: menu_esc
     *Type:* 'int'

     *Definition:* 'int lw6gui_mouse_s::menu_esc'

     Wether mouse pointer is over the ESC button.

 -- Member of lw6gui_mouse_s: button_left
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_mouse_s::button_left'

     Mouse left button state.

 -- Member of lw6gui_mouse_s: button_right
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_mouse_s::button_right'

     Mouse right button state.

 -- Member of lw6gui_mouse_s: button_middle
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_mouse_s::button_middle'

     Mouse middle button state.

 -- Member of lw6gui_mouse_s: wheel_up
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_mouse_s::wheel_up'

     Mouse wheel up state.

 -- Member of lw6gui_mouse_s: wheel_down
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_mouse_s::wheel_down'

     Mouse wheel down state.

 -- Struct: lw6gui_move_pad_s

     Standard interface for joypad-like interfaces, can also be used to
     map keyboard arrows.

 -- Member of lw6gui_move_pad_s: up
     *Type:* 'int'

     *Definition:* 'int lw6gui_move_pad_s::up'

     Up button (boolean).

 -- Member of lw6gui_move_pad_s: down
     *Type:* 'int'

     *Definition:* 'int lw6gui_move_pad_s::down'

     Down button (boolean).

 -- Member of lw6gui_move_pad_s: left
     *Type:* 'int'

     *Definition:* 'int lw6gui_move_pad_s::left'

     Left button (boolean).

 -- Member of lw6gui_move_pad_s: right
     *Type:* 'int'

     *Definition:* 'int lw6gui_move_pad_s::right'

     Right button (boolean).

 -- Struct: lw6gui_point_s

     Basic point type, 3 floating point coords.

 -- Member of lw6gui_point_s: x
     *Type:* 'float'

     *Definition:* 'float lw6gui_point_s::x'

     X position.

 -- Member of lw6gui_point_s: y
     *Type:* 'float'

     *Definition:* 'float lw6gui_point_s::y'

     Y position.

 -- Member of lw6gui_point_s: z
     *Type:* 'float'

     *Definition:* 'float lw6gui_point_s::z'

     Z position.

 -- Struct: lw6gui_quad_s

     Basic quad type, composed of 4 points (floating point values).

 -- Member of lw6gui_quad_s: p1
     *Type:* 'lw6gui_point_t'

     *Definition:* 'lw6gui_point_t lw6gui_quad_s::p1'

     1st point.

 -- Member of lw6gui_quad_s: p2
     *Type:* 'lw6gui_point_t'

     *Definition:* 'lw6gui_point_t lw6gui_quad_s::p2'

     2nd point.

 -- Member of lw6gui_quad_s: p3
     *Type:* 'lw6gui_point_t'

     *Definition:* 'lw6gui_point_t lw6gui_quad_s::p3'

     3rd point.

 -- Member of lw6gui_quad_s: p4
     *Type:* 'lw6gui_point_t'

     *Definition:* 'lw6gui_point_t lw6gui_quad_s::p4'

     4th point.

 -- Struct: lw6gui_rect_array_s

     Array of rectangles.  This is typically used to make tiles that
     overlap.  It's mostly used to display fighters/maps using multiple
     textures when the whole stuff does not fit in one single OpenGL
     texture and needs to be splitted.  Technically, when one needs to
     split textures, performance is poor, but still better than relying
     on software renderer only.

 -- Member of lw6gui_rect_array_s: source
     *Type:* 'lw6sys_whd_t'

     *Definition:* 'lw6sys_whd_t lw6gui_rect_array_s::source'

     Size of original source data.

 -- Member of lw6gui_rect_array_s: limits
     *Type:* 'lw6gui_rect_t'

     *Definition:* 'lw6gui_rect_t lw6gui_rect_array_s::limits'

     Boundary limits of the rect array, this is typically bigger that
     source size, it starts at negative values and finishes outside the
     source.  It's interesting to cover that big an area to enable both
     the water effect and proper wrapping/clamping.

 -- Member of lw6gui_rect_array_s: tile_size
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_array_s::tile_size'

     Width and height of the tiles, this is typically a power of two, as
     it's designed to match an OpenGL low-level texture object.

 -- Member of lw6gui_rect_array_s: border_size
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_array_s::border_size'

     The border size one needs to cut from the tile_size (on both sides,
     up and down or left and right) to get the real usable size of the
     tile.

 -- Member of lw6gui_rect_array_s: tile_spacing
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_array_s::tile_spacing'

     The tile spacing, difference of X or Y between two tiles, this is
     typically smaller that tile_size.

 -- Member of lw6gui_rect_array_s: nb_tiles_w
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_array_s::nb_tiles_w'

     Number of tiles on the X axis (width).

 -- Member of lw6gui_rect_array_s: nb_tiles_h
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_array_s::nb_tiles_h'

     Number of tiles on the Y axis (height).

 -- Member of lw6gui_rect_array_s: nb_tiles
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_array_s::nb_tiles'

     Overall number of tiles.

 -- Struct: lw6gui_rect_s

     A basic rectangle data.  The idea is to store both corner positions
     and width and height to cache the values and avoid always
     recalculating them.  Values are integer based, for a floating point
     equivalent, see the zone struct.

 -- Member of lw6gui_rect_s: x1
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_s::x1'

     Top-left corner X position.

 -- Member of lw6gui_rect_s: y1
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_s::y1'

     Top-left corner Y position.

 -- Member of lw6gui_rect_s: x2
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_s::x2'

     Bottom-right corner X position.

 -- Member of lw6gui_rect_s: y2
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_s::y2'

     Bottom-right corner Y position.

 -- Member of lw6gui_rect_s: w
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_s::w'

     Width.

 -- Member of lw6gui_rect_s: h
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_s::h'

     Height.

 -- Struct: lw6gui_repeat_settings_s

     Parameters used to handle repeat.  This is used both by keys and
     buttons (joystick buttons and mouse buttons).

 -- Member of lw6gui_repeat_settings_s: delay
     *Type:* 'int'

     *Definition:* 'int lw6gui_repeat_settings_s::delay'

     Delay, in milliseconds, after which a given key/button enters
     repeat mode.

 -- Member of lw6gui_repeat_settings_s: interval
     *Type:* 'int'

     *Definition:* 'int lw6gui_repeat_settings_s::interval'

     Interval, in milliseconds, between two key/button press events in
     repeat mode.

 -- Member of lw6gui_repeat_settings_s: double_click_delay
     *Type:* 'int'

     *Definition:* 'int lw6gui_repeat_settings_s::double_click_delay'

     If pressed twice within this delay (in milliseconds) then a
     double-click event is generated.

 -- Member of lw6gui_repeat_settings_s: auto_release_delay
     *Type:* 'int'

     *Definition:* 'int lw6gui_repeat_settings_s::auto_release_delay'

     After this delay (milliseconds) any key will be considered be
     unpressed, that is, it will be released automatically.  This is
     usefull when the input library (depends on the gfx backend) does
     not send proper "key up" events.  The workarround is to
     automatically consider the key is released after some time.
     Usually, this would typically be set just below the repeat delay.

 -- Struct: lw6gui_segment_s

     Basic segment type, composed of 2 points (floating point values).

 -- Member of lw6gui_segment_s: p1
     *Type:* 'lw6gui_point_t'

     *Definition:* 'lw6gui_point_t lw6gui_segment_s::p1'

     1st point.

 -- Member of lw6gui_segment_s: p2
     *Type:* 'lw6gui_point_t'

     *Definition:* 'lw6gui_point_t lw6gui_segment_s::p2'

     2nd point.

 -- Struct: lw6gui_smoother_s

     Statefull object used to make transitions between 2 floats.
     Basically, one needs to choose a target, which is y2, and give a
     start, which is defined by s1 and y1 (speed and y value).  Then
     with t1 (start timestamp) and duration the object has functions
     which enables interpolation between those two values, knowing at
     the end the value will be y2 and the speed 0.  To some extent, this
     is a primitive bezier-like tool.

 -- Member of lw6gui_smoother_s: s1
     *Type:* 'float'

     *Definition:* 'float lw6gui_smoother_s::s1'

     Speed at startup.

 -- Member of lw6gui_smoother_s: y1
     *Type:* 'float'

     *Definition:* 'float lw6gui_smoother_s::y1'

     Y value at startup.

 -- Member of lw6gui_smoother_s: y2
     *Type:* 'float'

     *Definition:* 'float lw6gui_smoother_s::y2'

     Y target value.

 -- Member of lw6gui_smoother_s: t1
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6gui_smoother_s::t1'

     Timestamp at startup.

 -- Member of lw6gui_smoother_s: duration
     *Type:* 'int'

     *Definition:* 'int lw6gui_smoother_s::duration'

     Duration (in milliseconds) of the transition.

 -- Struct: lw6gui_triangle_s

     Basic triangle type, composed of 3 points (floating point values).

 -- Member of lw6gui_triangle_s: p1
     *Type:* 'lw6gui_point_t'

     *Definition:* 'lw6gui_point_t lw6gui_triangle_s::p1'

     1st point.

 -- Member of lw6gui_triangle_s: p2
     *Type:* 'lw6gui_point_t'

     *Definition:* 'lw6gui_point_t lw6gui_triangle_s::p2'

     2nd point.

 -- Member of lw6gui_triangle_s: p3
     *Type:* 'lw6gui_point_t'

     *Definition:* 'lw6gui_point_t lw6gui_triangle_s::p3'

     3rd point.

 -- Struct: lw6gui_video_mode_s

     Contains the parameters for a video mode, regardless of driver
     used.

 -- Member of lw6gui_video_mode_s: width
     *Type:* 'int'

     *Definition:* 'int lw6gui_video_mode_s::width'

     Width, in pixels.

 -- Member of lw6gui_video_mode_s: height
     *Type:* 'int'

     *Definition:* 'int lw6gui_video_mode_s::height'

     Height, in pixels.

 -- Member of lw6gui_video_mode_s: fullscreen
     *Type:* 'int'

     *Definition:* 'int lw6gui_video_mode_s::fullscreen'

     1 for fullscreen mode, 0 for windowed mode.

 -- Struct: lw6gui_viewport_s

     Macro object used to store viewport information.  Viewport here
     means "what part of the map should we display, on which part of the
     screen, and with which parameters".

 -- Member of lw6gui_viewport_s: map_shape
     *Type:* 'lw6sys_whd_t'

     *Definition:* 'lw6sys_whd_t lw6gui_viewport_s::map_shape'

     Shape of the map to display, unit is map slot.

 -- Member of lw6gui_viewport_s: screen_shape
     *Type:* 'lw6sys_whd_t'

     *Definition:* 'lw6sys_whd_t lw6gui_viewport_s::screen_shape'

     Shape of the screen, unit is pixels.

 -- Member of lw6gui_viewport_s: center_x
     *Type:* 'float'

     *Definition:* 'float lw6gui_viewport_s::center_x'

     X coord of the point we want to display at the center of the
     screen.  This is typically our main cursor if we're using the
     keyboard to move it.  Unit is map slot.

 -- Member of lw6gui_viewport_s: center_y
     *Type:* 'float'

     *Definition:* 'float lw6gui_viewport_s::center_y'

     Y coord of the point we want to display at the center of the
     screen.  This is typically our main cursor if we're using the
     keyboard to move it.  Unit is map slot.

 -- Member of lw6gui_viewport_s: old_center_x
     *Type:* 'float'

     *Definition:* 'float lw6gui_viewport_s::old_center_x'

     Previous X coord of the point we wanted to display at the center of
     the screen.  This is typically our main cursor if we're using the
     keyboard to move it.  Unit is map slot.

 -- Member of lw6gui_viewport_s: old_center_y
     *Type:* 'float'

     *Definition:* 'float lw6gui_viewport_s::old_center_y'

     Previous Y coord of the point we wanted to display at the center of
     the screen.  This is typically our main cursor if we're using the
     keyboard to move it.  Unit is map slot.

 -- Member of lw6gui_viewport_s: speed_x
     *Type:* 'float'

     *Definition:* 'float lw6gui_viewport_s::speed_x'

     Speed at which the viewport is moving on the X axis, unit is map
     slot per second.

 -- Member of lw6gui_viewport_s: speed_y
     *Type:* 'float'

     *Definition:* 'float lw6gui_viewport_s::speed_y'

     Speed at which the viewport is moving on the Y axis, unit is map
     slot per second.

 -- Member of lw6gui_viewport_s: x_polarity
     *Type:* 'int'

     *Definition:* 'int lw6gui_viewport_s::x_polarity'

     X-polarity parameter (1=on, 0=off, -1=invert).

 -- Member of lw6gui_viewport_s: y_polarity
     *Type:* 'int'

     *Definition:* 'int lw6gui_viewport_s::y_polarity'

     Y-polarity parameter (1=on, 0=off, -1=invert).

 -- Member of lw6gui_viewport_s: x_wrap
     *Type:* 'int'

     *Definition:* 'int lw6gui_viewport_s::x_wrap'

     Wether to wrap map on the X axis.

 -- Member of lw6gui_viewport_s: y_wrap
     *Type:* 'int'

     *Definition:* 'int lw6gui_viewport_s::y_wrap'

     Wether to wrap map on the Y axis.

 -- Member of lw6gui_viewport_s: drawable
     *Type:* 'lw6gui_zone_t'

     *Definition:* 'lw6gui_zone_t lw6gui_viewport_s::drawable'

     Drawable zone, this is the physical on-screen viewport.  Unit is
     pixels.

 -- Member of lw6gui_viewport_s: map_main
     *Type:* 'lw6gui_zone_t'

     *Definition:* 'lw6gui_zone_t lw6gui_viewport_s::map_main'

     Zone corresponding to the map, if it was to be drawn as a whole,
     regardless of drawable size, wrapping and polarity.

 -- Member of lw6gui_viewport_s: map_main_clipped
     *Type:* 'lw6gui_zone_t'

     *Definition:* 'lw6gui_zone_t lw6gui_viewport_s::map_main_clipped'

     Zone corresponding to the map, only the main map, ignoring wrapping
     and polarity, but clipped with drawable zone.

 -- Member of lw6gui_viewport_s: map_visible
     *Type:* 'lw6gui_zone_t'

     *Definition:* 'lw6gui_zone_t lw6gui_viewport_s::map_visible'

     Actual visible zone of the map, including wrapping, polarity, and
     drawable clip aware.

 -- Struct: lw6gui_zone_s

     A basic rectangle data.  The idea is to store both corner positions
     and width and height to cache the values and avoid always
     recalculating them.  Values are float based, for an integer point
     equivalent, see the rect struct.

 -- Member of lw6gui_zone_s: x1
     *Type:* 'float'

     *Definition:* 'float lw6gui_zone_s::x1'

     Top-left corner X position.

 -- Member of lw6gui_zone_s: y1
     *Type:* 'float'

     *Definition:* 'float lw6gui_zone_s::y1'

     Top-left corner Y position.

 -- Member of lw6gui_zone_s: x2
     *Type:* 'float'

     *Definition:* 'float lw6gui_zone_s::x2'

     Bottom-right corner X position.

 -- Member of lw6gui_zone_s: y2
     *Type:* 'float'

     *Definition:* 'float lw6gui_zone_s::y2'

     Bottom-right corner Y position.

 -- Member of lw6gui_zone_s: w
     *Type:* 'float'

     *Definition:* 'float lw6gui_zone_s::w'

     Width.

 -- Member of lw6gui_zone_s: h
     *Type:* 'float'

     *Definition:* 'float lw6gui_zone_s::h'

     Height.


File: liquidwar6.info,  Node: libhlp,  Next: libimg,  Prev: libgui,  Up: C API

5.27 libhlp
===========

5.27.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/hlp/index.html>.

5.27.2 API
----------

 -- Function: int lw6hlp_is_documented (lw6sys_context_t * SYS_CONTEXT,
          const char * KEYWORD)
     SYS_CONTEXT: global system context

     KEYWORD: the keyword we want to check out

     Checks wether a given keyword is documented or not.

     *Return value:* 1 if documented, 0 if not.

 -- Function: const char * lw6hlp_about (lw6sys_context_t * SYS_CONTEXT,
          lw6hlp_type_t * TYPE, const char ** DEFAULT_VALUE, int *
          MIN_VALUE, int * MAX_VALUE, const char * KEYWORD)
     SYS_CONTEXT: global system context

     TYPE: the type of the data associated to the keyword, will be
     written

     DEFAULT_VALUE: the default value for the keyword, will be written

     MIN_VALUE: the min value for the keyword, will be written

     MAX_VALUE: the max value for the keyword, will be written

     KEYWORD: the keyword we want help about

     Returns the documentation string associated to a keyword.  The
     keyword might be a command-line option, a Guile function, an XML
     file entry.  Raises a warning if the keyword is undocumented, but
     never returns NULL, you can use the returned value without checking
     it.  String is localized if a translation is available.  It's safe
     to call this function with type or other parameters being NULL.

     *Return value:* a help string, never NULL, must not be freed.
     Additionnally, type will be updated.

 -- Function: lw6hlp_type_t lw6hlp_get_type (lw6sys_context_t *
          SYS_CONTEXT, const char * KEYWORD)
     SYS_CONTEXT: global system context

     KEYWORD: the keyword we want the type of

     Returns the type of a keyword.  Calls lw6hlp_about internally.

     *Return value:* the type, might be LW6HLP_TYPE_VOID.

 -- Function: const char * lw6hlp_get_default_value (lw6sys_context_t *
          SYS_CONTEXT, const char * KEYWORD)
     SYS_CONTEXT: global system context

     KEYWORD: the keyword we want the default for

     Returns the default value for a keyword.  Note that it can be NULL!
     The returned value is always a string, it's suitable to store in
     the config file, it's the value a user would pass on a command
     line, the one he wants documented.

     *Return value:* a pointer, which can be NULL, must not be freed.

 -- Function: int lw6hlp_get_min_value (lw6sys_context_t * SYS_CONTEXT,
          const char * KEYWORD)
     SYS_CONTEXT: global system context

     KEYWORD: the keyword we want the min for

     Returns the min value for a keyword.  Wether this is relevant for a
     given keyword does not affect the fact that you can call this
     function.  A min and max of zero means min and max make no sense.

     *Return value:* the value (integer)

 -- Function: int lw6hlp_get_max_value (lw6sys_context_t * SYS_CONTEXT,
          const char * KEYWORD)
     SYS_CONTEXT: global system context

     KEYWORD: the keyword we want the max for

     Returns the max value for a keyword.  Wether this is relevant for a
     given keyword does not affect the fact that you can call this
     function.  A min and max of zero means min and max make no sense.

     *Return value:* the value (integer)

 -- Function: char * lw6hlp_get_credits (lw6sys_context_t * SYS_CONTEXT,
          int ID)
     SYS_CONTEXT: global system context

     ID: the id of the credits line to return

     Returns a "credit line", that is a short sentence, about 30 to 50
     chars, saying who developped the game, created graphics, giving
     important URLs, and so on.  One can pass an arbitraty high 'id', no
     risk, it will just loop on previous lines.

     *Return value:* the string, must be freed.

 -- Function: int lw6hlp_match (lw6sys_context_t * SYS_CONTEXT, const
          char * KEYWORD1, const char * KEYWORD2)
     SYS_CONTEXT: global system context

     KEYWORD1: the 1st keyword

     KEYWORD2: the 2nd keyword

     Checks wether a keyword matches another.  Not only a string
     comparison, will also try and guess if the error is only about dash
     "-" replaced by underscode "_", for instance.

     *Return value:* 1 if matches, 0 if different.

 -- Function: lw6sys_list_t * lw6hlp_list_quick (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning quick options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_doc (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning self-documentation system.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_show (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the show options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_path (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the path options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_players (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the players options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_input (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the input options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_graphics (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the graphics options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_sound (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the sound options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_network (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the network options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_map (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the map options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_map_rules (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the rules options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_map_hints (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the hints options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_map_style (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the style options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_map_teams (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the teams options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_funcs (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of C-function exported to Guile.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_hooks (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of hooks.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_advanced (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning advanced options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_aliases (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of command-line aliases.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_team_colors (lw6sys_context_t
          * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of team_colors.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_weapons (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of weapons.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of all available keywords.

     *Return value:* list of static strings (can't modify them)

 -- Function: int lw6hlp_process_non_run_options (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV, int * RUN_GAME)
     SYS_CONTEXT: global system context

     ARGC: the number of command-line args, as passed to main

     ARGV: an array of strings containing command-line args, as passed
     to main

     RUN_GAME: a pointer to a boolean which will contain true (1) if the
     game must be launched, or false (0) if the option is such that game
     must be skipped.  Example: -copyright, -help, ...

     Will interpret the command-line arguments, and trap those who are
     related to docs, this is usefull when building the game, we want to
     have an extra binary to do this without being linked to SDL, for
     instance.

     *Return value:* non-zero if success, 0 if error.  The error can be,
     for instance, the test suite returning "no, tests were not OK".

 -- Function: void lw6hlp_print_keyword (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_list_t ** LIST, FILE * F)
     SYS_CONTEXT: global system context

     LIST: a pointer to a list of keywords

     F: the file to print the content to

     Prints all the keywords from the list.  One keyword per line.

     *Return value:* none.

 -- Function: void lw6hlp_print_content (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_list_t ** LIST, FILE * F)
     SYS_CONTEXT: global system context

     LIST: a pointer to a list of keywords

     F: the file to print the content to

     Prints all the keywords from the list, with the associated keyword
     help, to the given file.  Output is formatted to fit on the
     standard terminal/console.

     *Return value:* none.

 -- Function: void lw6hlp_print_about (lw6sys_context_t * SYS_CONTEXT,
          const char * KEYWORD, FILE * F)
     SYS_CONTEXT: global system context

     KEYWORD: the keyword to print help about

     F: the file to print the content to

     Displays the help about a keyword, to a file, directly.  It's
     formatted for the purpose of the -about=<value> option.

     *Return value:* none

 -- Function: void lw6hlp_print_help (lw6sys_context_t * SYS_CONTEXT,
          FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays a short help message.

     *Return value:* none

 -- Function: void lw6hlp_print_version (lw6sys_context_t * SYS_CONTEXT,
          FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the version of the game.

     *Return value:* none

 -- Function: void lw6hlp_print_short_copyright (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the copyright of the game (short version).

     *Return value:* none

 -- Function: void lw6hlp_print_long_copyright (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the copyright of the game (long version).

     *Return value:* none

 -- Function: void lw6hlp_print_bench (lw6sys_context_t * SYS_CONTEXT,
          float BENCH_RESULT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the program bench value.

     *Return value:* none

 -- Function: void lw6hlp_print_pedigree (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the program pedigree, think of this as version on
     steroids.

     *Return value:* none

 -- Function: void lw6hlp_print_host (lw6sys_context_t * SYS_CONTEXT,
          FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the host on which the program was compiled.

     *Return value:* none

 -- Function: void lw6hlp_print_audit (lw6sys_context_t * SYS_CONTEXT,
          int ARGC, const char * [] ARGV, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays various paths used by the game.

     *Return value:* none

 -- Function: void lw6hlp_print_modules (lw6sys_context_t * SYS_CONTEXT,
          FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of modules compiled with the game.

     *Return value:* none

 -- Function: void lw6hlp_print_credits (lw6sys_context_t * SYS_CONTEXT,
          FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays all credits on f, those should be available elsewhere
     within the game (typically on splash screen) but it's good to be
     able to show them "standalone".

     *Return value:* none

 -- Function: void lw6hlp_print_list_quick (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'quick' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_doc (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'doc' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_show (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'show' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_path (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'path' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_players (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'players' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_input (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'input' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_graphics (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'graphics' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_sound (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'sound' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_network (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'network' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_map (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'map' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_map_rules (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'map rules' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_map_hints (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'map hints' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_map_style (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'map style' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_map_teams (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'map teams' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_funcs (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'funcs'.

     *Return value:* none

 -- Function: void lw6hlp_print_list_hooks (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'hooks'.

     *Return value:* none

 -- Function: void lw6hlp_print_list_advanced (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'advanced' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_aliases (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of options aliases.

     *Return value:* none

 -- Function: void lw6hlp_print_list_team_colors (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of team colors.

     *Return value:* none

 -- Function: void lw6hlp_print_list_weapons (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of weapons.

     *Return value:* none

 -- Function: void lw6hlp_print_list (lw6sys_context_t * SYS_CONTEXT,
          FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of all known options.

     *Return value:* none

 -- Function: void lw6hlp_print_hello (lw6sys_context_t * SYS_CONTEXT,
          int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: number of args as passed to main

     ARGV: array of args as passed to main

     Displays 'hello' at the beginning of the program.

     *Return value:* none

 -- Function: void lw6hlp_print_goodbye (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Displays 'goodbye', typically use at end of program to know it's
     over and everything went fine.

     *Return value:* none

 -- Function: int lw6hlp_reference_init (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Initializes the help reference, this must be called before any call
     to lw6hlp_about or such help related functions.

     *Return value:* 1 on success, 0 if failed

 -- Function: void lw6hlp_reference_quit (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     un-initializes the help reference, this must be called at the end
     of the program.

     *Return value:* 1 on success, 0 if failed

 -- Function: int lw6hlp_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libhlp module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6hlp_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'hlp' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: libimg,  Next: libker,  Prev: libhlp,  Up: C API

5.28 libimg
===========

5.28.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/img/index.html>.

5.28.2 API
----------

 -- Function: char * lw6img_repr (lw6sys_context_t * SYS_CONTEXT, const
          lw6img_jpeg_t * JPEG)
     SYS_CONTEXT: global system context

     JPEG: the jpeg to describe

     Returns a string describing the jepg.  This is a very short
     description, use it for logs, and to debug stuff.  By no means it's
     a complete exhaustive description.  Still, the string returned
     should be unique.

     *Return value:* a dynamically allocated string.

 -- Function: lw6img_jpeg_t * lw6img_screenshot_new (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, char *
          USER_DIR, int QUALITY)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to create a screenshot from

     USER_DIR: user directory

     QUALITY: quality, from 0 to 100

     Creates a JPEG screenshot from a game state.  The 'user_dir'
     parameter is used to build a file name and then use it to write
     data on disk, it is then read and kept in memory.  Globally it's
     not that bad to store it for we do not generate screenshots that
     often, and it's nice for debugging to have it so developping a
     RAM-only writer wouldn't make it a blast anyway.

     *Return value:* dynamically allocated object.

 -- Function: void lw6img_screenshot_free (lw6sys_context_t *
          SYS_CONTEXT, lw6img_jpeg_t * SCREENSHOT)
     SYS_CONTEXT: global system context

     Frees a JPEG screenshot.

     *Return value:* none.

 -- Function: int lw6img_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libimg module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6img_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'img' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6img_jpeg_s

     Contains informations about a (loaded) JPEG file.

 -- Member of lw6img_jpeg_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6img_jpeg_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6img_jpeg_s: shape
     *Type:* 'lw6sys_whd_t'

     *Definition:* 'lw6sys_whd_t lw6img_jpeg_s::shape'

     JPEG file shape, only w and h are relevant.

 -- Member of lw6img_jpeg_s: jpeg_size
     *Type:* 'int'

     *Definition:* 'int lw6img_jpeg_s::jpeg_size'

     JPEG size (file size, same as data buffer size).

 -- Member of lw6img_jpeg_s: jpeg_data
     *Type:* 'void *'

     *Definition:* 'void* lw6img_jpeg_s::jpeg_data'

     JPEG raw data.


File: liquidwar6.info,  Node: libker,  Next: libldr,  Prev: libimg,  Up: C API

5.29 libker
===========

5.29.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/ker/index.html>.

5.29.2 API
----------

 -- Function: char * lw6ker_capture_str (lw6sys_context_t * SYS_CONTEXT,
          const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: game state to represent

     Gives a string representation, an ASCII capture of the game.  This
     representation is suitable for debugging, typically print it to a
     VT100 console.

     *Return value:* dynamically allocated string.

 -- Function: void lw6ker_game_state_checksum_log_set_interval
          (lw6sys_context_t * SYS_CONTEXT, lw6ker_game_state_t *
          GAME_STATE, int CHECKSUM_LOG_INTERVAL)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to track

     CHECKSUM_LOG_INTERVAL: dump interval, if 0, feature is disabled

     Debugging function used to set automatically an interval at which
     engine will log a checksum automatically.  This is typically to
     track down where and when there starts to be a difference between
     two game_states that have evolved separately.

     *Return value:* none

 -- Function: void lw6ker_cursor_reset (lw6sys_context_t * SYS_CONTEXT,
          lw6ker_cursor_t * CURSOR)
     SYS_CONTEXT: global system context

     CURSOR: the cursor to reset

     Sets a cursor to defaults (disabled).  This function will not touch
     the node_id and cursor_id fields, so you can call it on an already
     used cursor, it will stay usable.

     *Return value:* none

 -- Function: lw6ker_game_state_t * lw6ker_game_state_new
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_struct_t *
          GAME_STRUCT, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     GAME_STRUCT: game_struct use to construct the object

     PROGRESS: progress indicator

     Creates a game state from a game struct.  The game struct must be
     kept (never freed) while game_state is in use.

     *Return value:* newly created object.

 -- Function: void lw6ker_game_state_free (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the object to free

     Frees a game_state object, releases all required objects.  At this
     stage the map_struct must still be available.

     *Return value:* none

 -- Function: void lw6ker_game_state_point_to (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, const
          lw6ker_game_struct_t * GAME_STRUCT)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to modify

     GAME_STRUCT: the game_struct to point to

     This can be used when one makes a copy (dup) of a game struct and
     for some reason want the game_state to point on this new copy.  Of
     course you should make the game_state point to a game_struct that
     is identical to the one that was used to construct the object in
     the first place.  Use at your own risk.

     *Return value:* none

 -- Function: int lw6ker_game_state_memory_footprint (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Returns the approximative amount of memory taken by the object.

     *Return value:* number of bytes (approximation)

 -- Function: char * lw6ker_game_state_repr (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Gives a readable representation of the object.

     *Return value:* newly allocated string, must be freed

 -- Function: int lw6ker_game_state_can_sync (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * DST, const
          lw6ker_game_state_t * SRC)
     SYS_CONTEXT: global system context

     DST: the destination game_state

     SRC: the source game_state

     Tells wether src and dst can be synced.  This is not a fool proof
     function but in most cases it will raise the error, use it to avoid
     blunders.  It just compares 'dst' and 'src' and tries to guess if
     they correspond to the same logical objects.

     *Return value:* 1 if they are syncable, 0 if not.

 -- Function: int lw6ker_game_state_sync (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * DST, const
          lw6ker_game_state_t * SRC)
     SYS_CONTEXT: global system context

     DST: the destination game_state

     SRC: the source game_state

     Fundamental function, used to carbon copy a game state to another,
     this is intensively used to keep too tracks of the game state, one
     most-up-to-date but probably wrong, the one we use to display on
     the screen, and one slightly outdated (or very outdated if network
     is slow) but that we're sure of, something 100% bullet proof we can
     rely on.

     *Return value:* 1 on success, 0 on error

 -- Function: lw6ker_game_state_t * lw6ker_game_state_dup
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_state_t *
          GAME_STATE, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to copy

     PROGRESS: progress indicator

     Dups (copy) a game_state object.  The newly created object points
     to the same game_struct but is an independant copy, you can play a
     whole different game on it.  In practice this is often used to
     create the game_state objects for anticipation in network games.

     *Return value:* newly created object

 -- Function: u_int32_t lw6ker_game_state_checksum (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Calculates the checksum of a game_state, this can be very usefull
     to make sure two states are identicall (prevent network errors
     and/or cheating).

     *Return value:* 32-bit checksum

 -- Function: void lw6ker_game_state_get_shape (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE,
          lw6sys_whd_t * SHAPE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     SHAPE: the shape (out param)

     Retrieves the shape (w*h*d)of the game_state.

     *Return value:* none.

 -- Function: int lw6ker_game_state_get_w (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Retrieves the width (shape.w) of the game_state.

     *Return value:* the width.

 -- Function: int lw6ker_game_state_get_h (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Retrieves the height (shape.h) of the game_state.

     *Return value:* the height.

 -- Function: int lw6ker_game_state_get_d (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Retrieves the depth (shape.d, AKA number of layers) of the
     game_state.

     *Return value:* the depth.

 -- Function: int lw6ker_game_state_register_node (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, u_int64_t
          NODE_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to act on

     NODE_ID: the id of the node to register

     Registers a node in the game, this must be done, else no action
     will be allowed (such as adding a cursor or moving it).  There's a
     limited number of nodes allowed, and ids must be unique.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6ker_game_state_unregister_node (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, u_int64_t
          NODE_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to act on

     NODE_ID: the id of the node to register

     Unregisters a node in the game, this must be done when a node
     leaves the game, it will free ressources and allow others to
     connect.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6ker_game_state_node_exists (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, u_int64_t
          NODE_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     NODE_ID: the node to test

     Tells wether a node is present in a game.

     *Return value:* 1 if node is in game, 0 if not

 -- Function: int lw6ker_game_state_get_node_info (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, u_int16_t
          NODE_ID, u_int32_t * LAST_COMMAND_ROUND)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     NODE_ID: the node to get info about

     LAST_COMMAND_ROUND: the last round for which a command was issued
     (out parameter)

     Queries information about a given node, mostly, what was the last
     round we got a command.

     *Return value:* 1 on success, 0 on error.

 -- Function: int lw6ker_game_state_add_cursor (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, u_int64_t
          NODE_ID, u_int16_t CURSOR_ID, int TEAM_COLOR)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to act upon

     NODE_ID: the node issuing the command

     CURSOR_ID: the id of the cursor to add

     TEAM_COLOR: the color we wish

     Adds a cursor in a game.  Note that if there's already a cursor
     with that id, it will fail, and the color is only the color we
     wish, we might indeed be attributed another color on a successfull
     call.

     *Return value:* 1 on success, 0 on error.

 -- Function: int lw6ker_game_state_remove_cursor (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, u_int64_t
          NODE_ID, u_int16_t CURSOR_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to act upon

     NODE_ID: the node issuing the command

     CURSOR_ID: the id of the cursor to remove

     Removes a cursor from the game, corresponding teams will be removed
     if needed.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6ker_game_state_cursor_exists (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, u_int16_t
          CURSOR_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     CURSOR_ID: the cursor to test

     Tells wether a cursor is present in the game.

     *Return value:* 1 if cursor exists, 0 if not.

 -- Function: int lw6ker_game_state_get_cursor (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE,
          lw6ker_cursor_t * CURSOR, u_int16_t CURSOR_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     CURSOR: the cursor data (out param)

     CURSOR_ID: the cursor to query

     Get a pointer on a given cursor, pointer is read-only.

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6ker_game_state_get_cursor_by_index
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_state_t *
          GAME_STATE, lw6ker_cursor_t * CURSOR, int I)
     SYS_CONTEXT: global system context

     GAME_STATE: the game state to query

     CURSOR: the cursor (out param)

     I: the index

     Gets the cursor information, using its index.  This is usefull to
     walk the whole cursor without knowing their ids.  Pointer is
     read-only.

     *Return value:* none.

 -- Function: int lw6ker_game_state_set_cursor (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, lw6ker_cursor_t
          * CURSOR)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to act upon

     CURSOR: the cursor

     Sets a cursor, that is, changes its position, this is pretty much
     anything we can do about a cursor except adding or removing it,
     just because of Liquid War very simple rules.  The passed pointer
     may be freed after the call, only the 'cursor_id', 'node_id', 'x',
     'y' and 'fire' fields are used, others are ignored.  More
     precisely, the 'enabled' will be ignored, it's not a valid way to
     add/remove teams.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6ker_game_state_team_exists (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int
          TEAM_COLOR)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     TEAM_COLOR: the team color to test

     Tells wether a team color is present in the game.  Note that this
     is different from cursor ids.

     *Return value:* 1 if team exists, 0 if not.

 -- Function: int lw6ker_game_state_get_team_info (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int
          TEAM_COLOR, int32_t * NB_CURSORS, int32_t * NB_FIGHTERS)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     TEAM_COLOR: the color to get informations about

     NB_CURSORS: number of cursors with this color (out param)

     NB_FIGHTERS: number of fighters with this color (out param)

     Gets informations about a given color.  Indeed, a color can have
     several cursors, and knowing how many fighters there are with a
     given color is probably the most important things about a color.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6ker_game_state_get_nb_teams (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Tells how many teams there are in a game.  This is different from
     the cursors number, there can be more cursors than teams, because a
     team can have several cursors.

     *Return value:* the number of teams.

 -- Function: void lw6ker_game_state_do_spread (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, u_int32_t
          TEAM_MASK)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to act upon

     TEAM_MASK: a binary mask of which gradients (teams) must be
     spreaded

     Spreads the gradient, that is, calculates the potential of each
     point on the map, ie the distance to the closest cursor.  The
     binary mask allows gradient to be spread for only some teams, this
     is usefull in a multithreaded context, as gradients can be
     calculated separately.

     *Return value:* none

 -- Function: void lw6ker_game_state_do_move (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, u_int32_t
          TEAM_MASK)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to act upon

     TEAM_MASK: a binary mask of which teams must be moved

     Moves the fighters, note that you must calculate the gradient from
     time to time else they go to the wrong places.  The 'team_mask'
     allows the moving of only some given teams, but moving (for
     instance) even teams then odd teams isn't the same as moving odd
     teams then even teams.  Whereas as far as gradient calculation is
     concerned, this could have been true, you could have multithreaded
     that.

     *Return value:* none.

 -- Function: void lw6ker_game_state_finish_round (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to act upon

     Finishes a round, that is, vaccums various stuff, checks if some
     team has lost, and so on.  This is complementary to the spread and
     move steps, it should be called at each round.

     *Return value:* none.

 -- Function: void lw6ker_game_state_do_round (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to act upon

     This is a fundamental function, it's called at each round, it fires
     all the complex calculations in the game, the real core algorithm.
     Every time this function is called, the round is "over" and the
     game state is ready for the next...  round.  It's equivalent to
     calling the spread, move and finish functions.

     *Return value:* none.

 -- Function: u_int32_t lw6ker_game_state_get_moves (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Returns the number of moves done on this game.

     *Return value:* number of moves.

 -- Function: u_int32_t lw6ker_game_state_get_spreads (lw6sys_context_t
          * SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Returns the number of spreads done on this game.

     *Return value:* number of spreads.

 -- Function: u_int32_t lw6ker_game_state_get_rounds (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Returns the number of rounds done on this game.

     *Return value:* number of rounds.

 -- Function: u_int32_t lw6ker_game_state_get_total_rounds
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_state_t *
          GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Returns the number of playable rounds in the game, that is the
     number of rounds to be played if game goes up to the time limit.
     This is a fixed number, if game slows down then time is stretched,
     but the the exact maximum number of rounds is known at game start,
     and it is the number returned by this function.

     *Return value:* number of rounds in the game

 -- Function: int lw6ker_game_state_is_over (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Tells wether the game is over or not.  The answer depends on time
     limit, game rules, and of course what happened on the battlefield.

     *Return value:* 1 if over, 0 if not.

 -- Function: int lw6ker_game_state_did_cursor_win (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, u_int16_t
          CURSOR_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     CURSOR_ID: the cursor to test

     Tells wether a cursor was the winner after a game is over.

     *Return value:* 1 if cursor is in winning team, 0 if not.

 -- Function: int lw6ker_game_state_get_winner (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int
          EXCLUDED_TEAM)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     EXCLUDED_TEAM: a team to exclude

     Returns the winner, if you set excluded_team to something else than
     a valid team number (for instance -1, but 0 is a valid team) then
     this team will be excluded from search.  This is usefull if you
     want to find out who's the best positionned player while excluding
     yourself, for instance if you're a bot.

     *Return value:* the winner team number, note that it can be invalid
     (-1) if there's no winner (for example, there are no teams on the
     map).

 -- Function: int lw6ker_game_state_get_looser (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int
          EXCLUDED_TEAM)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     EXCLUDED_TEAM: a team to exclude

     Returns the looser, if you set excluded_team to something else than
     a valid team number (for instance -1, but 0 is a valid team) then
     this team will be excluded from search.  This is usefull if you
     want to find out who's the worst positionned player while excluding
     yourself, for instance if you're a bot.

     *Return value:* the looser team number, note that it can be invalid
     (-1) if there's no looser (for example, there are no teams on the
     map).

 -- Function: int32_t lw6ker_game_state_get_nb_active_fighters
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_state_t *
          GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Gets the number of active fighters, this is relatively constant
     within the game, it does not change when someone looses, but it can
     vary when a new team arrives or disappears.

     *Return value:* number of fighters.

 -- Function: int32_t lw6ker_game_state_get_time_elapsed
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_state_t *
          GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Returns the time elapsed, this is not the real time you'd time with
     an atomic clock, rather the time that would have elapsed if game
     had been run at its nominal speed.  There can be a difference if
     your computer is too slow, among other things.

     *Return value:* time elapsed, in seconds.

 -- Function: int32_t lw6ker_game_state_get_time_left (lw6sys_context_t
          * SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Returns the time left, this is not the real time you'd time with an
     atomic clock, rather the time that would theorically be left is
     game was to be run at its nominal speed.  There can be a difference
     if your computer is too slow, among other things.  You shouldn't
     rely on this to know wether a game is over or not, there's another
     dedicated function for that.

     *Return value:* time left, in seconds.

 -- Function: int32_t lw6ker_game_state_get_global_history
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_state_t *
          GAME_STATE, int I, int TEAM_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     I: the index of the history point

     TEAM_ID: the team to query

     Returns the number of fighters at some point in the past (the lower
     i, the oldest).  The history scrolls automatically and erases
     itself at some point, it's of constant length.  This is the global,
     long term history, reflects the whole game and could be used for an
     end-game score screen.

     *Return value:* number of fighters at that time.

 -- Function: int32_t lw6ker_game_state_get_latest_history
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_state_t *
          GAME_STATE, int I, int TEAM_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     I: the index of the history point

     TEAM_ID: the team to query

     Returns the number of fighters at some point in the past (the lower
     i, the oldest).  The history scrolls automatically and erases
     itself at some point, it's of constant length.  This is the latest,
     short term history, reflects the recent game evolutions and could
     be used to display an in-game monitor.

     *Return value:* number of fighters at that time.

 -- Function: int32_t lw6ker_game_state_get_global_history_max
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_state_t *
          GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     Returns the maximum value, that is, the maximum number of fighters,
     all teams combined, for this history.  This can be used to scale
     charts.  This function for the global long term history.

     *Return value:* max number of fighters.

 -- Function: int32_t lw6ker_game_state_get_latest_history_max
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_state_t *
          GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     Returns the maximum value, that is, the maximum number of fighters,
     all teams combined, for this history.  This can be used to scale
     charts.  This function for the latest short term history.

     *Return value:* max number of fighters.

 -- Function: int32_t lw6ker_game_state_get_fighter_id (lw6sys_context_t
          * SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int32_t
          X, int32_t Y, int32_t Z)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     X: x position

     Y: y position

     Z: z position

     Gets the id of a fighter in a given position.  Previous versions of
     the game used to have this declared inline static for speed, but
     the price to pay in terms of maintainability was too high: too much
     stuff from the ker module had to be kept public.  This functions is
     very likely to be called often when one wants to know what's
     happening on the battlefield, to draw it, for instance.  If there's
     no fighter, the id is negative, any id equal or greater than 0
     (returned by this function) is valid.

     *Return value:* the id of the fighter at that position.

 -- Function: lw6ker_fighter_t * lw6ker_game_state_get_fighter_rw_by_id
          (lw6sys_context_t * SYS_CONTEXT, lw6ker_game_state_t *
          GAME_STATE, int32_t FIGHTER_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     FIGHTER_ID: the id of the fighter

     Gets a fighter by its id.  Internally, all fighters are stored in
     an array so it could be "safe" to get fighter with id 0 then walk
     the array.  Previous versions of the game used to have this public
     (the array), it has been hidden since.  Pointer is read/write.
     Pointer is read/write.

     *Return value:* pointer to the fighter with the given id.

 -- Function: lw6ker_fighter_t * lw6ker_game_state_get_fighter_rw_safe
          (lw6sys_context_t * SYS_CONTEXT, lw6ker_game_state_t *
          GAME_STATE, int32_t X, int32_t Y, int32_t Z)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     X: x position

     Y: y position

     Z: z position

     Gets a fighter by its position.  This function will check for
     boundaries, if there's no fighter in this place, it will return
     NULL, but nothing worse can happen.  More precisely, if the place
     is in a wall, it won't bug, unlike the non-bullet-proof equivalent
     of this function.  Pointer is read/write.

     *Return value:* pointer to the fighter at this position, or NULL if
     none.

 -- Function: lw6ker_fighter_t * lw6ker_game_state_get_fighter_rw_unsafe
          (lw6sys_context_t * SYS_CONTEXT, lw6ker_game_state_t *
          GAME_STATE, int32_t X, int32_t Y, int32_t Z)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     X: x position

     Y: y position

     Z: z position

     Gets a fighter by its position.  This function will not check for
     boundaries, if there's no fighter in this place, not only will it
     probably not return a valid value, but it will also even segfault
     before that, trying to access non-existing structures in menory.
     So only call this if you're sure there's a fighter here.  Pointer
     is read/write.

     *Return value:* pointer to the fighter at this position, or NULL if
     none.

 -- Function: const lw6ker_fighter_t *
          lw6ker_game_state_get_fighter_ro_by_id (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int32_t
          FIGHTER_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     FIGHTER_ID: the id of the fighter

     Gets a fighter by its id.  Internally, all fighters are stored in
     an array so it could be "safe" to get fighter with id 0 then walk
     the array.  Previous versions of the game used to have this public
     (the array), it has been hidden since.  Pointer is read-only.
     Pointer is read-only.

     *Return value:* pointer to the fighter with the given id.

 -- Function: const lw6ker_fighter_t *
          lw6ker_game_state_get_fighter_ro_safe (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int32_t
          X, int32_t Y, int32_t Z)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     X: x position

     Y: y position

     Z: z position

     Gets a fighter by its position.  This function will check for
     boundaries, if there's no fighter in this place, it will return
     NULL, but nothing worse can happen.  More precisely, if the place
     is in a wall, it won't bug, unlike the non-bullet-proof equivalent
     of this function.  Pointer is read-only.

     *Return value:* pointer to the fighter at this position, or NULL if
     none.

 -- Function: const lw6ker_fighter_t *
          lw6ker_game_state_get_fighter_ro_unsafe (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int32_t
          X, int32_t Y, int32_t Z)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     X: x position

     Y: y position

     Z: z position

     Gets a fighter by its position.  This function will not check for
     boundaries, if there's no fighter in this place, not only will it
     probably not return a valid value, but it will also even segfault
     before that, trying to access non-existing structures in menory.
     So only call this if you're sure there's a fighter here.  Pointer
     is read-only.

     *Return value:* pointer to the fighter at this position, or NULL if
     none.

 -- Function: int lw6ker_game_state_get_zone_potential (lw6sys_context_t
          * SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int I,
          int TEAM_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     TEAM_ID: the team id (color)

     Gets the potential of a zone.  In practice this is not needed to
     make the game function, you need not call this to know how to move
     fighters, however the information can be interesting for debugging.

     *Return value:* the potential

 -- Function: int lw6ker_game_state_get_charge_per1000 (lw6sys_context_t
          * SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int
          TEAM_COLOR)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     TEAM_COLOR: the team color to query

     Returns the charge ratio for a given team/color.  A value of 100
     means fire is enabled, more than 1000 means super-charge, under 100
     means you have to wait.

     *Return value:* integer value.

 -- Function: int lw6ker_game_state_get_weapon_per1000_left
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_state_t *
          GAME_STATE, int TEAM_COLOR)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     TEAM_COLOR: the team color to query

     Returns how much of the weapon is yet to be consumed for a given
     team.  More than 1000 means extra time, 1000 is standard time to be
     elapsed, 0 means it's over.

     *Return value:* integer value.

 -- Function: int lw6ker_game_state_get_latest_weapon (lw6sys_context_t
          * SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int *
          TEAM_COLOR, int * WEAPON_ID, int * PER1000_LEFT)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     TEAM_COLOR: the team color corresponding to last weapon (out param)

     WEAPON_ID: the corresponding weapon_id (out param)

     PER1000_LEFT: how much of the weapon is yet to be spent (out param)

     Returns informations about the latest weapon, this is typically for
     drawing purposes, just query this and you know if you need to paint
     everything in red, green, whatever, as far as the default backend
     is concerned.  In case there's no weapon, well, parameters are
     untouched.  Pointers can be passed as NULL.

     *Return value:* 1 if found, 0 if not.

 -- Function: int lw6ker_game_state_get_nb_colors (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: game state to query

     Gives the max number of colors (AKA teams) that are present in the
     game.  This is just a simple utility/wrapper function which is
     meant to be exported to Guile scripts.

     *Return value:* number of colors

 -- Function: int lw6ker_game_state_get_nb_cursors (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: game state to query

     Gives the max number of cursors that are present in the game.  This
     is just a simple utility/wrapper function which is meant to be
     exported to Guile scripts.

     *Return value:* number of cursors

 -- Function: int lw6ker_game_state_get_nb_nodes (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: game state to query

     Gives the max number of nodes that are present in the game.  This
     is just a simple utility/wrapper function which is meant to be
     exported to Guile scripts.

     *Return value:* number of nodes

 -- Function: lw6ker_game_struct_t * lw6ker_game_struct_new
          (lw6sys_context_t * SYS_CONTEXT, const lw6map_level_t * LEVEL,
          lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     LEVEL: the level on which the game_struct is based

     PROGRESS: progress indicator

     Creates a new game_struct from a level.  The game_struct is
     different from the level in the sense that the game_struct does
     contain algorithmic specific optimizations, it's a ready-to-use
     struct desgined for execution speed, while the plain level just
     stores information.

     *Return value:* newly allocated object

 -- Function: void lw6ker_game_struct_free (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_struct_t * GAME_STRUCT)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to free

     Frees a game_struct object, releasing all required stuff.  The
     source level must still be available when freeing this.

     *Return value:* none

 -- Function: void lw6ker_game_struct_point_to (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_struct_t * GAME_STRUCT, const
          lw6map_level_t * LEVEL)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to modify

     LEVEL: the level to point to

     This can be used when one makes a copy (dup) of a level and for
     some reason want the game_struct to point on this new copy.  Of
     course you should make the game_struct point to a level that is
     identical to the one that was used to construct the object in the
     first place.  Use at your own risk.

     *Return value:* none

 -- Function: int lw6ker_game_struct_memory_footprint (lw6sys_context_t
          * SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     Returns the approximative amount of memory taken by the object.

     *Return value:* number of bytes (approximation)

 -- Function: char * lw6ker_game_struct_repr (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     Gives a readable representation of the object.

     *Return value:* newly allocated string, must be freed

 -- Function: lw6ker_game_struct_t * lw6ker_game_struct_dup
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_struct_t *
          GAME_STRUCT, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to copy

     PROGRESS: progress indicator

     Dups (copy) a game_struct object.  The newly created object points
     to the same game_struct but is an independant copy, you can play a
     whole different game on it.  In practice this is often used to
     create the game_struct objects for anticipation in network games.

     *Return value:* newly created object

 -- Function: u_int32_t lw6ker_game_struct_checksum (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     Calculates the checksum of a game_struct, this can be very usefull
     to make sure two structs are identicall (prevent network errors
     and/or cheating).

     *Return value:* 32-bit checksum

 -- Function: void lw6ker_game_struct_get_shape (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT,
          lw6sys_whd_t * SHAPE)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     SHAPE: the shape (out param)

     Retrieves the shape (w*h*d)of the game_struct.

     *Return value:* none.

 -- Function: int lw6ker_game_struct_get_w (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     Retrieves the width (shape.w) of the game_struct.

     *Return value:* the width.

 -- Function: int lw6ker_game_struct_get_h (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     Retrieves the height (shape.h) of the game_struct.

     *Return value:* the height.

 -- Function: int lw6ker_game_struct_get_d (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     Retrieves the depth (shape.d, AKA number of layers) of the
     game_struct.

     *Return value:* the depth.

 -- Function: int lw6ker_game_struct_is_fg (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT, int32_t
          X, int32_t Y, int32_t Z)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     X: x position

     Y: y position

     Z: z position

     Tests wether a given position is foreground, that is, occupied by a
     wall.

     *Return value:* 1 if foreground (wall, fighters can't move), 0 if
     not

 -- Function: int lw6ker_game_struct_is_bg (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT, int32_t
          X, int32_t Y, int32_t Z)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     X: x position

     Y: y position

     Z: z position

     Tests wether a given position is background, that is, there's no
     wall.

     *Return value:* 1 if background (wall, fighters can move), 0 if not

 -- Function: void lw6ker_game_struct_get_zones_info (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT, int *
          NB_ZONES, int * MAX_ZONE_SIZE)
     SYS_CONTEXT: global system context

     GAME_STRUCT: game_struct to query

     NB_ZONES: the maximum zone size (out param, can be NULL)

     MAX_ZONE_SIZE: the maximum zone size (out param, can be NULL)

     This function gets information about the internal zoning system,
     can be used for debugging.

     *Return value:* none.

 -- Function: void lw6ker_game_struct_get_zone_info (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT, int I,
          lw6sys_xyz_t * ZONE_POS, int * ZONE_SIZE)
     SYS_CONTEXT: global system context

     GAME_STRUCT: game_struct to query

     I: index of the zone to query

     ZONE_POS: coord of the zone, top-left corner (out param, can be
     NULL)

     ZONE_SIZE: size of the zone (out param, can be NULL)

     This function gets information about the internal zoning system,
     can be used for debugging.

     *Return value:* none

 -- Function: int32_t lw6ker_game_struct_get_zone_id (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT, int32_t
          X, int32_t Y, int32_t Z)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     X: x pos

     Y: y pos

     Z: z pos

     Gets the zone id for a given position.  The id returned can then be
     used to query for a potential, for instance.

     *Return value:* the zone id

 -- Function: void lw6ker_game_struct_find_free_slot_near
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_struct_t *
          GAME_STRUCT, lw6sys_xyz_t * THERE, lw6sys_xyz_t HERE)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     THERE: the closest free slot (out param)

     HERE: where we'd like to be

     Tries to find the closest free slot (there) near a given position
     (here).  This is typically used internally to find out where to
     apply the cursor when it's flying over walls.

     *Return value:* none

 -- Function: char * lw6ker_game_struct_to_hexa (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game struct to convert

     Converts a map to something that is later readable by
     'lw6ker_game_struct_from_hexa' to reproduce the exact same map.
     Just a serializer.

     *Return value:* a newly allocated pointer, NULL if conversion
     failed.

 -- Function: lw6ker_game_struct_t * lw6ker_game_struct_from_hexa
          (lw6sys_context_t * SYS_CONTEXT, const char * HEXA, const
          lw6map_level_t * LEVEL)
     SYS_CONTEXT: global system context

     HEXA: an hexadecimal ASCII string, created by
     'lw6ker_game_struct_to_hexa'

     LEVEL: the level this game_struct is bounded to

     Constructs a game struct from an hexadecimal string generated by
     'lw6ker_game_struct_to_hexa'.  Just an un-serializer.

     *Return value:* a new map, might be NULL if string isn't correct.

 -- Function: char * lw6ker_game_state_to_hexa (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game state to convert

     Converts a map to something that is later readable by
     'lw6ker_game_state_from_hexa' to reproduce the exact same map.
     Just a serializer.

     *Return value:* a newly allocated pointer, NULL if conversion
     failed.

 -- Function: lw6ker_game_state_t * lw6ker_game_state_from_hexa
          (lw6sys_context_t * SYS_CONTEXT, const char * HEXA, const
          lw6ker_game_struct_t * GAME_STRUCT)
     SYS_CONTEXT: global system context

     HEXA: an hexadecimal ASCII string, created by
     'lw6ker_game_state_to_hexa'

     GAME_STRUCT: the game_struct this game_state is bounded to

     Constructs a game state from an hexadecimal string generated by
     'lw6ker_game_state_to_hexa'.  Just an un-serializer.

     *Return value:* a new map, might be NULL if string isn't correct.

 -- Function: int lw6ker_move_get_best_next_pos (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE,
          lw6sys_xyz_t * NEXT_POS, lw6sys_xyz_t * CURRENT_POS, int
          TEAM_COLOR)
     GAME_STATE: the game_state to work on

     NEXT_POS: the next position (out param)

     CURRENT_POS: the current position

     TEAM_COLOR: the team color

     Tries to find the best move given a position and a team.  Note that
     this function does not check for the presence of another fighter,
     it will only check walls and can even (sometimes) fail when there's
     a path.  The reason is that it uses the game_state at a given round
     and does not recalculate gradient while a real fighter has an
     ever-changing gradient.  Whatsoever, this can be used to move
     cursors like they were fighters, it's not perfect but gives a good
     illusion.

     *Return value:* 1 if best place found, 0 if not.

 -- Function: int lw6ker_score_array_update (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_score_array_t * SCORE_ARRAY, const
          lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     SCORE_ARRAY: the score array to modify

     GAME_STATE: the game_state to get the information from

     Updates a score array, that is, calculates all scores, so that they
     can be displayed, for instance.

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6ker_team_mask_get (lw6sys_context_t * SYS_CONTEXT,
          u_int32_t * EVEN, u_int32_t * ODD, int32_t ROUND)
     SYS_CONTEXT: global system context

     EVEN: even team mask (out param)

     ODD: odd team mask (out param)

     ROUND: round concerned

     Returns a default team mask for a given round, even and odd will
     contain ready to use masks (for spread and move functions for
     instance).

     *Return value:* none.

 -- Function: void lw6ker_team_mask_best (lw6sys_context_t *
          SYS_CONTEXT, u_int32_t * EVEN, u_int32_t * ODD,
          lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     EVEN: even team mask (out param)

     ODD: odd team mask (out param)

     GAME_STATE: the game_state concerned

     Returns an optimal team mask for a given round, even and odd will
     contain ready to use masks (for spread and move functions for
     instance).  The difference with the default team mask is that this
     one will test for which teams are present and try and manage to
     find an equilibrated set of odd/even teams.

     *Return value:* none.

 -- Function: int lw6ker_team_mask_is_concerned (lw6sys_context_t *
          SYS_CONTEXT, int TEAM_COLOR, u_int32_t TEAM_MASK)
     SYS_CONTEXT: global system context

     TEAM_COLOR: color index

     TEAM_MASK: team mask

     Tells wether a given team is concerned by a team mask.

     *Return value:* 1 if concerned, 0 if not.

 -- Function: int lw6ker_team_mask_color2mask (lw6sys_context_t *
          SYS_CONTEXT, int TEAM_COLOR)
     TEAM_COLOR: color index

     Gives the mask corresponding to a given color.

     *Return value:* bitwise mask.

 -- Function: int lw6ker_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libker module.  Thoses tests Will
     perform deep checksums and *really* check many things.  If this
     passes, the algorithm is fine.  What could make it fail is a
     serious bug and/or some weird combination of endianess, byte
     alignment...  *

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6ker_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'ker' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6ker_cursor_control_s

     Contains a cursor controls state, basically a cursor is a position
     plus a fire and fire2 booleans.

 -- Member of lw6ker_cursor_control_s: pos
     *Type:* 'lw6sys_xyz_t'

     *Definition:* 'lw6sys_xyz_t lw6ker_cursor_control_s::pos'

     Cursor position, z isn't relevant for now.

 -- Member of lw6ker_cursor_control_s: fire
     *Type:* 'int'

     *Definition:* 'int lw6ker_cursor_control_s::fire'

     Fire, 1 if primary weapon must be used.

 -- Member of lw6ker_cursor_control_s: fire2
     *Type:* 'int'

     *Definition:* 'int lw6ker_cursor_control_s::fire2'

     Fire2, 1 if secondary weapon must be used.

 -- Struct: lw6ker_cursor_s

     Data about a given cursor.

 -- Member of lw6ker_cursor_s: node_id
     *Type:* 'u_int64_t'

     *Definition:* 'u_int64_t lw6ker_cursor_s::node_id'

     The id of the node this cursor belongs to.

 -- Member of lw6ker_cursor_s: cursor_id
     *Type:* 'u_int16_t'

     *Definition:* 'u_int16_t lw6ker_cursor_s::cursor_id'

     The id of this cursor.

 -- Member of lw6ker_cursor_s: letter
     *Type:* 'char'

     *Definition:* 'char lw6ker_cursor_s::letter'

     ASCII code of the letter associated to the cursor.

 -- Member of lw6ker_cursor_s: enabled
     *Type:* 'int'

     *Definition:* 'int lw6ker_cursor_s::enabled'

     Wether the cursor is enabled/active or not.

 -- Member of lw6ker_cursor_s: team_color
     *Type:* 'int'

     *Definition:* 'int lw6ker_cursor_s::team_color'

     Team associated with this cursor.

 -- Member of lw6ker_cursor_s: pos
     *Type:* 'lw6sys_xyz_t'

     *Definition:* 'lw6sys_xyz_t lw6ker_cursor_s::pos'

     Cursor position, z isn't relevant for now.

 -- Member of lw6ker_cursor_s: fire
     *Type:* 'int'

     *Definition:* 'int lw6ker_cursor_s::fire'

     Primary fire button state.

 -- Member of lw6ker_cursor_s: fire2
     *Type:* 'int'

     *Definition:* 'int lw6ker_cursor_s::fire2'

     Alternate fire button state.

 -- Member of lw6ker_cursor_s: apply_pos
     *Type:* 'lw6sys_xyz_t'

     *Definition:* 'lw6sys_xyz_t lw6ker_cursor_s::apply_pos'

     Position to apply cursor on.  Problem follows: cursor might be
     hanging on a wall, somewhere fighters can't go.  In that case an
     alternate position is find, usually the closest free space.  But
     this can take time to calculate so we cache this value here, as it
     is convenient to have it at hand.

 -- Member of lw6ker_cursor_s: pot_offset
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6ker_cursor_s::pot_offset'

     Potential offset.  Whenever the cursor is applied to some place,
     one can add a potential to it, this can be used to make some cursor
     more attractive than others.

 -- Struct: lw6ker_fighter_s

     Contains the parameters of a fighter, one of those little squares
     that are that at the very heart of Liquid War.

 -- Member of lw6ker_fighter_s: team_color
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6ker_fighter_s::team_color'

     Team color from 0 to 9, -1 if invalid.

 -- Member of lw6ker_fighter_s: last_direction
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6ker_fighter_s::last_direction'

     Last direction this fighter used, this is important for in some
     cases we want to know where the fighter was heading before, our
     current choice might rely on previous state.

 -- Member of lw6ker_fighter_s: health
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6ker_fighter_s::health'

     Fighter health from 0 to 10000.

 -- Member of lw6ker_fighter_s: act_counter
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6ker_fighter_s::act_counter'

     This counter is used to handle speed up/slow down.  At each round
     it's incremented, whenever it reaches 100 then the fighter really
     acts.  Basically, there's a Bresenham algorithm behind all that.

 -- Member of lw6ker_fighter_s: pad
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6ker_fighter_s::pad'

     Free for later use.

 -- Member of lw6ker_fighter_s: pos
     *Type:* 'lw6sys_xyz_t'

     *Definition:* 'lw6sys_xyz_t lw6ker_fighter_s::pos'

     Fighter position.

 -- Struct: lw6ker_game_state_s

     Game structure containing all changeable data state, this will hold
     the fighter positions, their health, the cursors position, the
     gradient, anything that is dynamic.  Note that this structure is a
     wrapper over the internal structure which contains the real
     members, the first two members need be the same as it is casted
     internally.

 -- Member of lw6ker_game_state_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6ker_game_state_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6ker_game_state_s: game_struct
     *Type:* 'lw6ker_game_struct_t *'

     *Definition:* 'lw6ker_game_struct_t*
     lw6ker_game_state_s::game_struct'

     Pointer on the game non-mutable structure, which holds the data
     that is never changed within a game.

 -- Struct: lw6ker_game_struct_s

     Game struct is very similar to the level struct of the lw6map
     module.  Indeed, it's immutable and won't change during the game.
     The difference with lw6map_level is that game_struct is algorithm
     aware and has many tricks, special internals, cached data, so that
     it speeds up the overall algorithm.  In fact it contains everything
     lw6ker_game_state needs to have but need not change during the
     game.  The 3 first members, id, level, rules are the same as the
     internal _lw6ker_game_struct_t structure.  The rest of it is
     hidden.  The program will cast from lw6ker_game_struct_t to
     _lw6ker_game_struct_t internally.

 -- Member of lw6ker_game_struct_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6ker_game_struct_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6ker_game_struct_s: level
     *Type:* 'lw6map_level_t *'

     *Definition:* 'lw6map_level_t* lw6ker_game_struct_s::level'

     Pointer on the level source structure.  This one might still retain
     informations we don't want to duplicate here, for instance the
     textures, which are of no use for the core algorithm so are
     pointless to backup here, but are still of interest for high-level
     functions such as display stuff.

 -- Member of lw6ker_game_struct_s: rules
     *Type:* 'lw6map_rules_t'

     *Definition:* 'lw6map_rules_t lw6ker_game_struct_s::rules'

     Game rules, this is just a cached copy to avoid derefencing the
     level pointer any time we need to query a parameter.

 -- Struct: lw6ker_score_array_s

     This is an array which contains all scores for all teams, it's
     calculated from game_state and should be used read only by code
     which is not within lw6ker.

 -- Member of lw6ker_score_array_s: active_fighters
     *Type:* 'int'

     *Definition:* 'int lw6ker_score_array_s::active_fighters'

     Number of fighters on the battlefield.

 -- Member of lw6ker_score_array_s: nb_scores
     *Type:* 'int'

     *Definition:* 'int lw6ker_score_array_s::nb_scores'

     Number of score items.  This can be greater than the number of
     active teams, since it retains informations about teams which have
     disappeared.

 -- Member of lw6ker_score_array_s: scores
     *Type:* 'lw6ker_score_t'

     *Definition:* 'lw6ker_score_t
     lw6ker_score_array_s::scores[LW6MAP_NB_TEAM_COLORS]'

     Scores for each team, they are sorted, the first one with index 0
     is the current winner, then all other teams follow, the last one
     being Mr Looser.

 -- Struct: lw6ker_score_s

     Stores the score information about a team, this structure is used
     to get informations from the game, and display them.

 -- Member of lw6ker_score_s: has_been_active
     *Type:* 'int'

     *Definition:* 'int lw6ker_score_s::has_been_active'

     Wether this team (this color) has been active at some point during
     the game.  This is important for at score time, many teams might
     have been disabled, this is typical of dead teams in the LW5 last
     player wins scheme.  It can also happen in network games after a
     team leaves.  Note that this way of counting active teams does not
     allow fine grain knowledge of who played, for the yellow team might
     have been played by different nodes through a single game session.

 -- Member of lw6ker_score_s: team_color
     *Type:* 'int'

     *Definition:* 'int lw6ker_score_s::team_color'

     The color of the team this score is about.

 -- Member of lw6ker_score_s: fighters_percent
     *Type:* 'int'

     *Definition:* 'int lw6ker_score_s::fighters_percent'

     Percentage of fighters for this team.  The global score array
     object will take care of making the sum of fighters_percent be
     exactly 100, regardless of exactitude, it will round this number to
     make a nice total and hide rounding errors.

 -- Member of lw6ker_score_s: fighters_absolute
     *Type:* 'int'

     *Definition:* 'int lw6ker_score_s::fighters_absolute'

     Absolute number of fighters for this team.

 -- Member of lw6ker_score_s: fighters_ratio
     *Type:* 'float'

     *Definition:* 'float lw6ker_score_s::fighters_ratio'

     One of the rare float in lw6ker, only for eye candy, this is the
     equivalent of fighters_percent but as a float between 0.0f and
     1.0f.  It gives the possibility of more precise graphical displays,
     will its integer companion value is usefull for writing down
     scores.

 -- Member of lw6ker_score_s: frags
     *Type:* 'int'

     *Definition:* 'int lw6ker_score_s::frags'

     Number of frags.  Note that depending on game rules, this can have
     very different meanings.

 -- Member of lw6ker_score_s: consolidated_percent
     *Type:* 'int'

     *Definition:* 'int lw6ker_score_s::consolidated_percent'

     OK, this is probably the most non-intuitive number but still the
     most usefull.  It will show a percentage that is greater as we
     estimate the team in a stronger position.  For instance, it can be
     higher if the team has very few fighters on the field but has a
     great number of frags.  The one who has the greatest number here is
     the winner.


File: liquidwar6.info,  Node: libldr,  Next: libmap,  Prev: libker,  Up: C API

5.30 libldr
===========

5.30.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/ldr/index.html>.

5.30.2 API
----------

 -- Function: int lw6ldr_body_read (lw6sys_context_t * SYS_CONTEXT,
          lw6map_body_t * BODY, const char * DIRNAME, lw6map_param_t *
          PARAM, const lw6ldr_hints_t * HINTS, int DISPLAY_W, int
          DISPLAY_H, float RATIO, int BENCH_VALUE, int MAGIC_NUMBER,
          lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     BODY: the body to read, must point to allocated memory

     DIRNAME: the directory of the map

     PARAM: map parameters

     HINTS: map hints

     DISPLAY_W: the display width

     DISPLAY_H: the display height

     RATIO: wished map ratio

     BENCH_VALUE: the bench value (depends on computer capacity)

     MAGIC_NUMBER: arbitrary constant

     PROGRESS: structure to transmit loading progress

     Reads the map body, that is, all the layers.

     *Return value:* 1 if OK, 0 if failed.

 -- Function: void lw6ldr_auto_colors (lw6sys_context_t * SYS_CONTEXT,
          lw6map_style_t * STYLE, const lw6ldr_hints_t * HINTS)
     STYLE: the style structure to process.

     HINTS: additionnal hints to know what to set automatically

     Deduces all colors from background color, if needed.  The function
     will check color_auto parameters and replace all other colors by
     base and alternate colors if needed.  Note that the background
     color itself is not changed by this function.  Background can only
     be guessed from texture.

     *Return value:* none.

 -- Function: int lw6ldr_cursor_texture_read (lw6sys_context_t *
          SYS_CONTEXT, lw6map_cursor_texture_t * CURSOR_TEXTURE, const
          char * DIRNAME)
     SYS_CONTEXT: global system context

     CURSOR_TEXTURE: the cursor texture (out param)

     DIRNAME: the directory we load the data form (map dir)

     Reads the cursor texture information, if not available, will use
     defaults

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6ldr_free_entry (lw6sys_context_t * SYS_CONTEXT,
          lw6ldr_entry_t * ENTRY)
     SYS_CONTEXT: global system context

     ENTRY: the entry to free

     Frees a map entry.

     *Return value:* none.

 -- Function: lw6ldr_entry_t * lw6ldr_dup_entry (lw6sys_context_t *
          SYS_CONTEXT, const lw6ldr_entry_t * ENTRY)
     SYS_CONTEXT: global system context

     ENTRY: the entry to dup

     Dup a map entry.

     *Return value:* newly allocated object.

 -- Function: lw6sys_list_t * lw6ldr_get_entries (lw6sys_context_t *
          SYS_CONTEXT, const char * MAP_PATH, const char *
          RELATIVE_PATH, const char * USER_DIR)
     SYS_CONTEXT: global system context

     MAP_PATH: the map_path environment config variable, delimited path
     list

     RELATIVE_PATH: the relative path to use to find the map directory

     USER_DIR: the user directory

     Lists all maps in a given directory.  Returns a list of
     lw6ldr_entry_t which can contain both directories with subdirs and
     actual maps.  Maps are sorted before being returned, first
     directories, then maps, sorted in alphabetical order.

     *Return value:* a list of dynamically allocated lw6ldr_entry_t.

 -- Function: void lw6ldr_for_all_entries (lw6sys_context_t *
          SYS_CONTEXT, const char * MAP_PATH, const char *
          RELATIVE_PATH, const char * USER_DIR, int RECURSIVE,
          lw6sys_list_callback_func_t CALLBACK_FUNC, void * FUNC_DATA)
     SYS_CONTEXT: global system context

     MAP_PATH: the map_path environment config variable, delimited path
     list

     RELATIVE_PATH: the relative path to use to find the map directory

     USER_DIR: the user directory

     RECURSIVE: if non-zero, map search will recurse in subdirs

     CALLBACK_FUNC: the function which will be called on each entry

     FUNC_DATA: an extra pointer to pass data to callback_func

     Executes a given function on all maps in a given place, typically
     used in test programs.

     *Return value:* none.

 -- Function: lw6ldr_entry_t * lw6ldr_chain_entry (lw6sys_context_t *
          SYS_CONTEXT, const char * MAP_PATH, const char *
          RELATIVE_PATH, const char * USER_DIR)
     SYS_CONTEXT: global system context

     MAP_PATH: the map_path environment config variable, delimited path
     list

     RELATIVE_PATH: the relative path to use to find the map directory

     USER_DIR: the user directory

     Gets the next entry used in test programs.

     *Return value:* none.

 -- Function: int lw6ldr_exp_validate (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_level_t * LEVEL, const char * USER_DIR)
     SYS_CONTEXT: global system context

     LEVEL: the level to validate

     USER_DIR: user directory

     Validates a level, acknowledges you've won it.  Upgrades exp.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6ldr_grease_apply (lw6sys_context_t * SYS_CONTEXT,
          lw6map_layer_t * LAYER, const lw6map_rules_t * RULES, const
          lw6ldr_hints_t * HINTS, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     LAYER: the layer on which to apply the grease

     RULES: map rules

     HINTS: map hints

     PROGRESS: structure to transmit loading progress

     Reads the map body, that is, all the layers.

     *Return value:* 1 if OK, 0 if failed.

 -- Function: void lw6ldr_hints_defaults (lw6sys_context_t *
          SYS_CONTEXT, lw6ldr_hints_t * HINTS)
     SYS_CONTEXT: global system context

     HINTS: data to initialize

     Set the hints struct to its defaults.

     *Return value:* none.

 -- Function: void lw6ldr_hints_zero (lw6sys_context_t * SYS_CONTEXT,
          lw6ldr_hints_t * HINTS)
     SYS_CONTEXT: global system context

     HINTS: data to initialize

     Zeros the hints struct, this is not the same as setting to
     defaults.

     *Return value:* none.

 -- Function: void lw6ldr_hints_clear (lw6sys_context_t * SYS_CONTEXT,
          lw6ldr_hints_t * HINTS)
     SYS_CONTEXT: global system context

     HINTS: data to initialize

     Clears the hints struct, this is not the same as setting to
     defaults.

     *Return value:* none.

 -- Function: int lw6ldr_hints_read (lw6sys_context_t * SYS_CONTEXT,
          lw6ldr_hints_t * HINTS, const char * DIRNAME)
     SYS_CONTEXT: global system context

     DIRNAME: the directory of the map

     Read the hints (hints.xml) of a map.  Pointer to hints must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:* 1 if success, 0 if failed.

 -- Function: int lw6ldr_hints_set (lw6sys_context_t * SYS_CONTEXT,
          lw6ldr_hints_t * HINTS, const char * KEY, const char * VALUE)
     SYS_CONTEXT: global system context

     HINTS: the hints to modify

     KEY: the key to modify

     VALUE: the value to affect to the key, as a string

     Sets one single parameter in a hints structure.  Value must always
     be passed as a string, will be converted to the right type
     automatically when storing it in the structure.

     *Return value:* 1 if success, 0 if failed.  Note that while 0
     really means there's a problem, some affectations can fail and
     return 1, needs to be worked on.

 -- Function: char * lw6ldr_hints_get (lw6sys_context_t * SYS_CONTEXT,
          const lw6ldr_hints_t * HINTS, const char * KEY)
     SYS_CONTEXT: global system context

     HINTS: the hints to modify

     KEY: the key to modify

     Gets one single parameter in a hints structure.  Value is converted
     as a string.

     *Return value:* dynamically allocated string, NULL on error.

 -- Function: char * lw6ldr_hints_get_default (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY)
     SYS_CONTEXT: global system context

     KEY: the key we want informations about.

     Gets the default value for a given hints key.

     *Return value:* dynamically allocated string, NULL on error.

 -- Function: int lw6ldr_hints_update (lw6sys_context_t * SYS_CONTEXT,
          lw6ldr_hints_t * HINTS, lw6sys_assoc_t * VALUES)
     SYS_CONTEXT: global system context

     HINTS: the hints struct to fill with values (read/write parameter)

     VALUES: an assoc containing strings with the new values

     Overrides hints with values.  Pointer to hints must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values.  Not all parameters need be defined in
     values.  It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing hints.

     *Return value:* 1 if success, 0 if failed.

 -- Function: int lw6ldr_layer_read_first (lw6sys_context_t *
          SYS_CONTEXT, lw6map_layer_t * LAYER, const char * FILENAME,
          lw6map_param_t * PARAM, const lw6ldr_hints_t * HINTS, int
          DISPLAY_W, int DISPLAY_H, float TARGET_RATIO, int BENCH_VALUE,
          int MAGIC_NUMBER, int EXPECTED_DEPTH, lw6sys_progress_t *
          PROGRESS)
     SYS_CONTEXT: global system context

     LAYER: layer to update (out param)

     FILENAME: name of PNG file

     PARAM: parameters of the map

     HINTS: hints of the map

     DISPLAY_W: width of display

     DISPLAY_H: height of display

     TARGET_RATIO: width/height ratio we want

     BENCH_VALUE: bench for this computer

     MAGIC_NUMBER: arbitrary constant

     EXPECTED_DEPTH: depth of map according to files available

     PROGRESS: progress object to provide feedback (in/out)

     Reads the first layer, that is map.png.  This function has many
     parameters since it will try and guess the final (real) resolution
     of the map.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6ldr_layer_read_next (lw6sys_context_t *
          SYS_CONTEXT, lw6map_layer_t * LAYER, const char * FILENAME,
          int TARGET_W, int TARGET_H)
     SYS_CONTEXT: global system context

     LAYER: layer to update (out param)

     FILENAME: name of PNG file

     TARGET_W: width we want

     TARGET_H: height we want

     Reads a layer, knowing the exact size we want.  This is typically
     to load layer2-7.png once map.png has been loaded.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6ldr_metadata_read (lw6sys_context_t * SYS_CONTEXT,
          lw6map_metadata_t * METADATA, const char * DIRNAME)
     SYS_CONTEXT: global system context

     METADATA: structure containting read data (out param)

     DIRNAME: map dirname (absolute path)

     Reads the metadata, will first parse metadata.xml, and if not
     available read README and guess a title from map path.  When
     function returns, all fields in structure are non-NULL.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6ldr_meta_layer_read (lw6sys_context_t *
          SYS_CONTEXT, lw6map_meta_layer_t * META_LAYER, const char *
          FILENAME, int TARGET_W, int TARGET_H, int ANALOG)
     SYS_CONTEXT: global system context

     META_LAYER: the meta layer to read

     FILENAME: the file to open

     TARGET_W: the wanted width

     TARGET_H: the wanted height

     ANALOG: wether to use analog info (0-255) or boolean (0-1)

     Reads a meta-layer from the disj, resampling is done according to
     the given parameters.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6ldr_meta_layer_read_if_exists (lw6sys_context_t *
          SYS_CONTEXT, lw6map_meta_layer_t * META_LAYER, const char *
          DIRNAME, const char * FILE_ONLY, int TARGET_W, int TARGET_H,
          int ANALOG)
     SYS_CONTEXT: global system context

     META_LAYER: the meta layer to read

     DIRNAME: the map directory

     FILE_ONLY: the meta-layer file name only (without the path)

     TARGET_W: the wanted width

     TARGET_H: the wanted height

     ANALOG: wether to use analog info (0-255) or boolean (0-1)

     Reads a meta-layer from the disj, resampling is done according to
     the given parameters.  This function is different from
     'lw6ldr_meta_layer_read' for it will 1) concatenate 'dirname' and
     'file_only' and 2) return OK (1) if file does not exist.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6ldr_process_non_run_options (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV, int * RUN_GAME)
     SYS_CONTEXT: global system context

     ARGC: the number of command-line args, as passed to main

     ARGV: an array of strings containing command-line args, as passed
     to main

     RUN_GAME: a pointer to a boolean which will contain true (1) if the
     game must be launched, or false (0) if the option is such that game
     must be skipped.  Example: -copyright, -help, ...

     Will interpret the command-line arguments, and trap those who are
     related to xml files, this is usefull when building the game, we
     want to have an extra binary to do this without being linked to
     SDL, for instance.

     *Return value:* non-zero if success, 0 if error.  The error can be,
     for instance, the test suite returning "no, tests were not OK".

 -- Function: int lw6ldr_param_read (lw6sys_context_t * SYS_CONTEXT,
          lw6map_param_t * PARAM, const char * DIRNAME)
     SYS_CONTEXT: global system context

     PARAM: the parameter struct to fill with values (read/write
     parameter)

     DIRNAME: the directory of the map

     Read the parameters associated to a map.  Pointer to param must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:* 1 if success, 0 if failed.

 -- Function: int lw6ldr_param_update (lw6sys_context_t * SYS_CONTEXT,
          lw6map_param_t * PARAM, lw6sys_assoc_t * VALUES)
     SYS_CONTEXT: global system context

     PARAM: the parameter struct to fill with values (read/write
     parameter)

     VALUES: an assoc containing strings with the new values

     Overrides param with values.  Pointer to param must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values.  Not all parameters need be defined in
     values.  It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing param.

     *Return value:* 1 if success, 0 if failed.

 -- Function: void lw6ldr_print_example_rules_xml (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: file to output content to

     Print to a file a typical map rules.xml file.

     *Return value:* none.

 -- Function: void lw6ldr_print_example_hints_xml (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: file to output content to

     Print to a file a typical map hints.xml file.

     *Return value:* none.

 -- Function: void lw6ldr_print_example_style_xml (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: file to output content to

     Print to a file a typical map style.xml file.

     *Return value:* none.

 -- Function: void lw6ldr_print_example_teams_xml (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: file to output content to

     Print to a file a typical map teams.xml file.

     *Return value:* none.

 -- Function: int lw6ldr_print_examples (lw6sys_context_t * SYS_CONTEXT,
          char * USER_DIR)
     SYS_CONTEXT: global system context

     USER_DIR: the user directory or at least, a writable one

     Writes all example XML files in 'user_dir/example/', will create
     the directory if needed.

     *Return value:* 1 if success, 0 if failed.

 -- Function: lw6map_level_t * lw6ldr_read (lw6sys_context_t *
          SYS_CONTEXT, const char * DIRNAME, lw6sys_assoc_t *
          DEFAULT_PARAM, lw6sys_assoc_t * FORCED_PARAM, int DISPLAY_W,
          int DISPLAY_H, int BENCH_VALUE, int MAGIC_NUMBER, const char *
          USER_DIR, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     DIRNAME: the directory containing the map

     DEFAULT_PARAM: default parameters, as strings

     FORCED_PARAM: forced parameters, as strings

     DISPLAY_W: the width of the display output (resolution)

     DISPLAY_H: the height of the display output (resolution)

     BENCH_VALUE: the bench value (depends on computer capacity)

     MAGIC_NUMBER: arbitrary constant

     USER_DIR: the user directory

     PROGRESS: information used to handle the progress bar

     Loads a map from dist.  The default_param and forced_param can
     contain values corresponding to rules.xml and style.xml entries.
     Parameters are read in 4 steps.  1st, a default value is picked by
     the program.  2nd, any value in 'default_param' replaces previous
     values.  3rd, any value in rules.xml or style.xml replaces previous
     values.  4th, any value in 'forced_param' replaces previous values.
     In practice, the 'default_param' allows the user to set defaults
     which can still be overwritten by the map, while 'forced_param' is
     a definitive 'ignore what is is defined in the map' way of doing
     things.  See also 'lw6ldr_read_relative'.

     *Return value:* 1 if success, 0 if failed.

 -- Function: lw6map_level_t * lw6ldr_read_relative (lw6sys_context_t *
          SYS_CONTEXT, const char * MAP_PATH, const char *
          RELATIVE_PATH, lw6sys_assoc_t * DEFAULT_PARAM, lw6sys_assoc_t
          * FORCED_PARAM, int DISPLAY_W, int DISPLAY_H, int BENCH_VALUE,
          int MAGIC_NUMBER, const char * USER_DIR, lw6sys_progress_t *
          PROGRESS)
     SYS_CONTEXT: global system context

     MAP_PATH: a collection of paths where to find maps

     RELATIVE_PATH: something which will be appended to a 'map_path'
     member

     DEFAULT_PARAM: default parameters, as strings

     FORCED_PARAM: forced parameters, as strings

     DISPLAY_W: the width of the display output (resolution)

     DISPLAY_H: the height of the display output (resolution)

     BENCH_VALUE: the bench value (depends on computer capacity)

     MAGIC_NUMBER: arbitrary constant

     USER_DIR: the user directory

     PROGRESS: information used to handle the progress bar

     Reads a map from disk, using the map-path value, which is a
     collection of paths defined by the command-line, the environment
     variables, and the config file.  'default_param' and 'forced_param'
     work as in the function 'lw6ldr_read'.

     *Return value:* 1 if success, 0 if failure.

 -- Function: void lw6ldr_resampler_init (lw6sys_context_t *
          SYS_CONTEXT, lw6ldr_resampler_t * RESAMPLER, lw6map_param_t *
          PARAM, const lw6ldr_hints_t * HINTS, int SOURCE_W, int
          SOURCE_H, int DISPLAY_W, int DISPLAY_H, float TARGET_RATIO,
          int BENCH_VALUE, int MAGIC_NUMBER, int EXPECTED_DEPTH, float
          GRAY_LEVEL)
     SYS_CONTEXT: global system context

     RESAMPLER: resampler object to init

     PARAM: map parameters to use

     HINTS: loading hints

     SOURCE_W: width of source map

     SOURCE_H: height of source map

     DISPLAY_W: width of source display

     DISPLAY_H: height of source display

     TARGET_RATIO: ratio, that is width/height of the target

     BENCH_VALUE: rough estimation of this computer power

     MAGIC_NUMBER: arbitrary constant, needed to calibrate speed

     EXPECTED_DEPTH: how thick the map could be (in practice, looks like
     d in whd)

     GRAY_LEVEL: used to estimate capacity, 1.0f is white and means many
     slots

     Initializes a resampler.  There is wizardry based on the bench,
     magic number map size, gray level.  This is bot bullet proof, but
     has been experience driven and is the result of many tries /
     failures and hopefully successes.  Might need tuning as the
     algorithm evolves.  This is the very function that chooses the
     actual logical map size.

     *Return value:* none.

 -- Function: void lw6ldr_resampler_use_for_gen (lw6sys_context_t *
          SYS_CONTEXT, int * MAP_W, int * MAP_H, int DISPLAY_W, int
          DISPLAY_H, int BENCH_VALUE, int MAGIC_NUMBER)
     SYS_CONTEXT: global system context

     MAP_W: target map width (out param)

     MAP_H: target map height (out param)

     DISPLAY_W: screen width (pixels)

     DISPLAY_H: screen height (pixels)

     BENCH_VALUE: rough estimation of this computer power

     MAGIC_NUMBER: arbitrary constant, needed to calibrate speed

     Builds a resampler and does all the calculus so that one gets the
     correct map width and height for the gen module.  The idea is that
     when generating a pseudo-random map, one can not really know what
     size to give it, so this function gives a hint, relying on bench
     and magic values, which are computer/runtime dependant.

     *Return value:* none

 -- Function: void lw6ldr_resampler_force (lw6sys_context_t *
          SYS_CONTEXT, lw6ldr_resampler_t * RESAMPLER, int SOURCE_W, int
          SOURCE_H, int TARGET_W, int TARGET_H)
     SYS_CONTEXT: global system context

     RESAMPLER: resampler to set

     SOURCE_W: source map width

     SOURCE_H: source map height

     TARGET_W: target map width

     TARGET_H: target map height

     Initializes a resampler with hardcoded values, does not calibrate
     according to context, simply set it to rescale the size you want.

     *Return value:* none.

 -- Function: void lw6ldr_resampler_source2target (lw6sys_context_t *
          SYS_CONTEXT, const lw6ldr_resampler_t * RESAMPLER, int *
          TARGET_X, int * TARGET_Y, int SOURCE_X, int SOURCE_Y)
     SYS_CONTEXT: global system context

     TARGET_X: target x coordinate (out param)

     TARGET_Y: target y coordinate (out param)

     SOURCE_X: source x coordinate (in param)

     SOURCE_Y: source y coordinate (in param)

     Transforms from source coordinate to target coordinates.  Does
     rounding fine-tuning, it's not a simple integer division.

     *Return value:* none.

 -- Function: void lw6ldr_resampler_target2source (lw6sys_context_t *
          SYS_CONTEXT, const lw6ldr_resampler_t * RESAMPLER, int *
          SOURCE_X, int * SOURCE_Y, int TARGET_X, int TARGET_Y)
     SYS_CONTEXT: global system context

     SOURCE_X: source x coordinate (out param)

     SOURCE_Y: source y coordinate (out param)

     TARGET_X: target x coordinate (in param)

     TARGET_Y: target y coordinate (in param)

     Transforms from target coordinate to source coordinates.  Yes,
     target to source.  Target is our final logical map, source is what
     we loaded from disk, here we want to know, given a point in the
     target, where to fetch its data from source.  Does rounding
     fine-tuning, it's not a simple integer division.

     *Return value:* none.

 -- Function: int lw6ldr_rules_read (lw6sys_context_t * SYS_CONTEXT,
          lw6map_rules_t * RULES, const char * DIRNAME)
     SYS_CONTEXT: global system context

     DIRNAME: the directory of the map

     Read the rules (rules.xml) of a map.  Pointer to rules must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:* 1 if success, 0 if failed.

 -- Function: int lw6ldr_rules_update (lw6sys_context_t * SYS_CONTEXT,
          lw6map_rules_t * RULES, lw6sys_assoc_t * VALUES)
     SYS_CONTEXT: global system context

     RULES: the rules struct to fill with values (read/write parameter)

     VALUES: an assoc containing strings with the new values

     Overrides rules with values.  Pointer to rules must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values.  Not all parameters need be defined in
     values.  It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing rules.

     *Return value:* 1 if success, 0 if failed.

 -- Function: int lw6ldr_style_read (lw6sys_context_t * SYS_CONTEXT,
          lw6map_style_t * STYLE, const char * DIRNAME)
     SYS_CONTEXT: global system context

     DIRNAME: the directory of the map

     Read the style (style.xml) of a map.  Pointer to style must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:* 1 if success, 0 if failed.

 -- Function: int lw6ldr_style_set (lw6sys_context_t * SYS_CONTEXT,
          lw6map_style_t * STYLE, const char * KEY, const char * VALUE)
     SYS_CONTEXT: global system context

     STYLE: the style to modify

     KEY: the key to modify

     VALUE: the value to affect to the key, as a string

     Sets one single parameter in a style structure.  Value must always
     be passed as a string, will be converted to the right type
     automatically when storing it in the structure.

     *Return value:* 1 if success, 0 if failed.  Note that while 0
     really means there's a problem, some affectations can fail and
     return 1, needs to be worked on.

 -- Function: int lw6ldr_style_update (lw6sys_context_t * SYS_CONTEXT,
          lw6map_style_t * STYLE, lw6sys_assoc_t * VALUES)
     SYS_CONTEXT: global system context

     STYLE: the style struct to fill with values (read/write parameter)

     VALUES: an assoc containing strings with the new values

     Overrides style with values.  Pointer to style must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values.  Not all parameters need be defined in
     values.  It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing style.

     *Return value:* 1 if success, 0 if failed.

 -- Function: int lw6ldr_teams_read (lw6sys_context_t * SYS_CONTEXT,
          lw6map_teams_t * TEAMS, const char * DIRNAME)
     SYS_CONTEXT: global system context

     DIRNAME: the directory of the map

     Read the teams (teams.xml) of a map.  Pointer to teams must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:* 1 if success, 0 if failed.

 -- Function: int lw6ldr_teams_update (lw6sys_context_t * SYS_CONTEXT,
          lw6map_teams_t * TEAMS, lw6sys_assoc_t * VALUES)
     SYS_CONTEXT: global system context

     TEAMS: the teams struct to fill with values (read/write parameter)

     VALUES: an assoc containing strings with the new values

     Overrides teams with values.  Pointer to teams must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values.  Not all parameters need be defined in
     values.  It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing teams.

     *Return value:* 1 if success, 0 if failed.

 -- Function: int lw6ldr_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libldr module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6ldr_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'ldr' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6ldr_texture_read (lw6sys_context_t * SYS_CONTEXT,
          lw6map_texture_t * TEXTURE, const char * DIRNAME, const
          lw6map_param_t * PARAM, const lw6ldr_hints_t * HINTS, int
          USE_TEXTURE, int DISPLAY_W, int DISPLAY_H, float * RATIO, int
          * TEXTURE_EXISTS, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     TEXTURE: structure to hold read data

     DIRNAME: map dirname (absolute path)

     PARAM: parameters to use

     HINTS: loading hints to use

     USE_TEXTURE: wether to use texture.png

     DISPLAY_W: display width

     DISPLAY_H: display height

     RATIO: target width/height factor (out param)

     TEXTURE_EXISTS: true if texture.png is here (out param)

     PROGRESS: progress indicator (in/out param)

     Read the texture associated to a map.  Pointer to texture must be
     valid, it's modified in-place.  The function will automatically
     figure out if texture.png exists or if we must use
     foreground.png/background.png.

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6ldr_use_defaults (lw6sys_context_t * SYS_CONTEXT,
          lw6ldr_use_t * USE)
     SYS_CONTEXT: global system context

     USE: struct to initialize

     Sets the use structure to its defaults, this structure being used
     to now wether we should use texture, cursor textures, rules, hints,
     style, teams and music.

     *Return value:* none.

 -- Function: void lw6ldr_use_clear (lw6sys_context_t * SYS_CONTEXT,
          lw6ldr_use_t * USE)
     SYS_CONTEXT: global system context

     USE: struct to clear

     Clears the use structure, set it to the use nothing mode.

     *Return value:* none.

 -- Function: int lw6ldr_use_set (lw6sys_context_t * SYS_CONTEXT,
          lw6ldr_use_t * USE, const char * KEY, const char * VALUE)
     SYS_CONTEXT: global system context

     USE: struct to modify

     KEY: key to change (as a string)

     VALUE: value to set (as a string)

     Sets a key to the given value, OK all fields are integer, this is
     just a convenient function to be called in more general functions
     which are fed with those string pointers, typically coming from an
     XML file.

     *Return value:* 1 on success, 0 on failure (key not found).

 -- Function: int lw6ldr_use_update (lw6sys_context_t * SYS_CONTEXT,
          lw6ldr_use_t * USE, lw6sys_assoc_t * VALUES)
     SYS_CONTEXT: global system context

     USE: the use struct to fill with values (read/write parameter)

     VALUES: an assoc containing strings with the new values

     Overrides use with values.  Pointer to use must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values.  Not all parameters need be defined in
     values.  It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing use.

     *Return value:* 1 if success, 0 if failed.

 -- Struct: lw6ldr_entry_s

     Contains informations about a map, but just the minimum to, for
     instance, display it in a menu entry.

 -- Member of lw6ldr_entry_s: metadata
     *Type:* 'lw6map_metadata_t'

     *Definition:* 'lw6map_metadata_t lw6ldr_entry_s::metadata'

     The map metadata.

 -- Member of lw6ldr_entry_s: absolute_path
     *Type:* 'char *'

     *Definition:* 'char* lw6ldr_entry_s::absolute_path'

     The map absolute path, use this to load it.

 -- Member of lw6ldr_entry_s: relative_path
     *Type:* 'char *'

     *Definition:* 'char* lw6ldr_entry_s::relative_path'

     The map relative path, store this in config file.

 -- Member of lw6ldr_entry_s: has_subdirs
     *Type:* 'int'

     *Definition:* 'int lw6ldr_entry_s::has_subdirs'

     Wether the entry has subdirs (and consequently, isn't a map)

 -- Member of lw6ldr_entry_s: nb_submaps
     *Type:* 'int'

     *Definition:* 'int lw6ldr_entry_s::nb_submaps'

     Number of sub mpas within this map.

 -- Member of lw6ldr_entry_s: forbidden
     *Type:* 'int'

     *Definition:* 'int lw6ldr_entry_s::forbidden'

     Wether it is forbidden (eg, not enough exp).

 -- Struct: lw6ldr_hints_s

     Content of hints.xml stored into a C struct.

 -- Member of lw6ldr_hints_s: resample
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::resample'

     Wether to resample the map on the fly when loaded.

 -- Member of lw6ldr_hints_s: min_map_width
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::min_map_width'

     Minimum map width.

 -- Member of lw6ldr_hints_s: max_map_width
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::max_map_width'

     Maximum map width.

 -- Member of lw6ldr_hints_s: min_map_height
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::min_map_height'

     Minimum map height.

 -- Member of lw6ldr_hints_s: max_map_height
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::max_map_height'

     Maximum map height.

 -- Member of lw6ldr_hints_s: min_map_surface
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::min_map_surface'

     Minimum map surface.

 -- Member of lw6ldr_hints_s: max_map_surface
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::max_map_surface'

     Maximum map surface.

 -- Member of lw6ldr_hints_s: fighter_scale
     *Type:* 'float'

     *Definition:* 'float lw6ldr_hints_s::fighter_scale'

     Use greater or smaller fighters.

 -- Member of lw6ldr_hints_s: downsize_using_fighter_scale
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::downsize_using_fighter_scale'

     Wether to downsize the map, if needed, using fighter scale.

 -- Member of lw6ldr_hints_s: upsize_using_fighter_scale
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::upsize_using_fighter_scale'

     Wether to upsize the map, if needed, using fighter scale.

 -- Member of lw6ldr_hints_s: downsize_using_bench_value
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::downsize_using_bench_value'

     Wether to downsize the map, if needed, using bench value.

 -- Member of lw6ldr_hints_s: upsize_using_bench_value
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::upsize_using_bench_value'

     Wether to upsize the map, if needed, using bench value.

 -- Member of lw6ldr_hints_s: guess_colors
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::guess_colors'

     Wether to guess colors from the map.

 -- Member of lw6ldr_hints_s: background_color_auto
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::background_color_auto'

     Wether to set up background colors automatically.

 -- Member of lw6ldr_hints_s: hud_color_auto
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::hud_color_auto'

     Wether to set up hud colors automatically.

 -- Member of lw6ldr_hints_s: menu_color_auto
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::menu_color_auto'

     Wether to set up menu colors automatically.

 -- Member of lw6ldr_hints_s: view_color_auto
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::view_color_auto'

     Wether to set up view colors automatically.

 -- Member of lw6ldr_hints_s: system_color_auto
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::system_color_auto'

     Wether to set up system colors automatically.

 -- Member of lw6ldr_hints_s: wall_grease
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::wall_grease'

     Wall grease used when rescaling.

 -- Member of lw6ldr_hints_s: guess_moves_per_sec
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::guess_moves_per_sec'

     Guess the moves per sec value automatically.

 -- Member of lw6ldr_hints_s: speed
     *Type:* 'float'

     *Definition:* 'float lw6ldr_hints_s::speed'

     Global speed.

 -- Struct: lw6ldr_resampler_s

     Almost internal struct use to handler the resampling process.  It
     has informations about the source, the target, and the ratio
     between them.  It basically contains informations about how to
     scale.

 -- Member of lw6ldr_resampler_s: target_w
     *Type:* 'int'

     *Definition:* 'int lw6ldr_resampler_s::target_w'

     Target width.

 -- Member of lw6ldr_resampler_s: target_h
     *Type:* 'int'

     *Definition:* 'int lw6ldr_resampler_s::target_h'

     Target height.

 -- Member of lw6ldr_resampler_s: source_w
     *Type:* 'int'

     *Definition:* 'int lw6ldr_resampler_s::source_w'

     Source width.

 -- Member of lw6ldr_resampler_s: source_h
     *Type:* 'int'

     *Definition:* 'int lw6ldr_resampler_s::source_h'

     Source height.

 -- Member of lw6ldr_resampler_s: scale_x
     *Type:* 'float'

     *Definition:* 'float lw6ldr_resampler_s::scale_x'

     Ratio for the X axis (target_w/source_w).

 -- Member of lw6ldr_resampler_s: scale_y
     *Type:* 'float'

     *Definition:* 'float lw6ldr_resampler_s::scale_y'

     Ratio for the Y axis (target_h/source_h).

 -- Struct: lw6ldr_use_s

     What files to use when loading a map.

 -- Member of lw6ldr_use_s: use_texture
     *Type:* 'int'

     *Definition:* 'int lw6ldr_use_s::use_texture'

     Wether to use texture.jpeg.

 -- Member of lw6ldr_use_s: use_cursor_texture
     *Type:* 'int'

     *Definition:* 'int lw6ldr_use_s::use_cursor_texture'

     Wether to use cursor-texture.jpeg.

 -- Member of lw6ldr_use_s: use_rules_xml
     *Type:* 'int'

     *Definition:* 'int lw6ldr_use_s::use_rules_xml'

     Wether to use rules.xml.

 -- Member of lw6ldr_use_s: use_hints_xml
     *Type:* 'int'

     *Definition:* 'int lw6ldr_use_s::use_hints_xml'

     Wether to use hints.xml.

 -- Member of lw6ldr_use_s: use_style_xml
     *Type:* 'int'

     *Definition:* 'int lw6ldr_use_s::use_style_xml'

     Wether to use style.xml.

 -- Member of lw6ldr_use_s: use_teams_xml
     *Type:* 'int'

     *Definition:* 'int lw6ldr_use_s::use_teams_xml'

     Wether to use teams.xml.

 -- Member of lw6ldr_use_s: use_music_file
     *Type:* 'int'

     *Definition:* 'int lw6ldr_use_s::use_music_file'

     Wether to use the map specific music file.


File: liquidwar6.info,  Node: libmap,  Next: libmat,  Prev: libldr,  Up: C API

5.31 libmap
===========

5.31.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/map/index.html>.

5.31.2 API
----------

 -- Function: void lw6map_body_builtin_custom (lw6sys_context_t *
          SYS_CONTEXT, lw6map_body_t * BODY, int W, int H, int D, int
          NOISE_PERCENT, const lw6map_rules_t * RULES)
     SYS_CONTEXT: global system context

     BODY: the body to initialize

     W: the width

     H: the height

     D: the depth

     NOISE_PERCENT: the noise level to fill meta layers with

     RULES: the map rules

     Sets up a default body structure.

     *Return value:* none

 -- Function: void lw6map_body_clear (lw6sys_context_t * SYS_CONTEXT,
          lw6map_body_t * BODY)
     SYS_CONTEXT: global system context

     BODY: the structure to clear

     Clears a body structure.

     *Return value:* none.

 -- Function: void lw6map_body_fix_checksum (lw6sys_context_t *
          SYS_CONTEXT, lw6map_body_t * BODY)
     SYS_CONTEXT: global system context

     BODY: the structure to update

     Updates (calculates) the checksum of a map body structure.

     *Return value:* none.

 -- Function: int lw6map_body_check_and_fix_holes (lw6sys_context_t *
          SYS_CONTEXT, lw6map_body_t * BODY, const lw6map_rules_t *
          RULES)
     SYS_CONTEXT: global system context

     BODY: the structure to update

     RULES: the game rules

     This (fundamental) function ensures that all playable areas in a
     map are connected.  If isolated zones are found out, then they are
     marked as walls and not used any more.

     *Return value:* none.

 -- Function: int lw6map_body_coord_from_texture (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_level_t * LEVEL, int * BODY_X, int *
          BODY_Y, int TEXTURE_X, int TEXTURE_Y)
     SYS_CONTEXT: global system context

     LEVEL: the level to work on

     BODY_X: the body (logical) x coord

     BODY_Y: the body (logical) y coord

     TEXTURE_X: the texture x coord

     TEXTURE_Y: the texture y coord

     Gets body (logical) coords from texture position.

     *Return value:* 1 on success, 0 on failure (out of bounds)

 -- Function: u_int8_t lw6map_body_get_with_texture_coord
          (lw6sys_context_t * SYS_CONTEXT, const lw6map_level_t * LEVEL,
          int TEXTURE_X, int TEXTURE_Y, int Z)
     SYS_CONTEXT: global system context

     LEVEL: the level to work on

     TEXTURE_X: the texture x coord

     TEXTURE_Y: the texture y coord

     Z: the z position (depth related)

     Tells wether a given map position is free or not, but using texture
     coords.

     *Return value:* 1 if position is playable, 0 if not (wall)

 -- Function: void lw6map_color_invert (lw6sys_context_t * SYS_CONTEXT,
          lw6map_color_couple_t * COLOR)
     SYS_CONTEXT: global system context

     COLOR: the color to invert

     Inverts a color couple, that is, replace fg by bg and vice-versa.

     *Return value:* none.

 -- Function: int lw6map_color_is_same (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_color_couple_t * COLOR1, const
          lw6map_color_couple_t * COLOR2)
     SYS_CONTEXT: global system context

     COLOR1: 1st color to compare

     COLOR2: 2nd color to compare

     Compares two colors.

     *Return value:* 1 if equal, 0 if not.

 -- Function: char * lw6map_team_color_index_to_key (lw6sys_context_t *
          SYS_CONTEXT, int INDEX)
     SYS_CONTEXT: global system context

     INDEX: index of the color between 0 & 9

     Transforms a team color index into its readable string form, which
     can be used in config files for instance.

     *Return value:* a string, must *not* be freed.

 -- Function: int lw6map_team_color_key_to_index (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY)
     SYS_CONTEXT: global system context

     KEY: key of the color, for instance "red"

     The index of the color, between 0 & 9

     *Return value:* an integer.

 -- Function: char * lw6map_team_color_index_to_label (lw6sys_context_t
          * SYS_CONTEXT, int INDEX)
     SYS_CONTEXT: global system context

     INDEX: index of the color between 0 & 9

     Transforms a team color index into its readable string form, which
     can be used to display information to players.

     *Return value:* a string, must *not* be freed.

 -- Function: void lw6map_coords_fix_xy (const lw6map_rules_t * RULES,
          const lw6sys_whd_t * SHAPE, int * X, int * Y)
     RULES: set of rules to use

     SHAPE: shape of the map

     X: x coord (in/out param)

     Y: y coord (in/out param)

     Fixes the x and y values so that it's always inside the map.  This
     function will read the rules and if there's some polarity enable,
     will do the right thing, for instance, a fighter too much on the
     right might reapper on the left side of the map.

     *Return value:* none.

 -- Function: void lw6map_coords_fix_z (const lw6map_rules_t * RULES,
          const lw6sys_whd_t * SHAPE, int * Z)
     RULES: set of rules to use

     SHAPE: shape of the map

     Z: z coord (in/out param)

     Fixes the z value so that it's always inside the map.  This
     function will read the rules and if there's some polarity enable,
     will do the right thing, for instance, a fighter too low it might
     reapper on top.

     *Return value:* none.

 -- Function: void lw6map_cursor_texture_clear (lw6sys_context_t *
          SYS_CONTEXT, lw6map_cursor_texture_t * CURSOR_TEXTURE)
     SYS_CONTEXT: global system context

     CURSOR_TEXTURE: the cursor texture to clear

     Clears a cursor texture (set it all transparent).

     *Return value:* none

 -- Function: void lw6map_cursor_texture_builtin (lw6sys_context_t *
          SYS_CONTEXT, lw6map_cursor_texture_t * CURSOR_TEXTURE)
     SYS_CONTEXT: global system context

     CURSOR_TEXTURE: the cursor texture to clear

     Sets a cursor texture to the builtin defauts, that is a circle that
     is black on the outside and gets white/transparent in the middle.

     *Return value:* none

 -- Function: void lw6map_cursor_texture_layer_set (lw6sys_context_t *
          SYS_CONTEXT, lw6map_cursor_texture_layer_t *
          CURSOR_TEXTURE_LAYER, int X, int Y, lw6sys_color_8_t COLOR)
     SYS_CONTEXT: global system context

     CURSOR_TEXTURE_LAYER: the cursor texture_layer to change

     X: x coord

     Y: y coord

     COLOR: the color

     Sets a pixel in the cursor texture_layer.

     *Return value:* none

 -- Function: lw6sys_color_8_t lw6map_cursor_texture_layer_get
          (lw6sys_context_t * SYS_CONTEXT, const
          lw6map_cursor_texture_layer_t * CURSOR_TEXTURE_LAYER, int X,
          int Y)
     SYS_CONTEXT: global system context

     CURSOR_TEXTURE_LAYER: the cursor texture_layer to query

     X: x coord

     Y: y coord

     Gets a pixel in the cursor texture_layer.

     *Return value:* the color

 -- Function: lw6map_level_t * lw6map_dup (lw6sys_context_t *
          SYS_CONTEXT, lw6map_level_t * SOURCE, lw6sys_progress_t *
          PROGRESS)
     SYS_CONTEXT: global system context

     SOURCE: the map to copy

     PROGRESS: to show advancement

     Performs a deep copy of the map, all elements are newly allocated
     and source can safely be destroyed after it's been duplicated.

     *Return value:* a newly allocated map, may be NULL.

 -- Function: int lw6map_exp_get_highest_team_color_allowed
          (lw6sys_context_t * SYS_CONTEXT, int EXP)
     SYS_CONTEXT: global system context

     EXP: the player experience

     Gets the highest color available for a given exp.

     *Return value:* a color id

 -- Function: int lw6map_exp_get_highest_weapon_allowed
          (lw6sys_context_t * SYS_CONTEXT, int EXP)
     SYS_CONTEXT: global system context

     EXP: the player experience

     Gets the highest weapon available for a given exp.

     *Return value:* a weapon id

 -- Function: int lw6map_exp_is_team_color_allowed (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_rules_t * RULES, int TEAM_COLOR_ID)
     SYS_CONTEXT: global system context

     RULES: set of rules to use

     TEAM_COLOR_ID: color id to test

     Tests wether a team color is allowed for a given set of rules.

     *Return value:* 1 if allowed, 0 if not.

 -- Function: int lw6map_exp_is_weapon_allowed (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_rules_t * RULES, int WEAPON_ID)
     SYS_CONTEXT: global system context

     RULES: set of rules to use

     WEAPON_ID: weapon id to test

     Tests wether a weapon is allowed for a given set of rules.

     *Return value:* 1 if allowed, 0 if not.

 -- Function: int lw6map_exp_get_unlocked_team_color (lw6sys_context_t *
          SYS_CONTEXT, int EXP)
     SYS_CONTEXT: global system context

     EXP: exp to test

     Get the unlocked team color for a given exp, if applyable.

     *Return value:* -1 if nothing unlocked, else the team color

 -- Function: int lw6map_exp_get_unlocked_weapon (lw6sys_context_t *
          SYS_CONTEXT, int EXP)
     SYS_CONTEXT: global system context

     EXP: exp to test

     Get the unlocked primary weapon for a given exp, if applyable.

     *Return value:* -1 if nothing unlocked, else the weapon id

 -- Function: char * lw6map_to_hexa (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_level_t * LEVEL)
     SYS_CONTEXT: global system context

     Converts a map to something that is later readable by
     'lw6map_from_hexa' to reproduce the exact same map.  Just a
     serializer.

     *Return value:* a newly allocated pointer, NULL if conversion
     failed.

 -- Function: lw6map_level_t * lw6map_from_hexa (lw6sys_context_t *
          SYS_CONTEXT, const char * HEXA)
     SYS_CONTEXT: global system context

     HEXA: an hexadecimal ASCII string, created by 'lw6map_to_hexa'

     Constructs a map from an hexadecimal string generated by
     'lw6map_to_hexa'.  Just an un-serializer.

     *Return value:* a new map, might be NULL if string isn't correct.

 -- Function: void lw6map_layer_builtin_custom (lw6sys_context_t *
          SYS_CONTEXT, lw6map_layer_t * LAYER, int W, int H)
     SYS_CONTEXT: global system context

     LAYER: the layer to init

     W: width

     H: height

     Creates a default layer.  This is mostly for testing purposes, the
     default layer is not empty, it contains a simplified map of the
     world.

     *Return value:* none

 -- Function: void lw6map_layer_clear (lw6sys_context_t * SYS_CONTEXT,
          lw6map_layer_t * LAYER)
     SYS_CONTEXT: global system context

     LAYER: the layer to init

     Clears a layer struct.  This means freeing the pointer if it's non
     NULL and setting everything to 0.

     *Return value:* none

 -- Function: lw6map_level_t * lw6map_new (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a new empty map.  This object is perfectly unusable as is,
     since it has a 0x0 size, and many things set to "NULL". Still, it's
     used internally and is the canonical way to create the object, it
     ensures later calls that set up default parameters, for instance,
     will succeed.

     *Return value:* a newly allocated pointer.

 -- Function: lw6map_level_t * lw6map_builtin_defaults (lw6sys_context_t
          * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a map, set to defaults.  This is usefull mostly for
     testing.  This builtin map has walls, paths, it's playable.

     *Return value:* a newly allocated map.

 -- Function: lw6map_level_t * lw6map_builtin_scale (lw6sys_context_t *
          SYS_CONTEXT, int PERCENT_FACTOR)
     SYS_CONTEXT: global system context

     PERCENT_FACTOR: how big the map should be, 100 is defaults 200 is
     double.

     Creates a map, set to defaults.  This is usefull mostly for
     testing.  This builtin map has walls, paths, it's playable,
     additionnally it's scalable, that's to say one can make it bigger
     if needed, using a percent factor.

     *Return value:* a newly allocated map.

 -- Function: lw6map_level_t * lw6map_builtin_custom (lw6sys_context_t *
          SYS_CONTEXT, int W, int H, int D, int NOISE_PERCENT)
     SYS_CONTEXT: global system context

     W: the width of the map

     H: the height of the map

     D: the depth (number of layers) of the map

     NOISE_PERCENT: percentage of noise to use for metalayers

     Creates a map, set to defaults.  This is usefull mostly for
     testing.  This one, unlike 'lw6map_builtin_defaults' will let you
     give a width, height and a depth.

     *Return value:* a newly allocated map.

 -- Function: void lw6map_free (lw6sys_context_t * SYS_CONTEXT,
          lw6map_level_t * LEVEL)
     SYS_CONTEXT: global system context

     Frees a map and releases all its internal ressources.

     *Return value:* none.

 -- Function: int lw6map_memory_footprint (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_level_t * LEVEL)
     SYS_CONTEXT: global system context

     Reports how many bytes the map needs, in memory.  Note that this is
     not contiguous memory, it involves a bunch of pointers, and
     possibly much more...

 -- Function: char * lw6map_repr (lw6sys_context_t * SYS_CONTEXT, const
          lw6map_level_t * LEVEL)
     SYS_CONTEXT: global system context

     Returns a string describing the map.  This is a very short
     description, use it for logs, and to debug stuff.  By no means it's
     a complete exhaustive description.  Still, the string returned
     should be unique.

     *Return value:* a dynamically allocated string.

 -- Function: int lw6map_is_same (lw6sys_context_t * SYS_CONTEXT, const
          lw6map_level_t * LEVEL_A, const lw6map_level_t * LEVEL_B)
     SYS_CONTEXT: global system context

     LEVEL_A: the first level to compare

     LEVEL_B: the other level to compare

     Compares two level structs, the idea is to compare the content, not
     only the pointers and level ids.

     *Return value:* 1 if they're the same, 0 if not.

 -- Function: const char * lw6map_get_title (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_level_t * LEVEL)
     SYS_CONTEXT: global system context

     LEVEL: level to get informations about

     Gives the map name.  This is just a simple utility/wrapper function
     which is meant to be exported to Guile scripts.

     *Return value:* static string, must not be freed, can't be NULL

 -- Function: int lw6map_get_max_nb_colors (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_level_t * LEVEL)
     LEVEL: level to get informations about

     Gives the max number of colors (AKA teams) that can fit on this
     map.  This is just a simple utility/wrapper function which is meant
     to be exported to Guile scripts.

     *Return value:* number of colors, taken from rules

 -- Function: int lw6map_get_max_nb_cursors (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_level_t * LEVEL)
     SYS_CONTEXT: global system context

     LEVEL: level to get informations about

     Gives the max number of cursors that can fit on this map.  This is
     just a simple utility/wrapper function which is meant to be
     exported to Guile scripts.

     *Return value:* number of cursors, taken from rules

 -- Function: int lw6map_get_max_nb_nodes (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_level_t * LEVEL)
     SYS_CONTEXT: global system context

     LEVEL: level to get informations about

     Gives the max number of nodes that can fit on this map.  This is
     just a simple utility/wrapper function which is meant to be
     exported to Guile scripts.

     *Return value:* number of nodes, taken from rules

 -- Function: int lw6map_local_info_set_music_dir (lw6sys_context_t *
          SYS_CONTEXT, lw6map_local_info_t * LOCAL_INFO, const char *
          MUSIC_DIR)
     SYS_CONTEXT: global system context

     LOCAL_INFO: the structure to modify

     MUSIC_DIR: the new music_dir value

     Sets the music_dir value, in a 'safe' manner, freeing any previous
     value and performing a string duplication.

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6map_local_info_clear (lw6sys_context_t *
          SYS_CONTEXT, lw6map_local_info_t * LOCAL_INFO)
     SYS_CONTEXT: global system context

     LOCAL_INFO: the structure to clear

     Clears the local_info structure, before destroying a level for
     instance.

     *Return value:* none

 -- Function: void lw6map_metadata_defaults (lw6sys_context_t *
          SYS_CONTEXT, lw6map_metadata_t * METADATA)
     SYS_CONTEXT: global system context

     METADATA: struct to set to defaults

     Sets the metadata struct to defaults, this does not set fields to
     NULL/empty values, but rather fills it with data claiming, for
     instance, that this is a default map.

     *Return value:* none.

 -- Function: void lw6map_metadata_clear (lw6sys_context_t *
          SYS_CONTEXT, lw6map_metadata_t * METADATA)
     SYS_CONTEXT: global system context

     METADATA: struct to clear

     Clears a metadata, will expect it to be in a consistent state, that
     is either filled with proper values or completely zeroed.

     *Return value:* none.

 -- Function: int lw6map_metadata_is_same (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_metadata_t * METADATA_A, const
          lw6map_metadata_t * METADATA_B)
     SYS_CONTEXT: global system context

     METADATA_A: first item to compare

     METADATA_B: second item to compare

     Tells wether both metadata items contain the same values.

     *Return value:* 1 if same, 0 if different.

 -- Function: void lw6map_meta_layer_set (lw6sys_context_t *
          SYS_CONTEXT, lw6map_meta_layer_t * META_LAYER, int X, int Y,
          u_int8_t VALUE)
     SYS_CONTEXT: global system context

     META_LAYER: the meta_layer structure

     X: x coord

     Y: y coord

     VALUE: the value to set at this place

     Simple setter for the meta_layer struct.

     *Return value:* none

 -- Function: u_int8_t lw6map_meta_layer_get (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_meta_layer_t * META_LAYER, int X,
          int Y)
     SYS_CONTEXT: global system context

     META_LAYER: the meta_layer structure

     X: x coord

     Y: y coord

     Simple getter for the meta_layer struct.

     *Return value:* the value at this place

 -- Function: void lw6map_meta_layer_clear (lw6sys_context_t *
          SYS_CONTEXT, lw6map_meta_layer_t * META_LAYER)
     SYS_CONTEXT: global system context

     META_LAYER: the meta_layer to clear

     Clears a meta_layer struct.  This means freeing the pointer if it's
     non NULL and setting everything to 0.

     *Return value:* none

 -- Function: int lw6map_meta_layer_builtin_custom (lw6sys_context_t *
          SYS_CONTEXT, lw6map_meta_layer_t * META_LAYER, int W, int H,
          int ANALOG, int NOISE_PERCENT, int SEED)
     SYS_CONTEXT: global system context

     META_LAYER: the object to init

     W: width

     H: height

     ANALOG: wether to use analog mode (0-255) or boolean (0-1)

     NOISE_PERCENT: the quantity of noise to initialise the layer with

     SEED: a pseudo-random seed to feed the pseudo-random generator

     Builds a custom metalyer, suitable for tests or demo, letting the
     choice of its size and the noise to fill it with.  If noise is 100
     then metalayer is "full".  If noise is 0, then meta layer is empty.

     *Return value:* 1 if OK, 0 on failure.

 -- Function: void lw6map_param_zero (lw6sys_context_t * SYS_CONTEXT,
          lw6map_param_t * PARAM)
     SYS_CONTEXT: global system context

     PARAM: struct to initialize

     Sets a param struct to zero, simply puts zero everywhere without
     checking what was here before

     *Return value:* none.

 -- Function: void lw6map_param_defaults (lw6sys_context_t *
          SYS_CONTEXT, lw6map_param_t * PARAM)
     SYS_CONTEXT: global system context

     PARAM: the param struct to modify

     Sets a param structure to its default value, note that current
     structured must be zeroed or correctly initialized.

     *Return value:* none

 -- Function: void lw6map_param_clear (lw6sys_context_t * SYS_CONTEXT,
          lw6map_param_t * PARAM)
     SYS_CONTEXT: global system context

     PARAM: the param struct to modify

     Resets a param structure to nothing.  Note that current structured
     must be zeroed or correctly initialized.  The idea is just to free
     member pointers before calling free.

     *Return value:* none

 -- Function: void lw6map_param_copy (lw6sys_context_t * SYS_CONTEXT,
          lw6map_param_t * DST, const lw6map_param_t * SRC)
     SYS_CONTEXT: global system context

     DST: the destination param struct

     SRC: the source param struct

     Copies parameters.  Both structures must be zeroed or correctly
     initialized.

     *Return value:* none

 -- Function: int lw6map_param_set (lw6sys_context_t * SYS_CONTEXT,
          lw6map_param_t * PARAM, const char * KEY, const char * VALUE)
     SYS_CONTEXT: global system context

     PARAM: the param struct to modify

     KEY: the name of the parameter to modify

     VALUE: the value of the parameter to modify

     Sets an entry in a param struct.  All values must be submitted as
     strings, internally, the function will call atoi to convert to
     integers if needed, for instance.  It will also dispatch
     automatically between rules, style and teams.

     *Return value:* 1 if parameter successfully set, 0 on error.

 -- Function: char * lw6map_param_get (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_param_t * PARAM, const char * KEY)
     SYS_CONTEXT: global system context

     PARAM: the param struct to query

     KEY: the name of the parameter to get

     Gets an entry from a param struct.  All values returned as strings,
     do not use this in performance bottlenecks, this is just to export
     values to scripts, for instance.

     *Return value:* dynamically allocated string, NULL on error, might
     return a string containing 0 on bad keys.

 -- Function: int lw6map_param_is_same (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_param_t * PARAM_A, const lw6map_param_t *
          PARAM_B)
     SYS_CONTEXT: global system context

     PARAM_A: one struct to compare

     PARAM_B: another struct to compare

     Compares the contents of two param structs.

     *Return value:* 1 if they contain the same thing, 0 if not

 -- Function: void lw6map_rules_zero (lw6sys_context_t * SYS_CONTEXT,
          lw6map_rules_t * RULES)
     SYS_CONTEXT: global system context

     RULES: struct to initialize

     Sets a rules struct to zero, simply puts zero everywhere without
     checking what was here before

     *Return value:* none.

 -- Function: void lw6map_rules_defaults (lw6sys_context_t *
          SYS_CONTEXT, lw6map_rules_t * RULES)
     SYS_CONTEXT: global system context

     RULES: struct to set to defaults

     Set rules to default values, as these are all integers, you can
     call this on any rules object.

     *Return value:* none.

 -- Function: void lw6map_rules_copy (lw6sys_context_t * SYS_CONTEXT,
          lw6map_rules_t * DST, const lw6map_rules_t * SRC)
     SYS_CONTEXT: global system context

     DST: destination (out param)

     SRC: source (in param)

     Copies the data from source to destination, simple wrapper on
     memcpy.

     *Return value:* none.

 -- Function: void lw6map_rules_update_checksum (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_rules_t * RULES, u_int32_t *
          CHECKSUM)
     SYS_CONTEXT: global system context

     RULES: rules struct to check

     CHECKSUM: checksum to update (in/out param)

     Updates a checksum with the rules data.

     *Return value:* none.

 -- Function: int32_t lw6map_rules_get_default (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY)
     SYS_CONTEXT: global system context

     KEY: key to query

     Get the default value for a given string key.  Of course you could
     access the member, but this function internally does the conversion
     between readable string and actual struct offset.

     *Return value:* integer.

 -- Function: int32_t lw6map_rules_get_min (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY)
     SYS_CONTEXT: global system context

     KEY: key to query

     Get the min value for a given string key.  Of course you could
     access the member, but this function internally does the conversion
     between readable string and actual struct offset.

     *Return value:* integer.

 -- Function: int32_t lw6map_rules_get_max (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY)
     SYS_CONTEXT: global system context

     KEY: key to query

     Get the min value for a given string key.  Of course you could
     access the member, but this function internally does the conversion
     between readable string and actual struct offset.

     *Return value:* integer.

 -- Function: int32_t lw6map_rules_get_int (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_rules_t * RULES, const char * KEY)
     SYS_CONTEXT: global system context

     RULES: struct to use

     KEY: key to query

     Get the value for a given string key, as an integer.  Of course you
     could access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:* integer.

 -- Function: int lw6map_rules_set_int (lw6sys_context_t * SYS_CONTEXT,
          lw6map_rules_t * RULES, const char * KEY, int32_t VALUE)
     SYS_CONTEXT: global system context

     RULES: struct to use

     KEY: key to set

     VALUE: new integer value for key

     Set the value for a given string key, as an integer.  Of course you
     could access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:* 1 on success, 0 on failure (eg key not found)

 -- Function: int lw6map_rules_get_bool (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_rules_t * RULES, const char * KEY)
     SYS_CONTEXT: global system context

     RULES: struct to use

     KEY: key to query

     Get the value for a given string key, as a boolean.  Of course you
     could access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:* boolean.

 -- Function: int lw6map_rules_set_bool (lw6sys_context_t * SYS_CONTEXT,
          lw6map_rules_t * RULES, const char * KEY, int VALUE)
     RULES: struct to use

     KEY: key to set

     VALUE: new boolean value for key

     Set the value for a given string key, as a boolean.  Of course you
     could access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:* 1 on success, 0 on failure (eg key not found)

 -- Function: void lw6map_rules_clear (lw6sys_context_t * SYS_CONTEXT,
          lw6map_rules_t * RULES)
     SYS_CONTEXT: global system context

     RULES: struct to init

     Set rules to 0, this is not defaults, this is 0 (probably unusable
     as a real-world setting).

     *Return value:* none.

 -- Function: int lw6map_rules_is_same (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_rules_t * RULES_A, const lw6map_rules_t *
          RULES_B)
     SYS_CONTEXT: global system context

     RULES_A: first item to compare

     RULES_B: second item to compare

     Compares two rules items.  Will tell if they contain the same data.

     *Return value:* 1 if same, 0 if different.

 -- Function: int lw6map_rules_sanity_check (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_rules_t * RULES)
     SYS_CONTEXT: global system context

     RULES: rules to check.

     Check wether the rules are within the acceptable range.

     *Return value:* 1 if same, 0 if different.

 -- Function: void lw6map_style_zero (lw6sys_context_t * SYS_CONTEXT,
          lw6map_style_t * STYLE)
     SYS_CONTEXT: global system context

     STYLE: struct to initialize

     Sets a style struct to zero, simply puts zero everywhere without
     checking what was here before

     *Return value:* none.

 -- Function: void lw6map_style_defaults (lw6sys_context_t *
          SYS_CONTEXT, lw6map_style_t * STYLE)
     SYS_CONTEXT: global system context

     STYLE: struct to modify

     Sets a style struct to defaults values, expects the object to be in
     a consistent style, that's to say either containing real data or
     being zeroed.

     *Return value:* none.

 -- Function: void lw6map_style_clear (lw6sys_context_t * SYS_CONTEXT,
          lw6map_style_t * STYLE)
     SYS_CONTEXT: global system context

     STYLE: struct to clear

     Clears a style struct.  This function won't work on an unitialized
     structure, structure must be zeroed by some CALLOC or something,
     else automatic freeing of pointers will fail.

     *Return value:* none.

 -- Function: void lw6map_style_copy (lw6sys_context_t * SYS_CONTEXT,
          lw6map_style_t * DST, const lw6map_style_t * SRC)
     SYS_CONTEXT: global system context

     DST: destination

     SRC: source

     Copies style data from source to destination.  Like with clear,
     'dst' must be either initialized or totally zeroed, else function
     will fail (core dump)

     *Return value:* none.

 -- Function: int lw6map_style_set (lw6sys_context_t * SYS_CONTEXT,
          lw6map_style_t * STYLE, const char * KEY, const char * VALUE)
     SYS_CONTEXT: global system context

     STYLE: style struct to modify (out param)

     KEY: key to use

     VALUE: value to use

     Sets a style entry, takes string values and will identify the
     struct offset and convert the value to whatever C type is needed.

     *Return value:* 1 on success, 0 on failure (key not found)

 -- Function: char * lw6map_style_get (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_style_t * STYLE, const char * KEY)
     SYS_CONTEXT: global system context

     STYLE: style struct to query

     KEY: key to use

     Get a style entry, takes a string key and will identify the struct
     offset.  The return value is converted to string, typically the
     cannonical representation suitable to write in an XML config file.

     *Return value:* dynamically allocated string.

 -- Function: char * lw6map_style_get_default (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY)
     SYS_CONTEXT: global system context

     KEY: key to query

     Get the default value for a style entry.  This is quite a
     cost-expensive function given what it does, indeed it will convert
     anything to a string, and also perform key lookup to fetch the
     value.

     *Return value:* dynamically allocated string.

 -- Function: int lw6map_color_set_is_same (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_color_set_t * COLOR_SET_A, const
          lw6map_color_set_t * COLOR_SET_B)
     SYS_CONTEXT: global system context

     COLOR_SET_A: first item to compare

     COLOR_SET_B: second item to compare

     Compares two color sets, telling if they contain the same data.

     *Return value:* 1 if same, 0 if different.

 -- Function: int lw6map_style_is_same (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_style_t * STYLE_A, const lw6map_style_t *
          STYLE_B)
     SYS_CONTEXT: global system context

     STYLE_A: first item to compare

     STYLE_B: second item to compare

     Compares two style structures, telling if they contain the same
     data.

     *Return value:* 1 if same, 0 if different.

 -- Function: void lw6map_teams_zero (lw6sys_context_t * SYS_CONTEXT,
          lw6map_teams_t * TEAMS)
     SYS_CONTEXT: global system context

     TEAMS: data to initialize

     Zeros the teams struct, this is not the same as setting to
     defaults.

     *Return value:* none.

 -- Function: void lw6map_teams_defaults (lw6sys_context_t *
          SYS_CONTEXT, lw6map_teams_t * TEAMS)
     SYS_CONTEXT: global system context

     TEAMS: data to initialize

     Set the teams struct to its defaults.

     *Return value:* none.

 -- Function: void lw6map_teams_clear (lw6sys_context_t * SYS_CONTEXT,
          lw6map_teams_t * TEAMS)
     SYS_CONTEXT: global system context

     TEAMS: data to initialize

     Clears the teams struct, this is not the same as setting to
     defaults.  This one supposes the struct has been properly
     initialized, at least zeroed before usage, it might contain
     pointers which should be freed.

     *Return value:* none.

 -- Function: void lw6map_teams_copy (lw6sys_context_t * SYS_CONTEXT,
          lw6map_teams_t * DST, const lw6map_teams_t * SRC)
     SYS_CONTEXT: global system context

     DST: destination

     SRC: source

     Copies the contents of the teams struct.  It's a real duplicate,
     any string is reallocated.

     *Return value:* none.

 -- Function: int lw6map_teams_set (lw6sys_context_t * SYS_CONTEXT,
          lw6map_teams_t * TEAMS, const char * KEY, const char * VALUE)
     SYS_CONTEXT: global system context

     TEAMS: the teams to modify

     KEY: the key to modify

     VALUE: the value to affect to the key, as a string

     Sets one single parameter in a teams structure.  Value must always
     be passed as a string, will be converted to the right type
     automatically when storing it in the structure.

     *Return value:* 1 if success, 0 if failed.  Note that while 0
     really means there's a problem, some affectations can fail and
     return 1, needs to be worked on.

 -- Function: char * lw6map_teams_get (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_teams_t * TEAMS, const char * KEY)
     SYS_CONTEXT: global system context

     TEAMS: the teams to modify

     KEY: the key to modify

     Gets one single parameter in a teams structure.  Value is converted
     as a string.

     *Return value:* dynamically allocated string, NULL on error.

 -- Function: char * lw6map_teams_get_default (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY)
     SYS_CONTEXT: global system context

     KEY: the key we want informations about.

     Gets the default value for a given teams key.

     *Return value:* dynamically allocated string, NULL on error.

 -- Function: int lw6map_teams_is_same (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_teams_t * TEAMS_A, const lw6map_teams_t *
          TEAMS_B)
     SYS_CONTEXT: global system context

     TEAMS_A: one struct to compare

     TEAMS_B: another struct to compare

     Compares the contents of two teams structs.

     *Return value:* 1 if they contain the same thing, 0 if not

 -- Function: int lw6map_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libmap module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6map_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'map' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6map_texture_from_body (lw6sys_context_t *
          SYS_CONTEXT, lw6map_texture_t * TEXTURE, const lw6map_body_t *
          BODY, const lw6map_color_couple_t * COLOR)
     SYS_CONTEXT: global system context

     TEXTURE: texture to load (out param)

     BODY: body to pick data from

     COLOR: colors to use

     Will create a default bicolor texture from the body data, this is
     in case we don't want to use the texture or there is none.  Result
     is not beautifull but might be very comfortable to play.

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6map_texture_clear (lw6sys_context_t * SYS_CONTEXT,
          lw6map_texture_t * TEXTURE)
     SYS_CONTEXT: global system context

     TEXTURE: data to clear

     Clears a texture object, expects it to be in a consitent state,
     either filled with real data of zeroed.

     *Return value:* none.

 -- Function: int lw6map_texture_coord_from_body (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_level_t * LEVEL, int * TEXTURE_X,
          int * TEXTURE_Y, int BODY_X, int BODY_Y)
     SYS_CONTEXT: global system context

     LEVEL: map to work on

     TEXTURE_X: texture x coordinate (out param)

     TEXTURE_Y: texture y coordinate (out param)

     BODY_X: body x coordinate (in param)

     BODY_Y: body y coordinate (in param)

     Translates from body coordinate space to texture coordinate space.

     *Return value:* 1 on success, 0 if failure.

 -- Function: lw6sys_color_8_t lw6map_texture_get_with_body_coord
          (lw6sys_context_t * SYS_CONTEXT, const lw6map_level_t * LEVEL,
          int BODY_X, int BODY_Y)
     SYS_CONTEXT: global system context

     LEVEL: map to use

     BODY_X: x coordinate in body space

     BODY_Y: y coordinate in body space

     Get the color of a given point in the texture, using the body
     coordinate space.

     *Return value:* RGBA 8-bit color.

 -- Function: int lw6map_texture_has_alpha (lw6sys_context_t *
          SYS_CONTEXT, lw6map_texture_t * TEXTURE)
     SYS_CONTEXT: global system context

     TEXTURE: texture object to test

     Finds out if the texture is fully opaque or not.  If it has an
     alpha layer (typically, PNG file) but this one is filled at 100%
     everywhere, then it will consider opaque.  This is a slow function
     but the result is cached in the has_alpha member, so as the
     function is called at map loading, use the cached value instead.

     *Return value:* 1 if has used alpha layer, 0 if opaque.

 -- Function: char * lw6map_weapon_index_to_key (lw6sys_context_t *
          SYS_CONTEXT, int INDEX)
     SYS_CONTEXT: global system context

     INDEX: index of the weapon between 0 & 19

     Transforms a team weapon index into its readable string form, which
     can be used in config files for instance.

     *Return value:* a string, must *not* be freed.

 -- Function: int lw6map_weapon_key_to_index (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY)
     SYS_CONTEXT: global system context

     KEY: key of the weapon, for instance "red"

     The index of the weapon, between 0 & 19

     *Return value:* an integer.

 -- Function: char * lw6map_weapon_index_to_label (lw6sys_context_t *
          SYS_CONTEXT, int INDEX)
     SYS_CONTEXT: global system context

     INDEX: index of the weapon between 0 & 19

     Transforms a team weapon index into its readable string form, which
     can be used to display information to players.

     *Return value:* a string, must *not* be freed.

 -- Struct: lw6map_body_s

     Logical layers for the map.  This is the big collection of bytes
     arrays containing most of the information, anything loaded from
     images (JPEG, PNG) from disk and having some logical (and not pure
     eye candy) meaning.

 -- Member of lw6map_body_s: checksum
     *Type:* 'int'

     *Definition:* 'int lw6map_body_s::checksum'

     Checksum for this map body, we could recalculate it dynamically but
     it's cached here for convenience and speed.

 -- Member of lw6map_body_s: shape
     *Type:* 'lw6sys_whd_t'

     *Definition:* 'lw6sys_whd_t lw6map_body_s::shape'

     Shape of the map, all layers need to be compatible with this.

 -- Member of lw6map_body_s: layers
     *Type:* 'lw6map_layer_t'

     *Definition:* 'lw6map_layer_t
     lw6map_body_s::layers[LW6MAP_MAX_BODY_DEPTH]'

     Layers, layer 0 is the top layer, the one stored in map.png, other
     layers are layerN.png.  Not all layers are defined, just depends on
     body shape.

 -- Member of lw6map_body_s: glue
     *Type:* 'lw6map_meta_layer_t'

     *Definition:* 'lw6map_meta_layer_t lw6map_body_s::glue'

     Informations stored in glue.png.

 -- Member of lw6map_body_s: boost
     *Type:* 'lw6map_meta_layer_t'

     *Definition:* 'lw6map_meta_layer_t lw6map_body_s::boost'

     Informations stored in boost.png.

 -- Member of lw6map_body_s: danger
     *Type:* 'lw6map_meta_layer_t'

     *Definition:* 'lw6map_meta_layer_t lw6map_body_s::danger'

     Informations stored in danger.png.

 -- Member of lw6map_body_s: medicine
     *Type:* 'lw6map_meta_layer_t'

     *Definition:* 'lw6map_meta_layer_t lw6map_body_s::medicine'

     Informations stored in medicine.png.

 -- Member of lw6map_body_s: one_way_north
     *Type:* 'lw6map_meta_layer_t'

     *Definition:* 'lw6map_meta_layer_t lw6map_body_s::one_way_north'

     Informations stored in one-way-north.png.

 -- Member of lw6map_body_s: one_way_east
     *Type:* 'lw6map_meta_layer_t'

     *Definition:* 'lw6map_meta_layer_t lw6map_body_s::one_way_east'

     Informations stored in one-way-east.png.

 -- Member of lw6map_body_s: one_way_south
     *Type:* 'lw6map_meta_layer_t'

     *Definition:* 'lw6map_meta_layer_t lw6map_body_s::one_way_south'

     Informations stored in one-way-south.png.

 -- Member of lw6map_body_s: one_way_west
     *Type:* 'lw6map_meta_layer_t'

     *Definition:* 'lw6map_meta_layer_t lw6map_body_s::one_way_west'

     Informations stored in one-way-west.png.

 -- Struct: lw6map_bot_info_s

     Bot information, contains the relevant generic parameters for a
     bot.

 -- Member of lw6map_bot_info_s: color
     *Type:* 'int'

     *Definition:* 'int lw6map_bot_info_s::color'

     Team/color the bot is associated to.

 -- Member of lw6map_bot_info_s: ai
     *Type:* 'char *'

     *Definition:* 'char* lw6map_bot_info_s::ai'

     AI engine used by bot, the name of the backend to load.

 -- Struct: lw6map_color_couple_s

     This structure simply binds 2 colors together, one being foreground
     and the other background.  There's a good reason to bind those
     together, indeed foreground and background need to be different
     enough so that text written in fg over bg is readable, and they
     need to go together well.

 -- Member of lw6map_color_couple_s: fg
     *Type:* 'lw6sys_color_8_t'

     *Definition:* 'lw6sys_color_8_t lw6map_color_couple_s::fg'

     Foreground color.

 -- Member of lw6map_color_couple_s: bg
     *Type:* 'lw6sys_color_8_t'

     *Definition:* 'lw6sys_color_8_t lw6map_color_couple_s::bg'

     Background color.

 -- Struct: lw6map_color_set_s

     Holds the complete color set for the game, including all color
     couples used for background, hud, menu, view, as well as team
     colors.

 -- Member of lw6map_color_set_s: color_base
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::color_base'

     Base color couple.

 -- Member of lw6map_color_set_s: color_alternate
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::color_alternate'

     Alternate color couple.

 -- Member of lw6map_color_set_s: background_color_root
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::background_color_root'

     Background color couple for root image.

 -- Member of lw6map_color_set_s: background_color_stuff
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::background_color_stuff'

     Background color couple for drawn stuff.

 -- Member of lw6map_color_set_s: hud_color_frame
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::hud_color_frame'

     Hud color couple for frames.

 -- Member of lw6map_color_set_s: hud_color_text
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::hud_color_text'

     Hud color couple for text.

 -- Member of lw6map_color_set_s: menu_color_default
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::menu_color_default'

     Menu default color couple.

 -- Member of lw6map_color_set_s: menu_color_selected
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::menu_color_selected'

     Menu color couple for selected items.

 -- Member of lw6map_color_set_s: menu_color_disabled
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::menu_color_disabled'

     Menu color couple for disabled items.

 -- Member of lw6map_color_set_s: view_color_cursor
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::view_color_cursor'

     Map view color couple for cursor.

 -- Member of lw6map_color_set_s: view_color_map
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::view_color_map'

     Map view color couple for map.

 -- Member of lw6map_color_set_s: system_color
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::system_color'

     System color couple (log messages).

 -- Member of lw6map_color_set_s: team_color_dead
     *Type:* 'lw6sys_color_8_t'

     *Definition:* 'lw6sys_color_8_t
     lw6map_color_set_s::team_color_dead'

     Color to use for dead fighters.

 -- Member of lw6map_color_set_s: team_colors
     *Type:* 'lw6sys_color_8_t'

     *Definition:* 'lw6sys_color_8_t
     lw6map_color_set_s::team_colors[LW6MAP_NB_TEAM_COLORS]'

     Team colors.

 -- Struct: lw6map_cursor_texture_layer_s

     Contains a cursor texture layer, this is basically a fixed (64x64)
     sized array of colors.

 -- Member of lw6map_cursor_texture_layer_s: data
     *Type:* 'lw6sys_color_8_t'

     *Definition:* 'lw6sys_color_8_t
     lw6map_cursor_texture_layer_s::data[LW6MAP_CURSOR_TEXTURE_SIZE][LW6MAP_CURSOR_TEXTURE_SIZE]'

     Color for each pixel.

 -- Struct: lw6map_cursor_texture_s

     A cursor texture.  It's divided between a texture that will be
     colorized depending on the map and another texture which will be
     colorized depending on the team playing the cursor.

 -- Member of lw6map_cursor_texture_s: fg_bg_layer
     *Type:* 'lw6map_cursor_texture_layer_t'

     *Definition:* 'lw6map_cursor_texture_layer_t
     lw6map_cursor_texture_s::fg_bg_layer'

     Layer to be colorized using foreground and background colors.

 -- Member of lw6map_cursor_texture_s: color_layer
     *Type:* 'lw6map_cursor_texture_layer_t'

     *Definition:* 'lw6map_cursor_texture_layer_t
     lw6map_cursor_texture_s::color_layer'

     Layer to be colorized using team colors.

 -- Struct: lw6map_layer_s

     A layer contains the actual data for a layer.

 -- Member of lw6map_layer_s: shape
     *Type:* 'lw6sys_whd_t'

     *Definition:* 'lw6sys_whd_t lw6map_layer_s::shape'

     Shape of the layer.  Z should be 1, logically.

 -- Member of lw6map_layer_s: data
     *Type:* 'u_int8_t *'

     *Definition:* 'u_int8_t* lw6map_layer_s::data'

     Raw (byte) data.

 -- Struct: lw6map_level_s

     This structure contains everything about a level, once it's loaded
     from disk.  It's immutable, it cannot be changed once it's loaded,
     and does not have any algorithm aware struct, this is just plain
     raw data, file data transformed into C struct.

 -- Member of lw6map_level_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6map_level_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6map_level_s: metadata
     *Type:* 'lw6map_metadata_t'

     *Definition:* 'lw6map_metadata_t lw6map_level_s::metadata'

     Metadata (title, copyright, description, ...)

 -- Member of lw6map_level_s: local_info
     *Type:* 'lw6map_local_info_t'

     *Definition:* 'lw6map_local_info_t lw6map_level_s::local_info'

     Informations that depend on the host loading the map.

 -- Member of lw6map_level_s: body
     *Type:* 'lw6map_body_t'

     *Definition:* 'lw6map_body_t lw6map_level_s::body'

     All layers (bytes array) forming the map.

 -- Member of lw6map_level_s: texture
     *Type:* 'lw6map_texture_t'

     *Definition:* 'lw6map_texture_t lw6map_level_s::texture'

     Texture used by the map.

 -- Member of lw6map_level_s: cursor_texture
     *Type:* 'lw6map_cursor_texture_t'

     *Definition:* 'lw6map_cursor_texture_t
     lw6map_level_s::cursor_texture'

     Cursor texture.

 -- Member of lw6map_level_s: param
     *Type:* 'lw6map_param_t'

     *Definition:* 'lw6map_param_t lw6map_level_s::param'

     All map parameters.

 -- Struct: lw6map_local_info_s

     Local info is for fields which can be exploited locally, but make
     no sense if transfered to another computer, over the network for
     instance.  This is typically something which will be updated by the
     ldr module or some other external code, but it's not directly
     linked to the content of the map itself.

 -- Member of lw6map_local_info_s: music_dir
     *Type:* 'char *'

     *Definition:* 'char* lw6map_local_info_s::music_dir'

     Directory where music files can be loaded.

 -- Struct: lw6map_metadata_s

     Content of metadata.xml stored into a C struct.

 -- Member of lw6map_metadata_s: title
     *Type:* 'char *'

     *Definition:* 'char* lw6map_metadata_s::title'

     Title of the map.

 -- Member of lw6map_metadata_s: author
     *Type:* 'char *'

     *Definition:* 'char* lw6map_metadata_s::author'

     Author of the map.

 -- Member of lw6map_metadata_s: description
     *Type:* 'char *'

     *Definition:* 'char* lw6map_metadata_s::description'

     Description of the map.

 -- Member of lw6map_metadata_s: license
     *Type:* 'char *'

     *Definition:* 'char* lw6map_metadata_s::license'

     License of the map (short, like GPLv2+ or GPLv3+).

 -- Member of lw6map_metadata_s: vanilla_exp
     *Type:* 'int'

     *Definition:* 'int lw6map_metadata_s::vanilla_exp'

     Exp as stored in the XML file of the map.

 -- Struct: lw6map_meta_layer_s

     A meta layer is a special layer which contains, for instance,
     informations such as where there's a special trick like glue.

 -- Member of lw6map_meta_layer_s: shape
     *Type:* 'lw6sys_whd_t'

     *Definition:* 'lw6sys_whd_t lw6map_meta_layer_s::shape'

     Shape of the metalayer.

 -- Member of lw6map_meta_layer_s: data
     *Type:* 'u_int8_t *'

     *Definition:* 'u_int8_t* lw6map_meta_layer_s::data'

     Raw (byte) data.

 -- Struct: lw6map_param_s

     All parameters in a map, indludes rules, style and teams.

 -- Member of lw6map_param_s: rules
     *Type:* 'lw6map_rules_t'

     *Definition:* 'lw6map_rules_t lw6map_param_s::rules'

     Content of rules.xml.

 -- Member of lw6map_param_s: style
     *Type:* 'lw6map_style_t'

     *Definition:* 'lw6map_style_t lw6map_param_s::style'

     Content of style.xml.

 -- Member of lw6map_param_s: teams
     *Type:* 'lw6map_teams_t'

     *Definition:* 'lw6map_teams_t lw6map_param_s::teams'

     Content of teams.xml.

 -- Struct: lw6map_rules_s

     Content of rules.xml stored into a C struct.  This structure is
     used a lot, it needs to be like this for we don't want to parse
     (even a hash) each time we want a param so we need it in a real C
     struct.  In this structure, it's important, fundamental, that
     floats are never ever used in map rules.  In fact, we need maps to
     be 100,00 (lots of zeroes) predictable, given some identical user
     actions.  Using floats could lead us to very slight differences
     (floats are never accurate, especially when you run calculus on
     different hardwares) which could, with time, become very important.
     Sort of a "butterfly effect".  So well, we use int.  Int32 to be
     exact.

 -- Member of lw6map_rules_s: total_time
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::total_time'

     total_time parameter, stored as an integer.

 -- Member of lw6map_rules_s: respawn_team
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::respawn_team'

     respawn_team parameter, stored as an integer.

 -- Member of lw6map_rules_s: respawn_position_mode
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::respawn_position_mode'

     respawn_position_mode parameter, stored as an integer.

 -- Member of lw6map_rules_s: respawn_delay
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::respawn_delay'

     respawn_delay parameter, stored as an integer.

 -- Member of lw6map_rules_s: moves_per_round
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::moves_per_round'

     moves_per_round parameter, stored as an integer.

 -- Member of lw6map_rules_s: spreads_per_round
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::spreads_per_round'

     spreads_per_round parameter, stored as an integer.

 -- Member of lw6map_rules_s: rounds_per_sec
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::rounds_per_sec'

     rounds_per_sec parameter, stored as an integer.

 -- Member of lw6map_rules_s: fighter_attack
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::fighter_attack'

     fighter_attack parameter, stored as an integer.

 -- Member of lw6map_rules_s: fighter_defense
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::fighter_defense'

     fighter_defense parameter, stored as an integer.

 -- Member of lw6map_rules_s: fighter_new_health
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::fighter_new_health'

     fighter_new_health parameter, stored as an integer.

 -- Member of lw6map_rules_s: fighter_regenerate
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::fighter_regenerate'

     fighter_regenerate parameter, stored as an integer.

 -- Member of lw6map_rules_s: side_attack_factor
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::side_attack_factor'

     side_attack_factor parameter, stored as an integer.

 -- Member of lw6map_rules_s: side_defense_factor
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::side_defense_factor'

     side_defense_factor parameter, stored as an integer.

 -- Member of lw6map_rules_s: nb_move_tries
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::nb_move_tries'

     nb_move_tries parameter, stored as an integer.

 -- Member of lw6map_rules_s: nb_attack_tries
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::nb_attack_tries'

     nb_attack_tries parameter, stored as an integer.

 -- Member of lw6map_rules_s: nb_defense_tries
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::nb_defense_tries'

     nb_defense_tries parameter, stored as an integer.

 -- Member of lw6map_rules_s: vertical_move
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::vertical_move'

     vertical_move parameter, stored as an integer.

 -- Member of lw6map_rules_s: spread_mode
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::spread_mode'

     spread_mode parameter, stored as an integer.

 -- Member of lw6map_rules_s: single_army_size
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::single_army_size'

     single_army_size parameter, stored as an integer.

 -- Member of lw6map_rules_s: total_armies_size
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::total_armies_size'

     total_armies_size parameter, stored as an integer.

 -- Member of lw6map_rules_s: max_nb_teams
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::max_nb_teams'

     max_nb_teams parameter, stored as an integer.

 -- Member of lw6map_rules_s: max_nb_cursors
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::max_nb_cursors'

     max_nb_cursors parameter, stored as an integer.

 -- Member of lw6map_rules_s: max_nb_nodes
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::max_nb_nodes'

     max_nb_nodes parameter, stored as an integer.

 -- Member of lw6map_rules_s: exp
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::exp'

     exp parameter, stored as an integer.

 -- Member of lw6map_rules_s: highest_team_color_allowed
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::highest_team_color_allowed'

     highest_team_color_allowed parameter, stored as an integer.

 -- Member of lw6map_rules_s: highest_weapon_allowed
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::highest_weapon_allowed'

     highest_weapon_allowed parameter, stored as an integer.

 -- Member of lw6map_rules_s: x_polarity
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::x_polarity'

     x_polarity parameter, stored as an integer.

 -- Member of lw6map_rules_s: y_polarity
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::y_polarity'

     y_polarity parameter, stored as an integer.

 -- Member of lw6map_rules_s: z_polarity
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::z_polarity'

     z_polarity parameter, stored as an integer.

 -- Member of lw6map_rules_s: max_zone_size
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::max_zone_size'

     max_zone_size parameter, stored as an integer.

 -- Member of lw6map_rules_s: round_delta
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::round_delta'

     round_delta parameter, stored as an integer.

 -- Member of lw6map_rules_s: max_round_delta
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::max_round_delta'

     max_round_delta parameter, stored as an integer.

 -- Member of lw6map_rules_s: max_cursor_pot
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::max_cursor_pot'

     max_cursor_pot parameter, stored as an integer.

 -- Member of lw6map_rules_s: cursor_pot_init
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::cursor_pot_init'

     cursor_pot_init parameter, stored as an integer.

 -- Member of lw6map_rules_s: max_cursor_pot_offset
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::max_cursor_pot_offset'

     max_cursor_pot_offset parameter, stored as an integer.

 -- Member of lw6map_rules_s: start_x
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6map_rules_s::start_x[LW6MAP_MAX_NB_TEAMS]'

     start_x parameters, stored as a per team integer.

 -- Member of lw6map_rules_s: start_y
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6map_rules_s::start_y[LW6MAP_MAX_NB_TEAMS]'

     start_y parameters, stored as a per team integer.

 -- Member of lw6map_rules_s: start_position_mode
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::start_position_mode'

     start_position_mode parameter, stored as an integer.

 -- Member of lw6map_rules_s: color_conflict_mode
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::color_conflict_mode'

     color_conflict_mode parameter, stored as an integer.

 -- Member of lw6map_rules_s: spread_thread
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::spread_thread'

     spread_thread parameter, stored as an integer.

 -- Member of lw6map_rules_s: glue_power
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::glue_power'

     glue_power parameter, stored as an integer.

 -- Member of lw6map_rules_s: boost_power
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::boost_power'

     boost_power parameter, stored as an integer.

 -- Member of lw6map_rules_s: danger_power
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::danger_power'

     danger_power parameter, stored as an integer.

 -- Member of lw6map_rules_s: medicine_power
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::medicine_power'

     medicine_power parameter, stored as an integer.

 -- Member of lw6map_rules_s: frags_mode
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::frags_mode'

     frags_mode parameter, stored as an integer.

 -- Member of lw6map_rules_s: frags_to_distribute
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::frags_to_distribute'

     frags_to_distribute parameter, stored as an integer.

 -- Member of lw6map_rules_s: frags_fade_out
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::frags_fade_out'

     frags_fade_out parameter, stored as an integer.

 -- Member of lw6map_rules_s: use_team_profiles
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::use_team_profiles'

     use_team_profiles parameter, stored as an integer.

 -- Member of lw6map_rules_s: team_profile_aggressive
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6map_rules_s::team_profile_aggressive[LW6MAP_MAX_NB_TEAMS]'

     team_profile_aggressive parameters, stored as a per team integer.

 -- Member of lw6map_rules_s: team_profile_vulnerable
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6map_rules_s::team_profile_vulnerable[LW6MAP_MAX_NB_TEAMS]'

     team_profile_vulnerable parameters, stored as a per team integer.

 -- Member of lw6map_rules_s: team_profile_mobile
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6map_rules_s::team_profile_mobile[LW6MAP_MAX_NB_TEAMS]'

     team_profile_mobile parameters, stored as a per team integer.

 -- Member of lw6map_rules_s: team_profile_fast
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6map_rules_s::team_profile_fast[LW6MAP_MAX_NB_TEAMS]'

     team_profile_fast parameters, stored as a per team integer.

 -- Member of lw6map_rules_s: team_profile_handicap
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6map_rules_s::team_profile_handicap[LW6MAP_MAX_NB_TEAMS]'

     team_profile_handicap parameters, stored as a per team integer.

 -- Member of lw6map_rules_s: team_profile_weapon_id
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6map_rules_s::team_profile_weapon_id[LW6MAP_MAX_NB_TEAMS]'

     team_profile_weapon_id parameters, stored as a per team integer.

 -- Member of lw6map_rules_s: team_profile_weapon_alternate_id
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6map_rules_s::team_profile_weapon_alternate_id[LW6MAP_MAX_NB_TEAMS]'

     team_profile_weapon_alternate_id parameters, stored as a per team
     integer.

 -- Member of lw6map_rules_s: team_profile_weapon_mode
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6map_rules_s::team_profile_weapon_mode[LW6MAP_MAX_NB_TEAMS]'

     team_profile_weapon_mode parameters, stored as a per team integer.

 -- Member of lw6map_rules_s: weapon_duration
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::weapon_duration'

     weapon_duration parameter, stored as an integer.

 -- Member of lw6map_rules_s: weapon_charge_delay
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::weapon_charge_delay'

     weapon_charge_delay parameter, stored as an integer.

 -- Member of lw6map_rules_s: weapon_charge_max
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::weapon_charge_max'

     weapon_charge_max parameter, stored as an integer.

 -- Member of lw6map_rules_s: weapon_tune_berzerk_power
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::weapon_tune_berzerk_power'

     weapon_tune_berzerk_power parameter, stored as an integer.

 -- Member of lw6map_rules_s: weapon_tune_turbo_power
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::weapon_tune_turbo_power'

     weapon_tune_turbo_power parameter, stored as an integer.

 -- Struct: lw6map_style_s

     Content of style.xml stored into a C struct.

 -- Member of lw6map_style_s: keep_ratio
     *Type:* 'int'

     *Definition:* 'int lw6map_style_s::keep_ratio'

     Boolean, wether to keep the map ratio or not.

 -- Member of lw6map_style_s: zoom
     *Type:* 'float'

     *Definition:* 'float lw6map_style_s::zoom'

     Default zoom.

 -- Member of lw6map_style_s: zoom_min
     *Type:* 'float'

     *Definition:* 'float lw6map_style_s::zoom_min'

     Min zoom.

 -- Member of lw6map_style_s: zoom_max
     *Type:* 'float'

     *Definition:* 'float lw6map_style_s::zoom_max'

     Max zoom.

 -- Member of lw6map_style_s: x_wrap
     *Type:* 'int'

     *Definition:* 'int lw6map_style_s::x_wrap'

     Wether to wrap on X axis.

 -- Member of lw6map_style_s: y_wrap
     *Type:* 'int'

     *Definition:* 'int lw6map_style_s::y_wrap'

     Wether to wrap on Y axis.

 -- Member of lw6map_style_s: background_style
     *Type:* 'char *'

     *Definition:* 'char* lw6map_style_s::background_style'

     Background style to use (for instance, bubbles).

 -- Member of lw6map_style_s: hud_style
     *Type:* 'char *'

     *Definition:* 'char* lw6map_style_s::hud_style'

     Hud style to use (for instance, floating).

 -- Member of lw6map_style_s: menu_style
     *Type:* 'char *'

     *Definition:* 'char* lw6map_style_s::menu_style'

     Menu style to use (for instance, cylinder).

 -- Member of lw6map_style_s: view_style
     *Type:* 'char *'

     *Definition:* 'char* lw6map_style_s::view_style'

     View style to use (for instance, flat).

 -- Member of lw6map_style_s: animation_density
     *Type:* 'float'

     *Definition:* 'float lw6map_style_s::animation_density'

     How dense animations should be (many or few sprites).

 -- Member of lw6map_style_s: animation_speed
     *Type:* 'float'

     *Definition:* 'float lw6map_style_s::animation_speed'

     How fast animations should be (sprites speed).

 -- Member of lw6map_style_s: cursor_size
     *Type:* 'float'

     *Definition:* 'float lw6map_style_s::cursor_size'

     Cursor size.

 -- Member of lw6map_style_s: colorize_cursor
     *Type:* 'int'

     *Definition:* 'int lw6map_style_s::colorize_cursor'

     Wether to colorize cursors or not.

 -- Member of lw6map_style_s: blink_cursor
     *Type:* 'int'

     *Definition:* 'int lw6map_style_s::blink_cursor'

     Wether to make cursors blink or not.

 -- Member of lw6map_style_s: hidden_layer_alpha
     *Type:* 'float'

     *Definition:* 'float lw6map_style_s::hidden_layer_alpha'

     Alpha value used to represent fighters hidden behind a layer.

 -- Member of lw6map_style_s: colorize
     *Type:* 'int'

     *Definition:* 'int lw6map_style_s::colorize'

     Wether to use colorization or not.

 -- Member of lw6map_style_s: pixelize
     *Type:* 'int'

     *Definition:* 'int lw6map_style_s::pixelize'

     Wether to pixelize the map and fighters or not.

 -- Member of lw6map_style_s: color_set
     *Type:* 'lw6map_color_set_t'

     *Definition:* 'lw6map_color_set_t lw6map_style_s::color_set'

     All colors used by the game.

 -- Member of lw6map_style_s: music_file
     *Type:* 'char *'

     *Definition:* 'char* lw6map_style_s::music_file'

     Music file to play.

 -- Member of lw6map_style_s: music_filter
     *Type:* 'char *'

     *Definition:* 'char* lw6map_style_s::music_filter'

     Music files to keep.

 -- Member of lw6map_style_s: music_exclude
     *Type:* 'char *'

     *Definition:* 'char* lw6map_style_s::music_exclude'

     Music files to exclude.

 -- Member of lw6map_style_s: waves
     *Type:* 'int'

     *Definition:* 'int lw6map_style_s::waves'

     Wether to turn on the wave effect or not.

 -- Struct: lw6map_teams_s

     Content of teams.xml stored into a C struct.

 -- Member of lw6map_teams_s: player_color
     *Type:* 'int'

     *Definition:* 'int
     lw6map_teams_s::player_color[LW6MAP_TEAMS_NB_PLAYERS]'

     Players colors.

 -- Member of lw6map_teams_s: nb_bots
     *Type:* 'int'

     *Definition:* 'int lw6map_teams_s::nb_bots'

     Number of bots.

 -- Member of lw6map_teams_s: bot_speed
     *Type:* 'float'

     *Definition:* 'float lw6map_teams_s::bot_speed'

     Bots speed.

 -- Member of lw6map_teams_s: bot_iq
     *Type:* 'int'

     *Definition:* 'int lw6map_teams_s::bot_iq'

     Bots IQ (how strong they are)

 -- Member of lw6map_teams_s: bot
     *Type:* 'lw6map_bot_info_t'

     *Definition:* 'lw6map_bot_info_t
     lw6map_teams_s::bot[LW6MAP_TEAMS_MAX_NB_BOTS]'

     Per-bot parameters, including their color and the ai engine they
     use.

 -- Struct: lw6map_texture_s

     Texture information, this is a bit different from a layer, since
     this is RGBA data, plus some meta-informations such as guessed
     colors.

 -- Member of lw6map_texture_s: w
     *Type:* 'int'

     *Definition:* 'int lw6map_texture_s::w'

     Texture width.

 -- Member of lw6map_texture_s: h
     *Type:* 'int'

     *Definition:* 'int lw6map_texture_s::h'

     Texture height.

 -- Member of lw6map_texture_s: has_alpha
     *Type:* 'int'

     *Definition:* 'int lw6map_texture_s::has_alpha'

     True if texture has an alpha channel.  If it has an alpha channel
     on disk (for instance, it's a PNG) and if in practice it has
     nothing else than full opaque 255 alpha values, then this will be
     set to 0 anyway, the idea is to detect textures that really need
     the engine to handle transparency.

 -- Member of lw6map_texture_s: data
     *Type:* 'lw6sys_color_8_t *'

     *Definition:* 'lw6sys_color_8_t* lw6map_texture_s::data'

     Color for each pixel.

 -- Member of lw6map_texture_s: guessed_color_base
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_texture_s::guessed_color_base'

     Base guessed color couple.  This is typically the best or more
     representative color couple (fg and bg) the program was able to
     automatically extract from the map.

 -- Member of lw6map_texture_s: guessed_color_alternate
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_texture_s::guessed_color_alternate'

     An alternate color couple which still comes from the map but is a
     bit different from the base one.

