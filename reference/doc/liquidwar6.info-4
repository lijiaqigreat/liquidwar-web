This is liquidwar6.info, produced by makeinfo version 5.2 from
liquidwar6.texi.

Liquid War 6, a unique multiplayer wargame.

   Copyright (c) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013,
2014, 2015 Christian Mauduit <ufoot@ufoot.org>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts and no
     Back-Cover Texts.  A copy of the license is included in the section
     entitled "GNU Free Documentation License".
START-INFO-DIR-ENTRY
* Liquid War 6: (liquidwar6).   A unique multiplayer wargame.
END-INFO-DIR-ENTRY


File: liquidwar6.info,  Node: libmat,  Next: libmsg,  Prev: libmap,  Up: C API

5.32 libmat
===========

5.32.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/mat/index.html>.

5.32.2 API
----------

 -- Function: void lw6mat_dmat2_zero (lw6mat_dmat2_t * DMAT2)
     DMAT2: the matrix to initialize.

     Fills the matrix with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: void lw6mat_dmat2_identity (lw6mat_dmat2_t * DMAT2)
     DMAT2: the matrix to initialize.

     Loads the matrix with the identity matrix, that is, zero everywhere
     but one on the main diag.

     *Return value:* none.

 -- Function: void lw6mat_dmat2_translation (lw6mat_dmat2_t * DMAT2,
          double D)
     DMAT2: the matrix to initialize.

     D: value which defines the translation.

     Loads the matrix with a translation transformation matrix.  By
     multiplicating by this matrix, a translation is done.

     *Return value:* none.

 -- Function: void lw6mat_dmat2_scale (lw6mat_dmat2_t * DMAT2, double D)
     DMAT2: the matrix to initialize.

     D: value used to scale matrix.

     Loads the matrix with a scale matrix.  By multiplicating by this
     matrix, a scaling is done.

     *Return value:* none.

 -- Function: int lw6mat_dmat2_is_same (const lw6mat_dmat2_t * DMAT2_A,
          const lw6mat_dmat2_t * DMAT2_B)
     DMAT2_A: 1st matrix to compare

     DMAT2_B: 2nd matrix to compare

     Compares two matrix, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: void lw6mat_dmat2_transpose (lw6mat_dmat2_t * DMAT2)
     DMAT2: the matrix to transpose

     Transposes the matrix, that is, inverts rows and columns.

     *Return value:* none.

 -- Function: double lw6mat_dmat2_det (const lw6mat_dmat2_t * DMAT2)
     DMAT2: the matrix used to calculate the determinant

     Calulates the determinant of the matrix.

     *Return value:* the determinant.

 -- Function: void lw6mat_dmat2_mul_scale (lw6mat_dmat2_t * DMAT2,
          double F)
     DMAT2: matrix to modify

     F: scale factor

     Scales the matrix by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: int lw6mat_dmat2_inv (lw6sys_context_t * SYS_CONTEXT,
          lw6mat_dmat2_t * DMAT2_DST, const lw6mat_dmat2_t * DMAT2_SRC)
     SYS_CONTEXT: global system context

     DMAT2_DST: the matrix inverted

     DMAT2_SRC: the matrix to invert

     Inverts a matrix.  Probably not the fastest implementation, but
     should work in all cases.  Use hardware accelerated API such as
     OpenGL on dedicated hardware if you want power.

     *Return value:* 1 if inverted, 0 if error, typically if determinant
     was 0, matrix can not be inverted.

 -- Function: void lw6mat_dmat2_mul_dmat2 (lw6mat_dmat2_t * DMAT2, const
          lw6mat_dmat2_t * DMAT2_A, const lw6mat_dmat2_t * DMAT2_B)
     DMAT2: the result matrix

     DMAT2_A: the 1st matrix to multiply, on the left

     DMAT2_B: the 2nd matrix to multiply, on the right

     Classic matrix multiplication.

     *Return value:* none.

 -- Function: void lw6mat_dmat2_mul_dvec2 (lw6mat_dvec2_t * DVEC2_DST,
          const lw6mat_dmat2_t * DMAT2, const lw6mat_dvec2_t *
          DVEC2_SRC)
     DVEC2_DST: the result vector

     DVEC2_SRC: the source vector

     Multiplication of matrix by vector.  The result is a vector, the
     convention used is that of OpenGL, matrix are column major and
     vector are columns, that is, should you do it on a paper, vector is
     placed vertically, on the right of matrix.  The other
     multiplication is not implemented, transposing the matrix will do
     it the other way if you wish.

     *Return value:* none.

 -- Function: char * lw6mat_dmat2_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_dmat2_t * DMAT2)
     SYS_CONTEXT: global system context

     Gives a readable version of the matrix, the representation uses
     newlines, with a different line for each row

     *Return value:* newly allocated string

 -- Function: void lw6mat_dmat3_zero (lw6mat_dmat3_t * DMAT3)
     DMAT3: the matrix to initialize.

     Fills the matrix with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: void lw6mat_dmat3_identity (lw6mat_dmat3_t * DMAT3)
     DMAT3: the matrix to initialize.

     Loads the matrix with the identity matrix, that is, zero everywhere
     but one on the main diag.

     *Return value:* none.

 -- Function: void lw6mat_dmat3_translation (lw6mat_dmat3_t * DMAT3,
          const lw6mat_dvec2_t * DVEC2)
     DMAT3: the matrix to initialize.

     DVEC2: vector which defines the translation.

     Loads the matrix with a translation transformation matrix.  By
     multiplicating by this matrix, a translation is done.

     *Return value:* none.

 -- Function: void lw6mat_dmat3_scale (lw6mat_dmat3_t * DMAT3, const
          lw6mat_dvec2_t * DVEC2)
     DMAT3: the matrix to initialize.

     DVEC2: value used to scale matrix.

     Loads the matrix with a scale matrix.  By multiplicating by this
     matrix, a scaling is done.

     *Return value:* none.

 -- Function: void lw6mat_dmat3_rot (lw6mat_dmat3_t * DMAT3, double R)
     DMAT3: the matrix to initialize.

     R: value used to for the rotation, angle in radians.

     Loads the matrix with a rotation matrix.  By multiplicating by this
     matrix, a rotation is done, over a virtual Z axis such as Z is the
     cross product of X and Y.

     *Return value:* none.

 -- Function: int lw6mat_dmat3_is_same (const lw6mat_dmat3_t * DMAT3_A,
          const lw6mat_dmat3_t * DMAT3_B)
     DMAT3_A: 1st matrix to compare

     DMAT3_B: 2nd matrix to compare

     Compares two matrix, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: void lw6mat_dmat3_transpose (lw6mat_dmat3_t * DMAT3)
     DMAT3: the matrix to transpose

     Transposes the matrix, that is, inverts rows and columns.

     *Return value:* none.

 -- Function: double lw6mat_dmat3_det (const lw6mat_dmat3_t * DMAT3)
     DMAT3: the matrix used to calculate the determinant

     Calulates the determinant of the matrix.

     *Return value:* the determinant.

 -- Function: void lw6mat_dmat3_mul_scale (lw6mat_dmat3_t * DMAT3,
          double F)
     DMAT3: matrix to modify

     F: scale factor

     Scales the matrix by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: int lw6mat_dmat3_inv (lw6sys_context_t * SYS_CONTEXT,
          lw6mat_dmat3_t * DMAT3_DST, const lw6mat_dmat3_t * DMAT3_SRC)
     SYS_CONTEXT: global system context

     DMAT3_DST: the matrix inverted

     DMAT3_SRC: the matrix to invert

     Inverts a matrix.  Probably not the fastest implementation, but
     should work in all cases.  Use hardware accelerated API such as
     OpenGL on dedicated hardware if you want power.

     *Return value:* 1 if inverted, 0 if error, typically if determinant
     was 0, matrix can not be inverted.

 -- Function: void lw6mat_dmat3_mul_dmat3 (lw6mat_dmat3_t * DMAT3, const
          lw6mat_dmat3_t * DMAT3_A, const lw6mat_dmat3_t * DMAT3_B)
     DMAT3: the result matrix

     DMAT3_A: the 1st matrix to multiply, on the left

     DMAT3_B: the 2nd matrix to multiply, on the right

     Classic matrix multiplication.

     *Return value:* none.

 -- Function: void lw6mat_dmat3_mul_dvec3 (lw6mat_dvec3_t * DVEC3_DST,
          const lw6mat_dmat3_t * DMAT3, const lw6mat_dvec3_t *
          DVEC3_SRC)
     DVEC3_DST: the result vector

     DVEC3_SRC: the source vector

     Multiplication of matrix by vector.  The result is a vector, the
     convention used is that of OpenGL, matrix are column major and
     vector are columns, that is, should you do it on a paper, vector is
     placed vertically, on the right of matrix.  The other
     multiplication is not implemented, transposing the matrix will do
     it the other way if you wish.

     *Return value:* none.

 -- Function: void lw6mat_dmat3_mul_dvec2 (lw6mat_dvec2_t * DVEC2_DST,
          const lw6mat_dmat3_t * DMAT3, const lw6mat_dvec2_t *
          DVEC2_SRC)
     DVEC2_DST: the result vector

     Multiplication of matrix by vector.  The result is a vector, the
     convention used is that of OpenGL, matrix are column major and
     vector are columns, that is, should you do it on a paper, vector is
     placed vertically, on the right of matrix.  The other
     multiplication is not implemented, transposing the matrix will do
     it the other way if you wish.  The vector, here, is smaller than
     the matrix, the last element is supposed to be 1, this is how one
     implements translation through multiplication.

     *Return value:* none.

 -- Function: char * lw6mat_dmat3_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_dmat3_t * DMAT3)
     SYS_CONTEXT: global system context

     Gives a readable version of the matrix, the representation uses
     newlines, with a different line for each row

     *Return value:* newly allocated string

 -- Function: void lw6mat_dmat4_zero (lw6mat_dmat4_t * DMAT4)
     DMAT4: the matrix to initialize.

     Fills the matrix with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: void lw6mat_dmat4_identity (lw6mat_dmat4_t * DMAT4)
     DMAT4: the matrix to initialize.

     Loads the matrix with the identity matrix, that is, zero everywhere
     but one on the main diag.

     *Return value:* none.

 -- Function: void lw6mat_dmat4_translation (lw6mat_dmat4_t * DMAT4,
          const lw6mat_dvec3_t * DVEC3)
     DMAT4: the matrix to initialize.

     DVEC3: vector which defines the translation.

     Loads the matrix with a translation transformation matrix.  By
     multiplicating by this matrix, a translation is done.

     *Return value:* none.

 -- Function: void lw6mat_dmat4_scale (lw6mat_dmat4_t * DMAT4, const
          lw6mat_dvec3_t * DVEC3)
     DMAT4: the matrix to initialize.

     DVEC3: value used to scale matrix.

     Loads the matrix with a scale matrix.  By multiplicating by this
     matrix, a scaling is done.

     *Return value:* none.

 -- Function: void lw6mat_dmat4_rot_x (lw6mat_dmat4_t * DMAT4, double R)
     DMAT4: the matrix to initialize.

     R: value used to for the rotation, angle in radians.

     Loads the matrix with a rotation matrix.  By multiplicating by this
     matrix, a rotation is done, over the X axis.

     *Return value:* none.

 -- Function: void lw6mat_dmat4_rot_y (lw6mat_dmat4_t * DMAT4, double R)
     DMAT4: the matrix to initialize.

     R: value used to for the rotation, angle in radians.

     Loads the matrix with a rotation matrix.  By multiplicating by this
     matrix, a rotation is done, over the Y axis.

     *Return value:* none.

 -- Function: void lw6mat_dmat4_rot_z (lw6mat_dmat4_t * DMAT4, double R)
     DMAT4: the matrix to initialize.

     R: value used to for the rotation, angle in radians.

     Loads the matrix with a rotation matrix.  By multiplicating by this
     matrix, a rotation is done, over the Z axis.

     *Return value:* none.

 -- Function: void lw6mat_dmat4_ortho (lw6mat_dmat4_t * DMAT4, double
          LEFT, double RIGHT, double BOTTOM, double TOP, double NEARVAL,
          double FARVAL)
     DMAT4: the matrix to initialize.

     LEFT: left plane coordinate

     RIGHT: right plane coordinate

     BOTTOM: bottom plane coordinate

     TOP: top plane coordinate

     NEARVAL: near plane coordinate

     FARVAL: far plane coordinate

     Loads the matrix with an orthogonal projection matrix.  Does it the
     way glOrtho would, see
     https://www.opengl.org/sdk/docs/man2/xhtml/glOrtho.xml for details.

     *Note:* use -nearVal and -farVal to initialize.  It's a little
     akward, if you expect to pass vectors with positions ranging from
     nearVal to farVal then you need to pass -nearVal and -farVal to
     this function.  This is probably due to the fact that with a
     right-handed basis and X,Y set up "as usual", then Z is negative
     when going farther and farther.  This tweak allows farVal to yield
     +1 and nearVal -1.  We keep this function as is here, as this is
     the way OpenGL functions seem to work.

     *Return value:* none.

 -- Function: void lw6mat_dmat4_perspective (lw6mat_dmat4_t * DMAT4,
          double FOVY, double ASPECT, double ZNEAR, double ZFAR)
     DMAT4: the matrix to initialize.

     FOVY: vertical field of view (degrees, not radians)

     ASPECT: x/y ratio

     ZNEAR: near plane coordinate (use -znear to initialize)

     ZFAR: far plane coordinate (use -zfar to initialize)

     Loads the matrix with a projection matrix.  Does it the way
     gluPerspective would, see
     https://www.opengl.org/sdk/docs/man2/xhtml/gluPerspective.xml for
     details.

     *Return value:* none.

 -- Function: int lw6mat_dmat4_is_same (const lw6mat_dmat4_t * DMAT4_A,
          const lw6mat_dmat4_t * DMAT4_B)
     DMAT4_A: 1st matrix to compare

     DMAT4_B: 2nd matrix to compare

     Compares two matrix, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: void lw6mat_dmat4_transpose (lw6mat_dmat4_t * DMAT4)
     DMAT4: the matrix to transpose

     Transposes the matrix, that is, inverts rows and columns.

     *Return value:* none.

 -- Function: double lw6mat_dmat4_det (const lw6mat_dmat4_t * DMAT4)
     DMAT4: the matrix used to calculate the determinant

     Calulates the determinant of the matrix.

     *Return value:* the determinant.

 -- Function: void lw6mat_dmat4_mul_scale (lw6mat_dmat4_t * DMAT4,
          double F)
     DMAT4: matrix to modify

     F: scale factor

     Scales the matrix by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: int lw6mat_dmat4_inv (lw6sys_context_t * SYS_CONTEXT,
          lw6mat_dmat4_t * DMAT4_DST, const lw6mat_dmat4_t * DMAT4_SRC)
     SYS_CONTEXT: global system context

     DMAT4_DST: the matrix inverted

     DMAT4_SRC: the matrix to invert

     Inverts a matrix.  Probably not the fastest implementation, but
     should work in all cases.  Use hardware accelerated API such as
     OpenGL on dedicated hardware if you want power.

     *Return value:* 1 if inverted, 0 if error, typically if determinant
     was 0, matrix can not be inverted.

 -- Function: void lw6mat_dmat4_mul_dmat4 (lw6mat_dmat4_t * DMAT4, const
          lw6mat_dmat4_t * DMAT4_A, const lw6mat_dmat4_t * DMAT4_B)
     DMAT4: the result matrix

     DMAT4_A: the 1st matrix to multiply, on the left

     DMAT4_B: the 2nd matrix to multiply, on the right

     Classic matrix multiplication.

     *Return value:* none.

 -- Function: void lw6mat_dmat4_mul_dvec4 (lw6mat_dvec4_t * DVEC4_DST,
          const lw6mat_dmat4_t * DMAT4, const lw6mat_dvec4_t *
          DVEC4_SRC)
     DVEC4_DST: the result vector

     DMAT4: the matrix to use

     DVEC4_SRC: the source vector

     Multiplication of matrix by vector.  The result is a vector, the
     convention used is that of OpenGL, matrix are column major and
     vector are columns, that is, should you do it on a paper, vector is
     placed vertically, on the right of matrix.  The other
     multiplication is not implemented, transposing the matrix will do
     it the other way if you wish.

     *Return value:* none.

 -- Function: void lw6mat_dmat4_mul_dvec3 (lw6mat_dvec3_t * DVEC3_DST,
          const lw6mat_dmat4_t * DMAT4, const lw6mat_dvec3_t *
          DVEC3_SRC)
     DVEC3_DST: the result vector

     DMAT4: the matrix to use

     DVEC3_SRC: the source vector

     Multiplication of matrix by vector.  The result is a vector, the
     convention used is that of OpenGL, matrix are column major and
     vector are columns, that is, should you do it on a paper, vector is
     placed vertically, on the right of matrix.  The other
     multiplication is not implemented, transposing the matrix will do
     it the other way if you wish.  The vector, here, is smaller than
     the matrix, the last element is supposed to be 1, this is how one
     implements translation through multiplication.

     *Return value:* none.

 -- Function: char * lw6mat_dmat4_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_dmat4_t * DMAT4)
     SYS_CONTEXT: global system context

     Gives a readable version of the matrix, the representation uses
     newlines, with a different line for each row

     *Return value:* newly allocated string

 -- Function: void lw6mat_dvec2_zero (lw6mat_dvec2_t * DVEC2)
     DVEC2: the vector to initialize.

     Fills the vector with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: int lw6mat_dvec2_is_same (const lw6mat_dvec2_t * DVEC2_A,
          const lw6mat_dvec2_t * DVEC2_B)
     DVEC2_A: 1st vector to compare

     DVEC2_B: 2nd vector to compare

     Compares two vectors, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: double lw6mat_dvec2_len_sq (const lw6mat_dvec2_t * DVEC2)
     DVEC2: the vector to query.

     Returns the square of a vector length.  To get the real length one
     should then apply a square root but at this stage one has at least
     an idea about vector length, and this information is enough to
     compare them.

     *Return value:* sigma(coord*coord)

 -- Function: double lw6mat_dvec2_len (const lw6mat_dvec2_t * DVEC2)
     DVEC2: the vector to query.

     Returns the size/length of a vector, this is the distance of the
     point from origin, not the number of elements.

     *Return value:* the length of the vector.

 -- Function: int lw6mat_dvec2_normalize (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_dvec2_t * DVEC2)
     SYS_CONTEXT: global system context

     DVEC2: the vector to normalize.

     Normalizes a vector, that is, make its length be 1.

     *Return value:* 1 if OK, 0 if error, such as trying to normalize
     vector zero.

 -- Function: int lw6mat_dvec2_homogeneous (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_dvec2_t * DVEC2)
     SYS_CONTEXT: global system context

     DVEC2: the vector to homogeneous.

     Transforms a vector into homegeneous coords, that is, scales it so
     that its last member is 1.

     *Return value:* 1 if OK, 0 if error, such as trying to operate on
     vector zero.

 -- Function: void lw6mat_dvec2_neg (lw6mat_dvec2_t * DVEC2)
     DVEC2: vector to modify

     Calcs the opposite vector, by making a negation on all its members

     *Return value:* none

 -- Function: void lw6mat_dvec2_add (lw6mat_dvec2_t * DVEC2, const
          lw6mat_dvec2_t * DVEC2_A, const lw6mat_dvec2_t * DVEC2_B)
     DVEC2: result vector

     DVEC2_A: 1st vector to add

     DVEC2_B: 2nd vector to add

     Adds two vectors.

     *Return value:* none

 -- Function: void lw6mat_dvec2_sub (lw6mat_dvec2_t * DVEC2, const
          lw6mat_dvec2_t * DVEC2_A, const lw6mat_dvec2_t * DVEC2_B)
     DVEC2: result vector

     DVEC2_A: 1st vector

     DVEC2_B: 2nd vector, will be substracted to 1st vector

     Substracts vector b from vector a.

     *Return value:* none

 -- Function: double lw6mat_dvec2_dot (const lw6mat_dvec2_t * DVEC2_A,
          const lw6mat_dvec2_t * DVEC2_B)
     DVEC2_A: 1st vector

     DVEC2_B: 2nd vector

     Calculates the dot AKA scalar product of the two vectors.

     *Return value:* none

 -- Function: void lw6mat_dvec2_cross (lw6mat_dvec3_t * DVEC3, const
          lw6mat_dvec2_t * DVEC2_A, const lw6mat_dvec2_t * DVEC2_B)
     DVEC3: result vector

     DVEC2_A: 1st vector

     DVEC2_B: 2nd vector

     Calculates the cross AKA vectorial product of the two vectors.
     Since cross product only really makes sense in 3D, this function
     will interpret the 2D vectors as 3D vectors with z set t zero, that
     is, a vector in the xy plane.

     *Return value:* none

 -- Function: void lw6mat_dvec2_mul_scale (lw6mat_dvec2_t * DVEC2,
          double F)
     DVEC2: vector to modify

     F: scale factor

     Scales the vector by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: void lw6mat_dvec2_mul_dvec2 (lw6mat_dmat2_t * DMAT2, const
          lw6mat_dvec2_t * DVEC2_A, const lw6mat_dvec2_t * DVEC2_B)
     DMAT2: result matrix

     DVEC2_A: 1st row vector

     DVEC2_B: 2nd column vector

     Multiplication of a row vector by a column vector to give a matrix.

     *Return value:* none

 -- Function: char * lw6mat_dvec2_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_dvec2_t * DVEC2)
     SYS_CONTEXT: global system context

     Gives a readable version of the vector

     *Return value:* newly allocated string

 -- Function: void lw6mat_dvec3_zero (lw6mat_dvec3_t * DVEC3)
     DVEC3: the vector to initialize.

     Fills the vector with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: int lw6mat_dvec3_is_same (const lw6mat_dvec3_t * DVEC3_A,
          const lw6mat_dvec3_t * DVEC3_B)
     DVEC3_A: 1st vector to compare

     DVEC3_B: 2nd vector to compare

     Compares two vectors, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: double lw6mat_dvec3_len_sq (const lw6mat_dvec3_t * DVEC3)
     DVEC3: the vector to query.

     Returns the square of a vector length.  To get the real length one
     should then apply a square root but at this stage one has at least
     an idea about vector length, and this information is enough to
     compare them.

     *Return value:* sigma(coord*coord)

 -- Function: double lw6mat_dvec3_len (const lw6mat_dvec3_t * DVEC3)
     DVEC3: the vector to query.

     Returns the size/length of a vector, this is the distance of the
     point from origin, not the number of elements.

     *Return value:* the length of the vector.

 -- Function: int lw6mat_dvec3_normalize (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_dvec3_t * DVEC3)
     SYS_CONTEXT: global system context

     DVEC3: the vector to normalize.

     Normalizes a vector, that is, make its length be 1.

     *Return value:* 1 if OK, 0 if error, such as trying to normalize
     vector zero.

 -- Function: int lw6mat_dvec3_homogeneous (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_dvec3_t * DVEC3)
     SYS_CONTEXT: global system context

     DVEC3: the vector to homogeneous.

     Transforms a vector into homegeneous coords, that is, scales it so
     that its last member is 1.

     *Return value:* 1 if OK, 0 if error, such as trying to operate on
     vector zero.

 -- Function: void lw6mat_dvec3_neg (lw6mat_dvec3_t * DVEC3)
     DVEC3: vector to modify

     Calcs the opposite vector, by making a negation on all its members

     *Return value:* none

 -- Function: void lw6mat_dvec3_add (lw6mat_dvec3_t * DVEC3, const
          lw6mat_dvec3_t * DVEC3_A, const lw6mat_dvec3_t * DVEC3_B)
     DVEC3: result vector

     DVEC3_A: 1st vector to add

     DVEC3_B: 2nd vector to add

     Adds two vectors.

     *Return value:* none

 -- Function: void lw6mat_dvec3_sub (lw6mat_dvec3_t * DVEC3, const
          lw6mat_dvec3_t * DVEC3_A, const lw6mat_dvec3_t * DVEC3_B)
     DVEC3: result vector

     DVEC3_A: 1st vector

     DVEC3_B: 2nd vector, will be substracted to 1st vector

     Substracts vector b from vector a.

     *Return value:* none

 -- Function: double lw6mat_dvec3_dot (const lw6mat_dvec3_t * DVEC3_A,
          const lw6mat_dvec3_t * DVEC3_B)
     DVEC3_A: 1st vector

     DVEC3_B: 2nd vector

     Calculates the dot AKA scalar product of the two vectors.

     *Return value:* none

 -- Function: void lw6mat_dvec3_cross (lw6mat_dvec3_t * DVEC3, const
          lw6mat_dvec3_t * DVEC3_A, const lw6mat_dvec3_t * DVEC3_B)
     DVEC3: result vector

     DVEC3_A: 1st vector

     DVEC3_B: 2nd vector

     Calculates the cross AKA vectorial product of the two vectors.

     *Return value:* none

 -- Function: void lw6mat_dvec3_mul_scale (lw6mat_dvec3_t * DVEC3,
          double F)
     DVEC3: vector to modify

     F: scale factor

     Scales the vector by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: void lw6mat_dvec3_mul_dvec3 (lw6mat_dmat3_t * DMAT3, const
          lw6mat_dvec3_t * DVEC3_A, const lw6mat_dvec3_t * DVEC3_B)
     DMAT3: result matrix

     DVEC3_A: 1st row vector

     DVEC3_B: 3nd column vector

     Multiplication of a row vector by a column vector to give a matrix.

     *Return value:* none

 -- Function: char * lw6mat_dvec3_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_dvec3_t * DVEC3)
     SYS_CONTEXT: global system context

     Gives a readable version of the vector

     *Return value:* newly allocated string

 -- Function: void lw6mat_dvec4_zero (lw6mat_dvec4_t * DVEC4)
     DVEC4: the vector to initialize.

     Fills the vector with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: int lw6mat_dvec4_is_same (const lw6mat_dvec4_t * DVEC4_A,
          const lw6mat_dvec4_t * DVEC4_B)
     DVEC4_A: 1st vector to compare

     DVEC4_B: 2nd vector to compare

     Compares two vectors, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: double lw6mat_dvec4_len_sq (const lw6mat_dvec4_t * DVEC4)
     DVEC4: the vector to query.

     Returns the square of a vector length.  To get the real length one
     should then apply a square root but at this stage one has at least
     an idea about vector length, and this information is enough to
     compare them.

     *Return value:* sigma(coord*coord)

 -- Function: double lw6mat_dvec4_len (const lw6mat_dvec4_t * DVEC4)
     DVEC4: the vector to query.

     Returns the size/length of a vector, this is the distance of the
     point from origin, not the number of elements.

     *Return value:* the length of the vector.

 -- Function: int lw6mat_dvec4_normalize (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_dvec4_t * DVEC4)
     SYS_CONTEXT: global system context

     DVEC4: the vector to normalize.

     Normalizes a vector, that is, make its length be 1.

     *Return value:* 1 if OK, 0 if error, such as trying to normalize
     vector zero.

 -- Function: int lw6mat_dvec4_homogeneous (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_dvec4_t * DVEC4)
     SYS_CONTEXT: global system context

     DVEC4: the vector to homogeneous.

     Transforms a vector into homegeneous coords, that is, scales it so
     that its last member is 1.

     *Return value:* 1 if OK, 0 if error, such as trying to operate on
     vector zero.

 -- Function: void lw6mat_dvec4_neg (lw6mat_dvec4_t * DVEC4)
     DVEC4: vector to modify

     Calcs the opposite vector, by making a negation on all its members

     *Return value:* none

 -- Function: void lw6mat_dvec4_add (lw6mat_dvec4_t * DVEC4, const
          lw6mat_dvec4_t * DVEC4_A, const lw6mat_dvec4_t * DVEC4_B)
     DVEC4: result vector

     DVEC4_A: 1st vector to add

     DVEC4_B: 2nd vector to add

     Adds two vectors.

     *Return value:* none

 -- Function: void lw6mat_dvec4_sub (lw6mat_dvec4_t * DVEC4, const
          lw6mat_dvec4_t * DVEC4_A, const lw6mat_dvec4_t * DVEC4_B)
     DVEC4: result vector

     DVEC4_A: 1st vector

     DVEC4_B: 2nd vector, will be substracted to 1st vector

     Substracts vector b from vector a.

     *Return value:* none

 -- Function: double lw6mat_dvec4_dot (const lw6mat_dvec4_t * DVEC4_A,
          const lw6mat_dvec4_t * DVEC4_B)
     DVEC4_A: 1st vector

     DVEC4_B: 2nd vector

     Calculates the dot AKA scalar product of the two vectors.

     *Return value:* none

 -- Function: void lw6mat_dvec4_cross (lw6mat_dvec3_t * DVEC3, const
          lw6mat_dvec4_t * DVEC4_A, const lw6mat_dvec4_t * DVEC4_B)
     DVEC3: result vector

     DVEC4_A: 1st vector

     DVEC4_B: 2nd vector

     Calculates the cross AKA vectorial product of the two vectors.
     Since cross product only really makes sense in 3D, this function
     will interpret the 4D vectors as 3D vectors only, ignoring the last
     value.

     *Return value:* none

 -- Function: void lw6mat_dvec4_mul_scale (lw6mat_dvec4_t * DVEC4,
          double F)
     DVEC4: vector to modify

     F: scale factor

     Scales the vector by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: void lw6mat_dvec4_mul_dvec4 (lw6mat_dmat4_t * DMAT4, const
          lw6mat_dvec4_t * DVEC4_A, const lw6mat_dvec4_t * DVEC4_B)
     DMAT4: result matrix

     DVEC4_A: 1st row vector

     DVEC4_B: 4nd column vector

     Multiplication of a row vector by a column vector to give a matrix.

     *Return value:* none

 -- Function: char * lw6mat_dvec4_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_dvec4_t * DVEC4)
     SYS_CONTEXT: global system context

     Gives a readable version of the vector

     *Return value:* newly allocated string

 -- Function: void lw6mat_fmat2_zero (lw6mat_fmat2_t * FMAT2)
     FMAT2: the matrix to initialize.

     Fills the matrix with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: void lw6mat_fmat2_identity (lw6mat_fmat2_t * FMAT2)
     FMAT2: the matrix to initialize.

     Loads the matrix with the identity matrix, that is, zero everywhere
     but one on the main diag.

     *Return value:* none.

 -- Function: void lw6mat_fmat2_translation (lw6mat_fmat2_t * FMAT2,
          float F)
     FMAT2: the matrix to initialize.

     F: value which defines the translation.

     Loads the matrix with a translation transformation matrix.  By
     multiplicating by this matrix, a translation is done.

     *Return value:* none.

 -- Function: void lw6mat_fmat2_scale (lw6mat_fmat2_t * FMAT2, float F)
     FMAT2: the matrix to initialize.

     F: value used to scale matrix.

     Loads the matrix with a scale matrix.  By multiplicating by this
     matrix, a scaling is done.

     *Return value:* none.

 -- Function: int lw6mat_fmat2_is_same (const lw6mat_fmat2_t * FMAT2_A,
          const lw6mat_fmat2_t * FMAT2_B)
     FMAT2_A: 1st matrix to compare

     FMAT2_B: 2nd matrix to compare

     Compares two matrix, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: void lw6mat_fmat2_transpose (lw6mat_fmat2_t * FMAT2)
     FMAT2: the matrix to transpose

     Transposes the matrix, that is, inverts rows and columns.

     *Return value:* none.

 -- Function: float lw6mat_fmat2_det (const lw6mat_fmat2_t * FMAT2)
     FMAT2: the matrix used to calculate the determinant

     Calulates the determinant of the matrix.

     *Return value:* the determinant.

 -- Function: void lw6mat_fmat2_mul_scale (lw6mat_fmat2_t * FMAT2, float
          F)
     FMAT2: matrix to modify

     F: scale factor

     Scales the matrix by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: int lw6mat_fmat2_inv (lw6sys_context_t * SYS_CONTEXT,
          lw6mat_fmat2_t * FMAT2_DST, const lw6mat_fmat2_t * FMAT2_SRC)
     SYS_CONTEXT: global system context

     FMAT2_DST: the matrix inverted

     FMAT2_SRC: the matrix to invert

     Inverts a matrix.  Probably not the fastest implementation, but
     should work in all cases.  Use hardware accelerated API such as
     OpenGL on dedicated hardware if you want power.

     *Return value:* 1 if inverted, 0 if error, typically if determinant
     was 0, matrix can not be inverted.

 -- Function: void lw6mat_fmat2_mul_fmat2 (lw6mat_fmat2_t * FMAT2, const
          lw6mat_fmat2_t * FMAT2_A, const lw6mat_fmat2_t * FMAT2_B)
     FMAT2: the result matrix

     FMAT2_A: the 1st matrix to multiply, on the left

     FMAT2_B: the 2nd matrix to multiply, on the right

     Classic matrix multiplication.

     *Return value:* none.

 -- Function: void lw6mat_fmat2_mul_fvec2 (lw6mat_fvec2_t * FVEC2_DST,
          const lw6mat_fmat2_t * FMAT2, const lw6mat_fvec2_t *
          FVEC2_SRC)
     FVEC2_DST: the result vector

     FVEC2_SRC: the source vector

     Multiplication of matrix by vector.  The result is a vector, the
     convention used is that of OpenGL, matrix are column major and
     vector are columns, that is, should you do it on a paper, vector is
     placed vertically, on the right of matrix.  The other
     multiplication is not implemented, transposing the matrix will do
     it the other way if you wish.

     *Return value:* none.

 -- Function: char * lw6mat_fmat2_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_fmat2_t * FMAT2)
     SYS_CONTEXT: global system context

     Gives a readable version of the matrix, the representation uses
     newlines, with a different line for each row

     *Return value:* newly allocated string

 -- Function: void lw6mat_fmat3_zero (lw6mat_fmat3_t * FMAT3)
     FMAT3: the matrix to initialize.

     Fills the matrix with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: void lw6mat_fmat3_identity (lw6mat_fmat3_t * FMAT3)
     FMAT3: the matrix to initialize.

     Loads the matrix with the identity matrix, that is, zero everywhere
     but one on the main diag.

     *Return value:* none.

 -- Function: void lw6mat_fmat3_translation (lw6mat_fmat3_t * FMAT3,
          const lw6mat_fvec2_t * FVEC2)
     FMAT3: the matrix to initialize.

     FVEC2: vector which defines the translation.

     Loads the matrix with a translation transformation matrix.  By
     multiplicating by this matrix, a translation is done.

     *Return value:* none.

 -- Function: void lw6mat_fmat3_scale (lw6mat_fmat3_t * FMAT3, const
          lw6mat_fvec2_t * FVEC2)
     FMAT3: the matrix to initialize.

     FVEC2: value used to scale matrix.

     Loads the matrix with a scale matrix.  By multiplicating by this
     matrix, a scaling is done.

     *Return value:* none.

 -- Function: void lw6mat_fmat3_rot (lw6mat_fmat3_t * FMAT3, float R)
     FMAT3: the matrix to initialize.

     R: value used to for the rotation, angle in radians.

     Loads the matrix with a rotation matrix.  By multiplicating by this
     matrix, a rotation is done, over a virtual Z axis such as Z is the
     cross product of X and Y.

     *Return value:* none.

 -- Function: int lw6mat_fmat3_is_same (const lw6mat_fmat3_t * FMAT3_A,
          const lw6mat_fmat3_t * FMAT3_B)
     FMAT3_A: 1st matrix to compare

     FMAT3_B: 2nd matrix to compare

     Compares two matrix, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: void lw6mat_fmat3_transpose (lw6mat_fmat3_t * FMAT3)
     FMAT3: the matrix to transpose

     Transposes the matrix, that is, inverts rows and columns.

     *Return value:* none.

 -- Function: float lw6mat_fmat3_det (const lw6mat_fmat3_t * FMAT3)
     FMAT3: the matrix used to calculate the determinant

     Calulates the determinant of the matrix.

     *Return value:* the determinant.

 -- Function: void lw6mat_fmat3_mul_scale (lw6mat_fmat3_t * FMAT3, float
          F)
     FMAT3: matrix to modify

     F: scale factor

     Scales the matrix by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: int lw6mat_fmat3_inv (lw6sys_context_t * SYS_CONTEXT,
          lw6mat_fmat3_t * FMAT3_DST, const lw6mat_fmat3_t * FMAT3_SRC)
     SYS_CONTEXT: global system context

     FMAT3_DST: the matrix inverted

     FMAT3_SRC: the matrix to invert

     Inverts a matrix.  Probably not the fastest implementation, but
     should work in all cases.  Use hardware accelerated API such as
     OpenGL on dedicated hardware if you want power.

     *Return value:* 1 if inverted, 0 if error, typically if determinant
     was 0, matrix can not be inverted.

 -- Function: void lw6mat_fmat3_mul_fmat3 (lw6mat_fmat3_t * FMAT3, const
          lw6mat_fmat3_t * FMAT3_A, const lw6mat_fmat3_t * FMAT3_B)
     FMAT3: the result matrix

     FMAT3_A: the 1st matrix to multiply, on the left

     FMAT3_B: the 2nd matrix to multiply, on the right

     Classic matrix multiplication.

     *Return value:* none.

 -- Function: void lw6mat_fmat3_mul_fvec3 (lw6mat_fvec3_t * FVEC3_DST,
          const lw6mat_fmat3_t * FMAT3, const lw6mat_fvec3_t *
          FVEC3_SRC)
     FVEC3_DST: the result vector

     FVEC3_SRC: the source vector

     Multiplication of matrix by vector.  The result is a vector, the
     convention used is that of OpenGL, matrix are column major and
     vector are columns, that is, should you do it on a paper, vector is
     placed vertically, on the right of matrix.  The other
     multiplication is not implemented, transposing the matrix will do
     it the other way if you wish.

     *Return value:* none.

 -- Function: void lw6mat_fmat3_mul_fvec2 (lw6mat_fvec2_t * FVEC2_DST,
          const lw6mat_fmat3_t * FMAT3, const lw6mat_fvec2_t *
          FVEC2_SRC)
     FVEC2_DST: the result vector

     Multiplication of matrix by vector.  The result is a vector, the
     convention used is that of OpenGL, matrix are column major and
     vector are columns, that is, should you do it on a paper, vector is
     placed vertically, on the right of matrix.  The other
     multiplication is not implemented, transposing the matrix will do
     it the other way if you wish.  The vector, here, is smaller than
     the matrix, the last element is supposed to be 1, this is how one
     implements translation through multiplication.

     *Return value:* none.

 -- Function: char * lw6mat_fmat3_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_fmat3_t * FMAT3)
     SYS_CONTEXT: global system context

     Gives a readable version of the matrix, the representation uses
     newlines, with a different line for each row

     *Return value:* newly allocated string

 -- Function: void lw6mat_fmat4_zero (lw6mat_fmat4_t * FMAT4)
     FMAT4: the matrix to initialize.

     Fills the matrix with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: void lw6mat_fmat4_identity (lw6mat_fmat4_t * FMAT4)
     FMAT4: the matrix to initialize.

     Loads the matrix with the identity matrix, that is, zero everywhere
     but one on the main diag.

     *Return value:* none.

 -- Function: void lw6mat_fmat4_translation (lw6mat_fmat4_t * FMAT4,
          const lw6mat_fvec3_t * FVEC3)
     FMAT4: the matrix to initialize.

     FVEC3: vector which defines the translation.

     Loads the matrix with a translation transformation matrix.  By
     multiplicating by this matrix, a translation is done.

     *Return value:* none.

 -- Function: void lw6mat_fmat4_scale (lw6mat_fmat4_t * FMAT4, const
          lw6mat_fvec3_t * FVEC3)
     FMAT4: the matrix to initialize.

     FVEC3: value used to scale matrix.

     Loads the matrix with a scale matrix.  By multiplicating by this
     matrix, a scaling is done.

     *Return value:* none.

 -- Function: void lw6mat_fmat4_rot_x (lw6mat_fmat4_t * FMAT4, float R)
     FMAT4: the matrix to initialize.

     R: value used to for the rotation, angle in radians.

     Loads the matrix with a rotation matrix.  By multiplicating by this
     matrix, a rotation is done, over the X axis.

     *Return value:* none.

 -- Function: void lw6mat_fmat4_rot_y (lw6mat_fmat4_t * FMAT4, float R)
     FMAT4: the matrix to initialize.

     R: value used to for the rotation, angle in radians.

     Loads the matrix with a rotation matrix.  By multiplicating by this
     matrix, a rotation is done, over the Y axis.

     *Return value:* none.

 -- Function: void lw6mat_fmat4_rot_z (lw6mat_fmat4_t * FMAT4, float R)
     FMAT4: the matrix to initialize.

     R: value used to for the rotation, angle in radians.

     Loads the matrix with a rotation matrix.  By multiplicating by this
     matrix, a rotation is done, over the Z axis.

     *Return value:* none.

 -- Function: void lw6mat_fmat4_ortho (lw6mat_fmat4_t * FMAT4, float
          LEFT, float RIGHT, float BOTTOM, float TOP, float NEARVAL,
          float FARVAL)
     FMAT4: the matrix to initialize.

     LEFT: left plane coordinate

     RIGHT: right plane coordinate

     BOTTOM: bottom plane coordinate

     TOP: top plane coordinate

     NEARVAL: near plane coordinate

     FARVAL: far plane coordinate

     Loads the matrix with an orthogonal projection matrix.  Does it the
     way glOrtho would, see
     https://www.opengl.org/sdk/docs/man2/xhtml/glOrtho.xml for details.

     *Note:* use -nearVal and -farVal to initialize.  It's a little
     akward, if you expect to pass vectors with positions ranging from
     nearVal to farVal then you need to pass -nearVal and -farVal to
     this function.  This is probably due to the fact that with a
     right-handed basis and X,Y set up "as usual", then Z is negative
     when going farther and farther.  This tweak allows farVal to yield
     +1 and nearVal -1.  We keep this function as is here, as this is
     the way OpenGL functions seem to work.

     *Return value:* none.

 -- Function: void lw6mat_fmat4_perspective (lw6mat_fmat4_t * FMAT4,
          float FOVY, float ASPECT, float ZNEAR, float ZFAR)
     FMAT4: the matrix to initialize.

     FOVY: vertical field of view (degrees, not radians)

     ASPECT: x/y ratio

     ZNEAR: near plane coordinate (use -znear to initialize)

     ZFAR: far plane coordinate (use -zfar to initialize)

     Loads the matrix with a projection matrix.  Does it the way
     gluPerspective would, see
     https://www.opengl.org/sdk/docs/man2/xhtml/gluPerspective.xml for
     details.

     *Return value:* none.

 -- Function: int lw6mat_fmat4_is_same (const lw6mat_fmat4_t * FMAT4_A,
          const lw6mat_fmat4_t * FMAT4_B)
     FMAT4_A: 1st matrix to compare

     FMAT4_B: 2nd matrix to compare

     Compares two matrix, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: void lw6mat_fmat4_transpose (lw6mat_fmat4_t * FMAT4)
     FMAT4: the matrix to transpose

     Transposes the matrix, that is, inverts rows and columns.

     *Return value:* none.

 -- Function: float lw6mat_fmat4_det (const lw6mat_fmat4_t * FMAT4)
     FMAT4: the matrix used to calculate the determinant

     Calulates the determinant of the matrix.

     *Return value:* the determinant.

 -- Function: void lw6mat_fmat4_mul_scale (lw6mat_fmat4_t * FMAT4, float
          F)
     FMAT4: matrix to modify

     F: scale factor

     Scales the matrix by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: int lw6mat_fmat4_inv (lw6sys_context_t * SYS_CONTEXT,
          lw6mat_fmat4_t * FMAT4_DST, const lw6mat_fmat4_t * FMAT4_SRC)
     SYS_CONTEXT: global system context

     FMAT4_DST: the matrix inverted

     FMAT4_SRC: the matrix to invert

     Inverts a matrix.  Probably not the fastest implementation, but
     should work in all cases.  Use hardware accelerated API such as
     OpenGL on dedicated hardware if you want power.

     *Return value:* 1 if inverted, 0 if error, typically if determinant
     was 0, matrix can not be inverted.

 -- Function: void lw6mat_fmat4_mul_fmat4 (lw6mat_fmat4_t * FMAT4, const
          lw6mat_fmat4_t * FMAT4_A, const lw6mat_fmat4_t * FMAT4_B)
     FMAT4: the result matrix

     FMAT4_A: the 1st matrix to multiply, on the left

     FMAT4_B: the 2nd matrix to multiply, on the right

     Classic matrix multiplication.

     *Return value:* none.

 -- Function: void lw6mat_fmat4_mul_fvec4 (lw6mat_fvec4_t * FVEC4_DST,
          const lw6mat_fmat4_t * FMAT4, const lw6mat_fvec4_t *
          FVEC4_SRC)
     FVEC4_DST: the result vector

     FMAT4: the matrix to use

     FVEC4_SRC: the source vector

     Multiplication of matrix by vector.  The result is a vector, the
     convention used is that of OpenGL, matrix are column major and
     vector are columns, that is, should you do it on a paper, vector is
     placed vertically, on the right of matrix.  The other
     multiplication is not implemented, transposing the matrix will do
     it the other way if you wish.

     *Return value:* none.

 -- Function: void lw6mat_fmat4_mul_fvec3 (lw6mat_fvec3_t * FVEC3_DST,
          const lw6mat_fmat4_t * FMAT4, const lw6mat_fvec3_t *
          FVEC3_SRC)
     FVEC3_DST: the result vector

     FMAT4: the matrix to use

     FVEC3_SRC: the source vector

     Multiplication of matrix by vector.  The result is a vector, the
     convention used is that of OpenGL, matrix are column major and
     vector are columns, that is, should you do it on a paper, vector is
     placed vertically, on the right of matrix.  The other
     multiplication is not implemented, transposing the matrix will do
     it the other way if you wish.  The vector, here, is smaller than
     the matrix, the last element is supposed to be 1, this is how one
     implements translation through multiplication.

     *Return value:* none.

 -- Function: char * lw6mat_fmat4_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_fmat4_t * FMAT4)
     SYS_CONTEXT: global system context

     Gives a readable version of the matrix, the representation uses
     newlines, with a different line for each row

     *Return value:* newly allocated string

 -- Function: void lw6mat_fvec2_zero (lw6mat_fvec2_t * FVEC2)
     FVEC2: the vector to initialize.

     Fills the vector with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: int lw6mat_fvec2_is_same (const lw6mat_fvec2_t * FVEC2_A,
          const lw6mat_fvec2_t * FVEC2_B)
     FVEC2_A: 1st vector to compare

     FVEC2_B: 2nd vector to compare

     Compares two vectors, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: float lw6mat_fvec2_len_sq (const lw6mat_fvec2_t * FVEC2)
     FVEC2: the vector to query.

     Returns the square of a vector length.  To get the real length one
     should then apply a square root but at this stage one has at least
     an idea about vector length, and this information is enough to
     compare them.

     *Return value:* sigma(coord*coord)

 -- Function: float lw6mat_fvec2_len (const lw6mat_fvec2_t * FVEC2)
     FVEC2: the vector to query.

     Returns the size/length of a vector, this is the distance of the
     point from origin, not the number of elements.

     *Return value:* the length of the vector.

 -- Function: int lw6mat_fvec2_normalize (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_fvec2_t * FVEC2)
     SYS_CONTEXT: global system context

     FVEC2: the vector to normalize.

     Normalizes a vector, that is, make its length be 1.

     *Return value:* 1 if OK, 0 if error, such as trying to normalize
     vector zero.

 -- Function: int lw6mat_fvec2_homogeneous (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_fvec2_t * FVEC2)
     SYS_CONTEXT: global system context

     FVEC2: the vector to homogeneous.

     Transforms a vector into homegeneous coords, that is, scales it so
     that its last member is 1.

     *Return value:* 1 if OK, 0 if error, such as trying to operate on
     vector zero.

 -- Function: void lw6mat_fvec2_neg (lw6mat_fvec2_t * FVEC2)
     FVEC2: vector to modify

     Calcs the opposite vector, by making a negation on all its members

     *Return value:* none

 -- Function: void lw6mat_fvec2_add (lw6mat_fvec2_t * FVEC2, const
          lw6mat_fvec2_t * FVEC2_A, const lw6mat_fvec2_t * FVEC2_B)
     FVEC2: result vector

     FVEC2_A: 1st vector to add

     FVEC2_B: 2nd vector to add

     Adds two vectors.

     *Return value:* none

 -- Function: void lw6mat_fvec2_sub (lw6mat_fvec2_t * FVEC2, const
          lw6mat_fvec2_t * FVEC2_A, const lw6mat_fvec2_t * FVEC2_B)
     FVEC2: result vector

     FVEC2_A: 1st vector

     FVEC2_B: 2nd vector, will be substracted to 1st vector

     Substracts vector b from vector a.

     *Return value:* none

 -- Function: float lw6mat_fvec2_dot (const lw6mat_fvec2_t * FVEC2_A,
          const lw6mat_fvec2_t * FVEC2_B)
     FVEC2_A: 1st vector

     FVEC2_B: 2nd vector

     Calculates the dot AKA scalar product of the two vectors.

     *Return value:* none

 -- Function: void lw6mat_fvec2_cross (lw6mat_fvec3_t * FVEC3, const
          lw6mat_fvec2_t * FVEC2_A, const lw6mat_fvec2_t * FVEC2_B)
     FVEC3: result vector

     FVEC2_A: 1st vector

     FVEC2_B: 2nd vector

     Calculates the cross AKA vectorial product of the two vectors.
     Since cross product only really makes sense in 3D, this function
     will interpret the 2D vectors as 3D vectors with z set t zero, that
     is, a vector in the xy plane.

     *Return value:* none

 -- Function: void lw6mat_fvec2_mul_scale (lw6mat_fvec2_t * FVEC2, float
          F)
     FVEC2: vector to modify

     F: scale factor

     Scales the vector by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: void lw6mat_fvec2_mul_fvec2 (lw6mat_fmat2_t * FMAT2, const
          lw6mat_fvec2_t * FVEC2_A, const lw6mat_fvec2_t * FVEC2_B)
     FMAT2: result matrix

     FVEC2_A: 1st row vector

     FVEC2_B: 2nd column vector

     Multiplication of a row vector by a column vector to give a matrix.

     *Return value:* none

 -- Function: char * lw6mat_fvec2_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_fvec2_t * FVEC2)
     SYS_CONTEXT: global system context

     Gives a readable version of the vector

     *Return value:* newly allocated string

 -- Function: void lw6mat_fvec3_zero (lw6mat_fvec3_t * FVEC3)
     FVEC3: the vector to initialize.

     Fills the vector with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: int lw6mat_fvec3_is_same (const lw6mat_fvec3_t * FVEC3_A,
          const lw6mat_fvec3_t * FVEC3_B)
     FVEC3_A: 1st vector to compare

     FVEC3_B: 2nd vector to compare

     Compares two vectors, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: float lw6mat_fvec3_len_sq (const lw6mat_fvec3_t * FVEC3)
     FVEC3: the vector to query.

     Returns the square of a vector length.  To get the real length one
     should then apply a square root but at this stage one has at least
     an idea about vector length, and this information is enough to
     compare them.

     *Return value:* sigma(coord*coord)

 -- Function: float lw6mat_fvec3_len (const lw6mat_fvec3_t * FVEC3)
     FVEC3: the vector to query.

     Returns the size/length of a vector, this is the distance of the
     point from origin, not the number of elements.

     *Return value:* the length of the vector.

 -- Function: int lw6mat_fvec3_normalize (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_fvec3_t * FVEC3)
     SYS_CONTEXT: global system context

     FVEC3: the vector to normalize.

     Normalizes a vector, that is, make its length be 1.

     *Return value:* 1 if OK, 0 if error, such as trying to normalize
     vector zero.

 -- Function: int lw6mat_fvec3_homogeneous (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_fvec3_t * FVEC3)
     SYS_CONTEXT: global system context

     FVEC3: the vector to homogeneous.

     Transforms a vector into homegeneous coords, that is, scales it so
     that its last member is 1.

     *Return value:* 1 if OK, 0 if error, such as trying to operate on
     vector zero.

 -- Function: void lw6mat_fvec3_neg (lw6mat_fvec3_t * FVEC3)
     FVEC3: vector to modify

     Calcs the opposite vector, by making a negation on all its members

     *Return value:* none

 -- Function: void lw6mat_fvec3_add (lw6mat_fvec3_t * FVEC3, const
          lw6mat_fvec3_t * FVEC3_A, const lw6mat_fvec3_t * FVEC3_B)
     FVEC3: result vector

     FVEC3_A: 1st vector to add

     FVEC3_B: 2nd vector to add

     Adds two vectors.

     *Return value:* none

 -- Function: void lw6mat_fvec3_sub (lw6mat_fvec3_t * FVEC3, const
          lw6mat_fvec3_t * FVEC3_A, const lw6mat_fvec3_t * FVEC3_B)
     FVEC3: result vector

     FVEC3_A: 1st vector

     FVEC3_B: 2nd vector, will be substracted to 1st vector

     Substracts vector b from vector a.

     *Return value:* none

 -- Function: float lw6mat_fvec3_dot (const lw6mat_fvec3_t * FVEC3_A,
          const lw6mat_fvec3_t * FVEC3_B)
     FVEC3_A: 1st vector

     FVEC3_B: 2nd vector

     Calculates the dot AKA scalar product of the two vectors.

     *Return value:* none

 -- Function: void lw6mat_fvec3_cross (lw6mat_fvec3_t * FVEC3, const
          lw6mat_fvec3_t * FVEC3_A, const lw6mat_fvec3_t * FVEC3_B)
     FVEC3: result vector

     FVEC3_A: 1st vector

     FVEC3_B: 2nd vector

     Calculates the cross AKA vectorial product of the two vectors.

     *Return value:* none

 -- Function: void lw6mat_fvec3_mul_scale (lw6mat_fvec3_t * FVEC3, float
          F)
     FVEC3: vector to modify

     F: scale factor

     Scales the vector by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: void lw6mat_fvec3_mul_fvec3 (lw6mat_fmat3_t * FMAT3, const
          lw6mat_fvec3_t * FVEC3_A, const lw6mat_fvec3_t * FVEC3_B)
     FMAT3: result matrix

     FVEC3_A: 1st row vector

     FVEC3_B: 3nd column vector

     Multiplication of a row vector by a column vector to give a matrix.

     *Return value:* none

 -- Function: char * lw6mat_fvec3_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_fvec3_t * FVEC3)
     SYS_CONTEXT: global system context

     Gives a readable version of the vector

     *Return value:* newly allocated string

 -- Function: void lw6mat_fvec4_zero (lw6mat_fvec4_t * FVEC4)
     FVEC4: the vector to initialize.

     Fills the vector with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: int lw6mat_fvec4_is_same (const lw6mat_fvec4_t * FVEC4_A,
          const lw6mat_fvec4_t * FVEC4_B)
     FVEC4_A: 1st vector to compare

     FVEC4_B: 2nd vector to compare

     Compares two vectors, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: float lw6mat_fvec4_len_sq (const lw6mat_fvec4_t * FVEC4)
     FVEC4: the vector to query.

     Returns the square of a vector length.  To get the real length one
     should then apply a square root but at this stage one has at least
     an idea about vector length, and this information is enough to
     compare them.

     *Return value:* sigma(coord*coord)

 -- Function: float lw6mat_fvec4_len (const lw6mat_fvec4_t * FVEC4)
     FVEC4: the vector to query.

     Returns the size/length of a vector, this is the distance of the
     point from origin, not the number of elements.

     *Return value:* the length of the vector.

 -- Function: int lw6mat_fvec4_normalize (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_fvec4_t * FVEC4)
     SYS_CONTEXT: global system context

     FVEC4: the vector to normalize.

     Normalizes a vector, that is, make its length be 1.

     *Return value:* 1 if OK, 0 if error, such as trying to normalize
     vector zero.

 -- Function: int lw6mat_fvec4_homogeneous (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_fvec4_t * FVEC4)
     SYS_CONTEXT: global system context

     FVEC4: the vector to homogeneous.

     Transforms a vector into homegeneous coords, that is, scales it so
     that its last member is 1.

     *Return value:* 1 if OK, 0 if error, such as trying to operate on
     vector zero.

 -- Function: void lw6mat_fvec4_neg (lw6mat_fvec4_t * FVEC4)
     FVEC4: vector to modify

     Calcs the opposite vector, by making a negation on all its members

     *Return value:* none

 -- Function: void lw6mat_fvec4_add (lw6mat_fvec4_t * FVEC4, const
          lw6mat_fvec4_t * FVEC4_A, const lw6mat_fvec4_t * FVEC4_B)
     FVEC4: result vector

     FVEC4_A: 1st vector to add

     FVEC4_B: 2nd vector to add

     Adds two vectors.

     *Return value:* none

 -- Function: void lw6mat_fvec4_sub (lw6mat_fvec4_t * FVEC4, const
          lw6mat_fvec4_t * FVEC4_A, const lw6mat_fvec4_t * FVEC4_B)
     FVEC4: result vector

     FVEC4_A: 1st vector

     FVEC4_B: 2nd vector, will be substracted to 1st vector

     Substracts vector b from vector a.

     *Return value:* none

 -- Function: float lw6mat_fvec4_dot (const lw6mat_fvec4_t * FVEC4_A,
          const lw6mat_fvec4_t * FVEC4_B)
     FVEC4_A: 1st vector

     FVEC4_B: 2nd vector

     Calculates the dot AKA scalar product of the two vectors.

     *Return value:* none

 -- Function: void lw6mat_fvec4_cross (lw6mat_fvec3_t * FVEC3, const
          lw6mat_fvec4_t * FVEC4_A, const lw6mat_fvec4_t * FVEC4_B)
     FVEC3: result vector

     FVEC4_A: 1st vector

     FVEC4_B: 2nd vector

     Calculates the cross AKA vectorial product of the two vectors.
     Since cross product only really makes sense in 3D, this function
     will interpret the 4D vectors as 3D vectors only, ignoring the last
     value.

     *Return value:* none

 -- Function: void lw6mat_fvec4_mul_scale (lw6mat_fvec4_t * FVEC4, float
          F)
     FVEC4: vector to modify

     F: scale factor

     Scales the vector by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: void lw6mat_fvec4_mul_fvec4 (lw6mat_fmat4_t * FMAT4, const
          lw6mat_fvec4_t * FVEC4_A, const lw6mat_fvec4_t * FVEC4_B)
     FMAT4: result matrix

     FVEC4_A: 1st row vector

     FVEC4_B: 4nd column vector

     Multiplication of a row vector by a column vector to give a matrix.

     *Return value:* none

 -- Function: char * lw6mat_fvec4_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_fvec4_t * FVEC4)
     SYS_CONTEXT: global system context

     Gives a readable version of the vector

     *Return value:* newly allocated string

 -- Function: int lw6mat_is_similar_f (float F_A, float F_B)
     F_A: 1st value to compare

     F_B: 2nd value to compare

     Compares two value, and returns true if they look the same.  This
     similarity is based on a percentage of difference for big enough
     values, and for very small values, they are just considered equal
     whatever happens.  This is far from perfect but the purpose is
     usually just to track blunders in matrix code.

     *Return value:* 1 if similar, 0 if not.

 -- Function: int lw6mat_is_similar_i (int32_t I_A, int32_t I_B)
     I_A: 1st value to compare

     I_B: 2nd value to compare

     Compares two value, and returns true if they look the same.  This
     similarity is based on a percentage of difference for big enough
     values, and for very small values, they are just considered equal
     whatever happens.  This is far from perfect but the purpose is
     usually just to track blunders in matrix code.

     *Return value:* 1 if similar, 0 if not.

 -- Function: int lw6mat_is_similar_d (double D_A, double D_B)
     D_A: 1st value to compare

     D_B: 2nd value to compare

     Compares two value, and returns true if they look the same.  This
     similarity is based on a percentage of difference for big enough
     values, and for very small values, they are just considered equal
     whatever happens.  This is far from perfect but the purpose is
     usually just to track blunders in matrix code.

     *Return value:* 1 if similar, 0 if not.

 -- Function: int lw6mat_is_similar_x (int32_t X_A, int32_t X_B)
     X_A: 1st value to compare

     X_B: 2nd value to compare

     Compares two value, and returns true if they look the same.  This
     similarity is based on a percentage of difference for big enough
     values, and for very small values, they are just considered equal
     whatever happens.  This is far from perfect but the purpose is
     usually just to track blunders in matrix code.

     *Return value:* 1 if similar, 0 if not.

 -- Function: int lw6mat_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libmat module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6mat_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'mat' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6mat_dmat2_t

     Double 2x2 matrix (AKA 2D rectangle).

 -- Member of lw6mat_dmat2_t: m
     *Type:* 'double'

     *Definition:* 'double
     lw6mat_dmat2_t::m[LW6MAT_MAT2_M_SIZE][LW6MAT_MAT2_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_dmat2_t: v
     *Type:* 'double'

     *Definition:* 'double lw6mat_dmat2_t::v[LW6MAT_MAT2_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*2+j.

 -- Struct: lw6mat_dmat3_t

     Double 3x3 matrix (AKA 3D triangle).

 -- Member of lw6mat_dmat3_t: m
     *Type:* 'double'

     *Definition:* 'double
     lw6mat_dmat3_t::m[LW6MAT_MAT3_M_SIZE][LW6MAT_MAT3_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_dmat3_t: v
     *Type:* 'double'

     *Definition:* 'double lw6mat_dmat3_t::v[LW6MAT_MAT3_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*3+j.

 -- Struct: lw6mat_dmat4_t

     Double 4x4 matrix (AKA 3D transformation/composition matrix).

 -- Member of lw6mat_dmat4_t: m
     *Type:* 'double'

     *Definition:* 'double
     lw6mat_dmat4_t::m[LW6MAT_MAT4_M_SIZE][LW6MAT_MAT4_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_dmat4_t: v
     *Type:* 'double'

     *Definition:* 'double lw6mat_dmat4_t::v[LW6MAT_MAT4_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*4+j.

 -- Struct: lw6mat_dvec2_t

     Double vector with 2 elements (AKA 2D point).

 -- Member of lw6mat_dvec2_t: x
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec2_t::x'

 -- Member of lw6mat_dvec2_t: y
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec2_t::y'

 -- Member of lw6mat_dvec2_t: p
     *Type:* 'struct lw6mat_dvec2_t::16'

     *Definition:* 'struct lw6mat_dvec2_t::16 lw6mat_dvec2_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_dvec2_t: s
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec2_t::s'

 -- Member of lw6mat_dvec2_t: t
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec2_t::t'

 -- Member of lw6mat_dvec2_t: t
     *Type:* 'struct lw6mat_dvec2_t::17'

     *Definition:* 'struct lw6mat_dvec2_t::17 lw6mat_dvec2_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_dvec2_t: v
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec2_t::v[LW6MAT_VEC2_V_SIZE]'

     Accessor with array index.

 -- Struct: lw6mat_dvec3_t

     Double vector with 3 elements (AKA 3D point).

 -- Member of lw6mat_dvec3_t: x
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec3_t::x'

 -- Member of lw6mat_dvec3_t: y
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec3_t::y'

 -- Member of lw6mat_dvec3_t: z
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec3_t::z'

 -- Member of lw6mat_dvec3_t: p
     *Type:* 'struct lw6mat_dvec3_t::18'

     *Definition:* 'struct lw6mat_dvec3_t::18 lw6mat_dvec3_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_dvec3_t: r
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec3_t::r'

 -- Member of lw6mat_dvec3_t: g
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec3_t::g'

 -- Member of lw6mat_dvec3_t: b
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec3_t::b'

 -- Member of lw6mat_dvec3_t: c
     *Type:* 'struct lw6mat_dvec3_t::19'

     *Definition:* 'struct lw6mat_dvec3_t::19 lw6mat_dvec3_t::c'

     Accessor with color-like name.

 -- Member of lw6mat_dvec3_t: s
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec3_t::s'

 -- Member of lw6mat_dvec3_t: t
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec3_t::t'

 -- Member of lw6mat_dvec3_t: p
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec3_t::p'

 -- Member of lw6mat_dvec3_t: t
     *Type:* 'struct lw6mat_dvec3_t::20'

     *Definition:* 'struct lw6mat_dvec3_t::20 lw6mat_dvec3_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_dvec3_t: v
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec3_t::v[LW6MAT_VEC3_V_SIZE]'

     Accessor with array index.

 -- Member of lw6mat_dvec3_t: v2
     *Type:* 'lw6mat_dvec2_t'

     *Definition:* 'lw6mat_dvec2_t lw6mat_dvec3_t::v2'

     Accessor with smaller-sized vector, only 2 dimensions.

 -- Struct: lw6mat_dvec4_t

     Double vector with 4 elements (AKA quaternion).

 -- Member of lw6mat_dvec4_t: x
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::x'

 -- Member of lw6mat_dvec4_t: y
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::y'

 -- Member of lw6mat_dvec4_t: z
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::z'

 -- Member of lw6mat_dvec4_t: w
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::w'

 -- Member of lw6mat_dvec4_t: p
     *Type:* 'struct lw6mat_dvec4_t::21'

     *Definition:* 'struct lw6mat_dvec4_t::21 lw6mat_dvec4_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_dvec4_t: r
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::r'

 -- Member of lw6mat_dvec4_t: g
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::g'

 -- Member of lw6mat_dvec4_t: b
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::b'

 -- Member of lw6mat_dvec4_t: a
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::a'

 -- Member of lw6mat_dvec4_t: c
     *Type:* 'struct lw6mat_dvec4_t::22'

     *Definition:* 'struct lw6mat_dvec4_t::22 lw6mat_dvec4_t::c'

     Accessor with color-like name.

 -- Member of lw6mat_dvec4_t: s
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::s'

 -- Member of lw6mat_dvec4_t: t
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::t'

 -- Member of lw6mat_dvec4_t: p
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::p'

 -- Member of lw6mat_dvec4_t: q
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::q'

 -- Member of lw6mat_dvec4_t: t
     *Type:* 'struct lw6mat_dvec4_t::23'

     *Definition:* 'struct lw6mat_dvec4_t::23 lw6mat_dvec4_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_dvec4_t: v
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::v[LW6MAT_VEC4_V_SIZE]'

     Accessor with array index.

 -- Member of lw6mat_dvec4_t: v2
     *Type:* 'lw6mat_dvec2_t'

     *Definition:* 'lw6mat_dvec2_t lw6mat_dvec4_t::v2'

     Accessor with smaller-sized vector, only 2 dimensions.

 -- Member of lw6mat_dvec4_t: v3
     *Type:* 'lw6mat_dvec3_t'

     *Definition:* 'lw6mat_dvec3_t lw6mat_dvec4_t::v3'

     Accessor with smaller-sized vector, only 3 dimensions.

 -- Struct: lw6mat_fmat2_t

     Float 2x2 matrix (AKA 2D rectangle).

 -- Member of lw6mat_fmat2_t: m
     *Type:* 'float'

     *Definition:* 'float
     lw6mat_fmat2_t::m[LW6MAT_MAT2_M_SIZE][LW6MAT_MAT2_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_fmat2_t: v
     *Type:* 'float'

     *Definition:* 'float lw6mat_fmat2_t::v[LW6MAT_MAT2_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*4+j.

 -- Struct: lw6mat_fmat3_t

     Float 3x3 matrix (AKA 3D triangle).

 -- Member of lw6mat_fmat3_t: m
     *Type:* 'float'

     *Definition:* 'float
     lw6mat_fmat3_t::m[LW6MAT_MAT3_M_SIZE][LW6MAT_MAT3_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_fmat3_t: v
     *Type:* 'float'

     *Definition:* 'float lw6mat_fmat3_t::v[LW6MAT_MAT3_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*3+j.

 -- Struct: lw6mat_fmat4_t

     Float 4x4 matrix (AKA 3D transformation/composition matrix).

 -- Member of lw6mat_fmat4_t: m
     *Type:* 'float'

     *Definition:* 'float
     lw6mat_fmat4_t::m[LW6MAT_MAT4_M_SIZE][LW6MAT_MAT4_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_fmat4_t: v
     *Type:* 'float'

     *Definition:* 'float lw6mat_fmat4_t::v[LW6MAT_MAT4_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*4+j.

 -- Struct: lw6mat_fvec2_t

     Float vector with 2 elements (AKA 2D point).

 -- Member of lw6mat_fvec2_t: x
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec2_t::x'

 -- Member of lw6mat_fvec2_t: y
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec2_t::y'

 -- Member of lw6mat_fvec2_t: p
     *Type:* 'struct lw6mat_fvec2_t::0'

     *Definition:* 'struct lw6mat_fvec2_t::0 lw6mat_fvec2_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_fvec2_t: s
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec2_t::s'

 -- Member of lw6mat_fvec2_t: t
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec2_t::t'

 -- Member of lw6mat_fvec2_t: t
     *Type:* 'struct lw6mat_fvec2_t::1'

     *Definition:* 'struct lw6mat_fvec2_t::1 lw6mat_fvec2_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_fvec2_t: v
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec2_t::v[LW6MAT_VEC2_V_SIZE]'

     Accessor with array index.

 -- Struct: lw6mat_fvec3_t

     Float vector with 3 elements (AKA 3D point).

 -- Member of lw6mat_fvec3_t: x
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec3_t::x'

 -- Member of lw6mat_fvec3_t: y
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec3_t::y'

 -- Member of lw6mat_fvec3_t: z
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec3_t::z'

 -- Member of lw6mat_fvec3_t: p
     *Type:* 'struct lw6mat_fvec3_t::2'

     *Definition:* 'struct lw6mat_fvec3_t::2 lw6mat_fvec3_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_fvec3_t: r
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec3_t::r'

 -- Member of lw6mat_fvec3_t: g
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec3_t::g'

 -- Member of lw6mat_fvec3_t: b
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec3_t::b'

 -- Member of lw6mat_fvec3_t: c
     *Type:* 'struct lw6mat_fvec3_t::3'

     *Definition:* 'struct lw6mat_fvec3_t::3 lw6mat_fvec3_t::c'

     Accessor with color-like name.

 -- Member of lw6mat_fvec3_t: s
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec3_t::s'

 -- Member of lw6mat_fvec3_t: t
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec3_t::t'

 -- Member of lw6mat_fvec3_t: p
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec3_t::p'

 -- Member of lw6mat_fvec3_t: t
     *Type:* 'struct lw6mat_fvec3_t::4'

     *Definition:* 'struct lw6mat_fvec3_t::4 lw6mat_fvec3_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_fvec3_t: v
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec3_t::v[LW6MAT_VEC3_V_SIZE]'

     Accessor with array index.

 -- Member of lw6mat_fvec3_t: v2
     *Type:* 'lw6mat_fvec2_t'

     *Definition:* 'lw6mat_fvec2_t lw6mat_fvec3_t::v2'

     Accessor with smaller-sized vector, only 2 dimensions.

 -- Struct: lw6mat_fvec4_t

     Float vector with 4 elements (AKA quaternion).

 -- Member of lw6mat_fvec4_t: x
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::x'

 -- Member of lw6mat_fvec4_t: y
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::y'

 -- Member of lw6mat_fvec4_t: z
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::z'

 -- Member of lw6mat_fvec4_t: w
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::w'

 -- Member of lw6mat_fvec4_t: p
     *Type:* 'struct lw6mat_fvec4_t::5'

     *Definition:* 'struct lw6mat_fvec4_t::5 lw6mat_fvec4_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_fvec4_t: r
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::r'

 -- Member of lw6mat_fvec4_t: g
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::g'

 -- Member of lw6mat_fvec4_t: b
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::b'

 -- Member of lw6mat_fvec4_t: a
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::a'

 -- Member of lw6mat_fvec4_t: c
     *Type:* 'struct lw6mat_fvec4_t::6'

     *Definition:* 'struct lw6mat_fvec4_t::6 lw6mat_fvec4_t::c'

     Accessor with color-like name.

 -- Member of lw6mat_fvec4_t: s
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::s'

 -- Member of lw6mat_fvec4_t: t
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::t'

 -- Member of lw6mat_fvec4_t: p
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::p'

 -- Member of lw6mat_fvec4_t: q
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::q'

 -- Member of lw6mat_fvec4_t: t
     *Type:* 'struct lw6mat_fvec4_t::7'

     *Definition:* 'struct lw6mat_fvec4_t::7 lw6mat_fvec4_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_fvec4_t: v
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::v[LW6MAT_VEC4_V_SIZE]'

     Accessor with array index.

 -- Member of lw6mat_fvec4_t: v2
     *Type:* 'lw6mat_fvec2_t'

     *Definition:* 'lw6mat_fvec2_t lw6mat_fvec4_t::v2'

     Accessor with smaller-sized vector, only 2 dimensions.

 -- Member of lw6mat_fvec4_t: v3
     *Type:* 'lw6mat_fvec3_t'

     *Definition:* 'lw6mat_fvec3_t lw6mat_fvec4_t::v3'

     Accessor with smaller-sized vector, only 3 dimensions.

 -- Struct: lw6mat_imat2_t

     Integer 2x2 matrix (AKA 2D rectangle).

 -- Member of lw6mat_imat2_t: m
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_imat2_t::m[LW6MAT_MAT2_M_SIZE][LW6MAT_MAT2_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_imat2_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_imat2_t::v[LW6MAT_MAT2_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*2+j.

 -- Struct: lw6mat_imat3_t

     Integer 3x3 matrix (AKA 3D triangle).

 -- Member of lw6mat_imat3_t: m
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_imat3_t::m[LW6MAT_MAT3_M_SIZE][LW6MAT_MAT3_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_imat3_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_imat3_t::v[LW6MAT_MAT3_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*3+j.

 -- Struct: lw6mat_imat4_t

     Integer 4x4 matrix (AKA 3D transformation/composition matrix).

 -- Member of lw6mat_imat4_t: m
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_imat4_t::m[LW6MAT_MAT4_M_SIZE][LW6MAT_MAT4_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_imat4_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_imat4_t::v[LW6MAT_MAT4_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*4+j.

 -- Struct: lw6mat_ivec2_t

     Integer vector with 2 elements (AKA 2D point).

 -- Member of lw6mat_ivec2_t: x
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec2_t::x'

 -- Member of lw6mat_ivec2_t: y
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec2_t::y'

 -- Member of lw6mat_ivec2_t: p
     *Type:* 'struct lw6mat_ivec2_t::8'

     *Definition:* 'struct lw6mat_ivec2_t::8 lw6mat_ivec2_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_ivec2_t: s
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec2_t::s'

 -- Member of lw6mat_ivec2_t: t
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec2_t::t'

 -- Member of lw6mat_ivec2_t: t
     *Type:* 'struct lw6mat_ivec2_t::9'

     *Definition:* 'struct lw6mat_ivec2_t::9 lw6mat_ivec2_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_ivec2_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec2_t::v[LW6MAT_VEC2_V_SIZE]'

     Accessor with array index.

 -- Struct: lw6mat_ivec3_t

     Integer vector with 3 elements (AKA 3D point).

 -- Member of lw6mat_ivec3_t: x
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec3_t::x'

 -- Member of lw6mat_ivec3_t: y
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec3_t::y'

 -- Member of lw6mat_ivec3_t: z
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec3_t::z'

 -- Member of lw6mat_ivec3_t: p
     *Type:* 'struct lw6mat_ivec3_t::10'

     *Definition:* 'struct lw6mat_ivec3_t::10 lw6mat_ivec3_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_ivec3_t: r
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec3_t::r'

 -- Member of lw6mat_ivec3_t: g
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec3_t::g'

 -- Member of lw6mat_ivec3_t: b
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec3_t::b'

 -- Member of lw6mat_ivec3_t: c
     *Type:* 'struct lw6mat_ivec3_t::11'

     *Definition:* 'struct lw6mat_ivec3_t::11 lw6mat_ivec3_t::c'

     Accessor with color-like name.

 -- Member of lw6mat_ivec3_t: s
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec3_t::s'

 -- Member of lw6mat_ivec3_t: t
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec3_t::t'

 -- Member of lw6mat_ivec3_t: p
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec3_t::p'

 -- Member of lw6mat_ivec3_t: t
     *Type:* 'struct lw6mat_ivec3_t::12'

     *Definition:* 'struct lw6mat_ivec3_t::12 lw6mat_ivec3_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_ivec3_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec3_t::v[LW6MAT_VEC3_V_SIZE]'

     Accessor with array index.

 -- Struct: lw6mat_ivec4_t

     Integer vector with 4 elements (AKA quaternion).

 -- Member of lw6mat_ivec4_t: x
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::x'

 -- Member of lw6mat_ivec4_t: y
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::y'

 -- Member of lw6mat_ivec4_t: z
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::z'

 -- Member of lw6mat_ivec4_t: w
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::w'

 -- Member of lw6mat_ivec4_t: p
     *Type:* 'struct lw6mat_ivec4_t::13'

     *Definition:* 'struct lw6mat_ivec4_t::13 lw6mat_ivec4_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_ivec4_t: r
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::r'

 -- Member of lw6mat_ivec4_t: g
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::g'

 -- Member of lw6mat_ivec4_t: b
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::b'

 -- Member of lw6mat_ivec4_t: a
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::a'

 -- Member of lw6mat_ivec4_t: c
     *Type:* 'struct lw6mat_ivec4_t::14'

     *Definition:* 'struct lw6mat_ivec4_t::14 lw6mat_ivec4_t::c'

     Accessor with color-like name.

 -- Member of lw6mat_ivec4_t: s
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::s'

 -- Member of lw6mat_ivec4_t: t
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::t'

 -- Member of lw6mat_ivec4_t: p
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::p'

 -- Member of lw6mat_ivec4_t: q
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::q'

 -- Member of lw6mat_ivec4_t: t
     *Type:* 'struct lw6mat_ivec4_t::15'

     *Definition:* 'struct lw6mat_ivec4_t::15 lw6mat_ivec4_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_ivec4_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::v[LW6MAT_VEC4_V_SIZE]'

     Accessor with array index.

 -- Struct: lw6mat_xmat2_t

     Fixed Point 2x2 matrix (AKA 2D rectangle).

 -- Member of lw6mat_xmat2_t: m
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_xmat2_t::m[LW6MAT_MAT2_M_SIZE][LW6MAT_MAT2_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_xmat2_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_xmat2_t::v[LW6MAT_MAT2_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*3+j.

 -- Struct: lw6mat_xmat3_t

     Fixed Point 3x3 matrix (AKA 3D triangle).

 -- Member of lw6mat_xmat3_t: m
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_xmat3_t::m[LW6MAT_MAT3_M_SIZE][LW6MAT_MAT3_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_xmat3_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_xmat3_t::v[LW6MAT_MAT3_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*3+j.

 -- Struct: lw6mat_xmat4_t

     Fixed Point 4x4 matrix (AKA 3D transformation/composition matrix).

 -- Member of lw6mat_xmat4_t: m
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_xmat4_t::m[LW6MAT_MAT4_M_SIZE][LW6MAT_MAT4_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_xmat4_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_xmat4_t::v[LW6MAT_MAT4_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*4+j.

 -- Struct: lw6mat_xvec2_t

     Fixed Point vector with 2 elements (AKA 2D point).

 -- Member of lw6mat_xvec2_t: x
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec2_t::x'

 -- Member of lw6mat_xvec2_t: y
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec2_t::y'

 -- Member of lw6mat_xvec2_t: p
     *Type:* 'struct lw6mat_xvec2_t::24'

     *Definition:* 'struct lw6mat_xvec2_t::24 lw6mat_xvec2_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_xvec2_t: s
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec2_t::s'

 -- Member of lw6mat_xvec2_t: t
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec2_t::t'

 -- Member of lw6mat_xvec2_t: t
     *Type:* 'struct lw6mat_xvec2_t::25'

     *Definition:* 'struct lw6mat_xvec2_t::25 lw6mat_xvec2_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_xvec2_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec2_t::v[LW6MAT_VEC2_V_SIZE]'

     Accessor with array index.

 -- Struct: lw6mat_xvec3_t

     Fixed Point vector with 3 elements (AKA 3D point).

 -- Member of lw6mat_xvec3_t: x
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec3_t::x'

 -- Member of lw6mat_xvec3_t: y
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec3_t::y'

 -- Member of lw6mat_xvec3_t: z
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec3_t::z'

 -- Member of lw6mat_xvec3_t: p
     *Type:* 'struct lw6mat_xvec3_t::26'

     *Definition:* 'struct lw6mat_xvec3_t::26 lw6mat_xvec3_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_xvec3_t: r
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec3_t::r'

 -- Member of lw6mat_xvec3_t: g
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec3_t::g'

 -- Member of lw6mat_xvec3_t: b
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec3_t::b'

 -- Member of lw6mat_xvec3_t: c
     *Type:* 'struct lw6mat_xvec3_t::27'

     *Definition:* 'struct lw6mat_xvec3_t::27 lw6mat_xvec3_t::c'

     Accessor with color-like name.

 -- Member of lw6mat_xvec3_t: s
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec3_t::s'

 -- Member of lw6mat_xvec3_t: t
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec3_t::t'

 -- Member of lw6mat_xvec3_t: p
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec3_t::p'

 -- Member of lw6mat_xvec3_t: t
     *Type:* 'struct lw6mat_xvec3_t::28'

     *Definition:* 'struct lw6mat_xvec3_t::28 lw6mat_xvec3_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_xvec3_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec3_t::v[LW6MAT_VEC3_V_SIZE]'

     Accessor with array index.

 -- Struct: lw6mat_xvec4_t

     Fixed Point vector with 4 elements (AKA quaternion).

 -- Member of lw6mat_xvec4_t: x
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::x'

 -- Member of lw6mat_xvec4_t: y
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::y'

 -- Member of lw6mat_xvec4_t: z
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::z'

 -- Member of lw6mat_xvec4_t: w
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::w'

 -- Member of lw6mat_xvec4_t: p
     *Type:* 'struct lw6mat_xvec4_t::29'

     *Definition:* 'struct lw6mat_xvec4_t::29 lw6mat_xvec4_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_xvec4_t: r
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::r'

 -- Member of lw6mat_xvec4_t: g
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::g'

 -- Member of lw6mat_xvec4_t: b
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::b'

 -- Member of lw6mat_xvec4_t: a
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::a'

 -- Member of lw6mat_xvec4_t: c
     *Type:* 'struct lw6mat_xvec4_t::30'

     *Definition:* 'struct lw6mat_xvec4_t::30 lw6mat_xvec4_t::c'

     Accessor with color-like name.

 -- Member of lw6mat_xvec4_t: s
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::s'

 -- Member of lw6mat_xvec4_t: t
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::t'

 -- Member of lw6mat_xvec4_t: p
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::p'

 -- Member of lw6mat_xvec4_t: q
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::q'

 -- Member of lw6mat_xvec4_t: t
     *Type:* 'struct lw6mat_xvec4_t::31'

     *Definition:* 'struct lw6mat_xvec4_t::31 lw6mat_xvec4_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_xvec4_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::v[LW6MAT_VEC4_V_SIZE]'

     Accessor with array index.


File: liquidwar6.info,  Node: libmsg,  Next: libnet,  Prev: libmat,  Up: C API

5.33 libmsg
===========

5.33.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/msg/index.html>.

5.33.2 API
----------

 -- Function: char * lw6msg_cmd_generate_hello (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: the node info to use

     Generate a HELLO command.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_cmd_generate_ticket (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, u_int64_t TICKET)
     SYS_CONTEXT: global system context

     INFO: the node info to use

     TICKET: the ticket to send

     Generate a TICKET command.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_cmd_generate_foo (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, u_int32_t KEY, int SERIAL)
     SYS_CONTEXT: global system context

     INFO: the node info to use

     KEY: the key to identify the message

     SERIAL: serial number of latest data message

     Generate a FOO command.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_cmd_generate_bar (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, u_int32_t KEY, int SERIAL)
     SYS_CONTEXT: global system context

     INFO: the node info to use

     KEY: the key to identify the message

     SERIAL: serial number of latest data message

     Generate a BAR command.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_cmd_generate_join (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, int64_t SEQ, int SERIAL)
     SYS_CONTEXT: global system context

     INFO: the node info to use

     SEQ: the current seq

     SERIAL: the serial message number to start with

     Generate a JOIN command.  The seq parameter, if 0, means we want to
     request to join to a server.  Wether this is a real server or a
     physical client acting as a server is out of consideration, 0 means
     request to join, period.  If greater than 0, means we are accepting
     a client, and then the value is our current seq, which the client
     must use to calibrate its own data.  The serial number is here to
     avoid querying messages before the join and keep the serie
     complete.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_cmd_generate_goodbye (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: the node info to use

     Generate a GOODBYE command.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_cmd_generate_data (lw6sys_context_t *
          SYS_CONTEXT, int SERIAL, int I, int N, int64_t SEQ, const char
          * KER_MSG)
     SYS_CONTEXT: global system context

     SERIAL: the message serial number

     I: the message index in the group

     N: the number of messages in the group

     SEQ: the message seq (round + an offset)

     KER_MSG: the actual content of the message (passed to core algo)

     Generate a DATA command.  Serial is an ever increasing number, i
     and n are most of the time 1 and 1, they are usefull only in long
     multipart messages.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_cmd_generate_meta (lw6sys_context_t *
          SYS_CONTEXT, int SERIAL, int I, int N, int64_t SEQ, const
          lw6msg_meta_array_t * META_ARRAY)
     SYS_CONTEXT: global system context

     SERIAL: the message serial number

     I: the message index in the group

     N: the number of messages in the group

     SEQ: the message seq (round + an offset)

     META_ARRAY: the content to send

     Generate a META command.  Serial is an ever increasing number, i
     and n are most of the time 1 and 1, they are usefull only in long
     multipart messages.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_cmd_generate_miss (lw6sys_context_t *
          SYS_CONTEXT, u_int64_t ID_FROM, u_int64_t ID_TO, int
          SERIAL_MIN, int SERIAL_MAX)
     SYS_CONTEXT: global system context

     ID_FROM: id of the node which didn't send data correctly

     ID_TO: id of the node which didn't receive data correctly

     SERIAL_MIN: minimum serial number of unsent/unreceived messages

     SERIAL_MAX: maximum serial number of unsent/unreceived messages

     Generate a MISS command.  This will request anyone who has the
     messages mentionned in stock to resent them to the one who's asking
     for them.

     *Return value:* newly allocated string.

 -- Function: int lw6msg_cmd_analyse_hello (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t ** INFO, const char * MSG)
     SYS_CONTEXT: global system context

     INFO: will contain (remote) node info on success

     MSG: the message to analyse

     Analyzes a HELLO message.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_ticket (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t ** INFO, u_int64_t * TICKET, const
          char * MSG)
     SYS_CONTEXT: global system context

     INFO: will contain (remote) node info on success

     TICKET: if not NULL, will contain the ticket value on success

     MSG: the message to analyse

     Analyzes a TICKET message.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_foo (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t ** INFO, u_int32_t * KEY, int *
          SERIAL, const char * MSG)
     SYS_CONTEXT: global system context

     INFO: will contain (remote) node info on success

     KEY: if not NULL, will contain the foo/bar key on success

     SERIAL: if not NULL, will contain the latest serial number of peer

     MSG: the message to analyse

     Analyzes a FOO message.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_bar (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t ** INFO, u_int32_t * KEY, int *
          SERIAL, const char * MSG)
     SYS_CONTEXT: global system context

     INFO: will contain (remote) node info on success

     KEY: if not NULL, will contain the foo/bar key on success

     SERIAL: if not NULL, will contain the latest serial number of peer

     MSG: the message to analyse

     Analyzes a BAR message.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_join (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t ** INFO, lw6nod_info_t *
          LOCAL_INFO, int64_t * SEQ, int * SERIAL, const char * MSG)
     SYS_CONTEXT: global system context

     INFO: will contain (remote) node info on success

     LOCAL_INFO: local node info to be updated (peer_id list), can be
     NULL

     SEQ: sequence used to initialize communication

     SERIAL: serial used to initialize communication

     MSG: the message to analyse

     Analyzes a JOIN message.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_goodbye (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t ** INFO, const char * MSG)
     SYS_CONTEXT: global system context

     INFO: will contain (remote) node info on success

     MSG: the message to analyse

     Analyzes a GOODBYE message.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_data (lw6sys_context_t *
          SYS_CONTEXT, int * SERIAL, int * I, int * N, int64_t * SEQ,
          char ** KER_MSG, const char * MSG)
     SYS_CONTEXT: global system context

     SERIAL: will contain serial number on success

     I: will contain group index on success

     N: will contain group size on success

     SEQ: will contain seq on success (round + an offset)

     KER_MSG: will contain actual message on success

     MSG: the message to analyze

     Analyzes a DATA message.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_meta (lw6sys_context_t *
          SYS_CONTEXT, int * SERIAL, int * I, int * N, int64_t * SEQ,
          lw6msg_meta_array_t * META_ARRAY, const char * MSG)
     SYS_CONTEXT: global system context

     SERIAL: will contain serial number on success

     I: will contain group index on success

     N: will contain group size on success

     SEQ: will contain seq on success (round + an offset)

     META_ARRAY: will contain the content on success

     MSG: the message to analyze

     Analyzes a META message.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_miss (lw6sys_context_t *
          SYS_CONTEXT, u_int64_t * ID_FROM, u_int64_t * ID_TO, int *
          SERIAL_MIN, int * SERIAL_MAX, const char * MSG)
     SYS_CONTEXT: global system context

     ID_FROM: will contain the id of the node which didn't send data
     correctly

     ID_TO: will contain the id of the node which didn't receive data
     correctly

     SERIAL_MIN: will contain the minimum serial number of
     unsent/unreceived messages

     SERIAL_MAX: will contain the maximum serial number of
     unsent/unreceived messages

     MSG: the message to analyze

     Analyzes a MISS message.

     *Return value:* 1 on success, 0 on failure

 -- Function: char * lw6msg_cmd_guess_from_url (lw6sys_context_t *
          SYS_CONTEXT, const char * MSG)
     SYS_CONTEXT: global system context

     MSG: the message to analyse

     Analyzes a GOODBYE message.

     *Return value:* the from url, if found (dynamically allocated)

 -- Function: char * lw6msg_envelope_generate (lw6sys_context_t *
          SYS_CONTEXT, lw6msg_envelope_mode_t MODE, const char *
          VERSION, const char * PASSWORD_CHECKSUM, u_int32_t
          PHYSICAL_TICKET_SIG, u_int32_t LOGICAL_TICKET_SIG, u_int64_t
          PHYSICAL_FROM_ID, u_int64_t PHYSICAL_TO_ID, u_int64_t
          LOGICAL_FROM_ID, u_int64_t LOGICAL_TO_ID, const char * MSG)
     SYS_CONTEXT: global system context

     MODE: mode to use (a la TELNET or URL compatible)

     VERSION: the program version to use (note: can be changed when
     testing)

     PASSWORD_CHECKSUM: the password string to send

     PHYSICAL_TICKET_SIG: the signature of the message, calculated with
     ticket + physical from/to

     LOGICAL_TICKET_SIG: the signature of the message, calculated with
     ticket + logical from/to

     PHYSICAL_FROM_ID: the sender id

     PHYSICAL_TO_ID: the receiver id

     LOGICAL_FROM_ID: the message creator id

     LOGICAL_TO_ID: the message final destination id

     MSG: the body of the message

     Generate an envelope, that is, the complete message sendable on the
     network.

     *Return value:* newly allocated string.

 -- Function: int lw6msg_envelope_analyse (lw6sys_context_t *
          SYS_CONTEXT, const char * ENVELOPE, lw6msg_envelope_mode_t
          MODE, const char * LOCAL_URL, const char * PASSWORD, u_int64_t
          EXPECTED_PHYSICAL_FROM_ID, u_int64_t EXPECTED_PHYSICAL_TO_ID,
          char ** MSG, u_int32_t * PHYSICAL_TICKET_SIG, u_int32_t *
          LOGICAL_TICKET_SIG, u_int64_t * PHYSICAL_FROM_ID, u_int64_t *
          PHYSICAL_TO_ID, u_int64_t * LOGICAL_FROM_ID, u_int64_t *
          LOGICAL_TO_ID, char ** PHYSICAL_FROM_URL)
     SYS_CONTEXT: global system context

     ENVELOPE: the envelope to analyse

     MODE: mode to use (a la TELNET or URL compatible)

     LOCAL_URL: the url of local server (usefull for password)

     PASSWORD: the password to check against

     EXPECTED_PHYSICAL_FROM_ID: the sender id, if NULL, no check
     performed

     EXPECTED_PHYSICAL_TO_ID: the receiver id, if NULL, no check
     performed

     MSG: if not NULL, will contain body of the message

     PHYSICAL_TICKET_SIG: if not NULL, will contain signature of
     message, calculated with ticket

     LOGICAL_TICKET_SIG: if not NULL, will contain signature of message,
     calculated with ticket

     PHYSICAL_FROM_ID: if not NULL, will contain sender id

     PHYSICAL_TO_ID: if not NULL, will contain receiver id

     LOGICAL_FROM_ID: if not NULL, will contain message creator id

     LOGICAL_TO_ID: if not NULL, will contain message final destination
     id

     PHYSICAL_FROM_URL: if not NULL and if message allows, will contain
     sender public URL

     Generate an envelope, that is, the complete message sendable on the
     network.

     *Return value:* newly allocated string.

 -- Function: void lw6msg_meta_array_zero (lw6sys_context_t *
          SYS_CONTEXT, lw6msg_meta_array_t * META_ARRAY)
     SYS_CONTEXT: global system context

     META_ARRAY: meta meta_array (list of nodes) to modify

     Fills the meta meta_array with zeroes, emptying all nodes.

     *Return value:* none

 -- Function: int lw6msg_meta_array_find (lw6sys_context_t *
          SYS_CONTEXT, const lw6msg_meta_array_t * META_ARRAY, u_int64_t
          NODE_ID)
     SYS_CONTEXT: global system context

     META_ARRAY: meta meta_array (list of nodes) to modify

     NODE_ID: the ID (64-bit) of the node to seartch

     Registers a node in the meta_array.

     *Return value:* 1 if registered, 0 if not (possible error: no place
     left)

 -- Function: int lw6msg_meta_array_exists (lw6sys_context_t *
          SYS_CONTEXT, const lw6msg_meta_array_t * META_ARRAY, u_int64_t
          NODE_ID)
     SYS_CONTEXT: global system context

     META_ARRAY: meta meta_array (list of nodes) to modify

     NODE_ID: the ID (64-bit) of the node to test

     Registers a node in the meta_array.

     *Return value:* 1 if registered, 0 if not (possible error: no place
     left)

 -- Function: int lw6msg_meta_array_set (lw6sys_context_t * SYS_CONTEXT,
          lw6msg_meta_array_t * META_ARRAY, u_int64_t NODE_ID, int
          SERIAL_0, int64_t SEQ_0)
     SYS_CONTEXT: global system context

     META_ARRAY: meta meta_array (list of nodes) to modify

     NODE_ID: the ID (64-bit) of the node to add

     SERIAL_0: base serialfor the node to add

     SEQ_0: base seq for for node to add

     Registers a node in the meta_array.

     *Return value:* 1 if registered, 0 if not (possible error: no place
     left)

 -- Function: int lw6msg_meta_array_unset (lw6sys_context_t *
          SYS_CONTEXT, lw6msg_meta_array_t * META_ARRAY, u_int64_t
          NODE_ID)
     SYS_CONTEXT: global system context

     META_ARRAY: meta meta_array (list of nodes) to modify

     NODE_ID: the ID (64-bit) of the node to remove

     Unregisters a node in the meta_array.

     *Return value:* 1 if node existed, 0 if it was not here

 -- Function: int lw6msg_meta_str2array (lw6sys_context_t * SYS_CONTEXT,
          lw6msg_meta_array_t * META_ARRAY, const char * STR)
     SYS_CONTEXT: global system context

     META_ARRAY: meta meta_array (list of nodes) to get (out param)

     STR: meta string (list of nodes) to be put in the meta_array

     Transforms a string describing the nodes and their id/serial/seq
     into a more usable C structure.

     *Return value:* 1 if parseable and success, 0 if not.

 -- Function: char * lw6msg_meta_array2str (lw6sys_context_t *
          SYS_CONTEXT, const lw6msg_meta_array_t * META_ARRAY)
     SYS_CONTEXT: global system context

     META_ARRAY: meta meta_array (list of nodes) to transform as a
     string

     Transforms a C struct describing the nodes and their id/serial/seq
     into a string transmittable on the network.

     *Return value:* dynamically allocated string

 -- Function: char * lw6msg_oob_generate_info (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: the node to generate info about

     Generates a standard response to the INFO question for OOB (out of
     band) messages.  The same message is sent, be it on http or tcp or
     udp, so it's factorized here.  Function will lock the info object
     when needed.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_oob_generate_list (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: the node to generate info about

     Generates a standard response to the LIST question for OOB (out of
     band) messages.  The same message is sent, be it on http or tcp or
     udp, so it's factorized here.  Function will lock the info object
     when needed.  There's a max length because we don't want the udp
     buffer to be saturated + too long lists do not really mean anything
     anyway.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_oob_generate_pong (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: the node to generate info about

     Generates a standard response to the PING question for OOB (out of
     band) messages.  The same message is sent, be it on http or tcp or
     udp, so it's factorized here.  Function will lock the info object
     when needed.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_oob_generate_request (lw6sys_context_t *
          SYS_CONTEXT, const char * COMMAND, const char * REMOTE_URL,
          const char * PASSWORD, const char * LOCAL_URL)
     SYS_CONTEXT: global system context

     COMMAND: the command to send (PING, INFO, LIST)

     REMOTE_URL: the remote URL (used to seed password)

     PASSWORD: the password, can be NULL or ""

     LOCAL_URL: the public URL to send along with the message, can be
     NULL or ""

     Generates a simple clear text OOB request, with a password if
     needed.

     *Return value:* a newly allocated string

 -- Function: int lw6msg_oob_analyse_request (lw6sys_context_t *
          SYS_CONTEXT, int * SYNTAX_OK, char ** COMMAND, int *
          PASSWORD_OK, char ** REMOTE_URL, const char * REQUEST, const
          char * LOCAL_URL, const char * PASSWORD)
     SYS_CONTEXT: global system context

     SYNTAX_OK: will contain 1 if syntax is OK, 0 if not

     COMMAND: the command (out param, needs *not* to be freed)

     PASSWORD_OK: will contain 1 if password is OK, 0 if not

     REMOTE_URL: the URL detected, if provided (out param, does needs to
     be freed)

     REQUEST: the request to analyse

     LOCAL_URL: the local url (used to seed password)

     PASSWORD: the password to check against

     Analyses a simple OOB message of the form COMMAND <passwd> <url>.

     *Return value:* 1 if OK, 0 if not.  If 0, check the value of
     password_ok.

 -- Function: char * lw6msg_oob_analyse_pong (lw6sys_context_t *
          SYS_CONTEXT, const char * TEXT)
     SYS_CONTEXT: global system context

     TEXT: the text of the message to parse

     Analyses a PONG message and gets the public_url from it, if it
     exists.

     *Return value:* newly allocated string containing public_url if OK,
     NULL on error.

 -- Function: int lw6msg_sort_str_by_seq_callback (lw6sys_context_t *
          SYS_CONTEXT, void * FUNC_DATA, const void * PTR_A, const void
          * PTR_B)
     SYS_CONTEXT: global system context

     FUNC_DATA: function specific data

     PTR_A: pointer to a string

     PTR_B: pointer to a string

     Sort callback for a list containing strings which begin by a seq
     number, will sort with lower seq number first.

     *Return value:* -1 if 'ptr_a' < 'ptr_b' , 0 if 'ptr_a' == 'ptr_b',
     1 if 'ptr_a' > 'ptr_b'

 -- Function: int lw6msg_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libmsg module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6msg_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'msg' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: u_int32_t lw6msg_ticket_calc_sig (lw6sys_context_t *
          SYS_CONTEXT, u_int64_t TICKET, u_int64_t FROM_ID, u_int64_t
          TO_ID, const char * MSG)
     SYS_CONTEXT: global system context

     TICKET: the (private) ticket to use

     FROM_ID: the sender/creator

     TO_ID: the receiver/target

     MSG: the message to sign

     Produces a little signature, which is clearly vulnerable to
     brute-force attacks but makes it possible to be 100% sure if it's
     wrong, someone is trying to do something nasty (or there's a
     serious bug!).

     *Return value:* the sig, always non-zero

 -- Function: int lw6msg_ticket_check_sig (lw6sys_context_t *
          SYS_CONTEXT, u_int64_t TICKET, u_int64_t FROM_ID, u_int64_t
          TO_ID, const char * MSG, u_int32_t TICKET_SIG)
     SYS_CONTEXT: global system context

     TICKET: the (private) ticket to use

     FROM_ID: the sender/creator

     TO_ID: the receiver/target

     MSG: the message to sign

     TICKET_SIG: the signature to check against

     Checks a sig is OK.

     *Return value:* 1 if they are the same, 0 if not.

 -- Function: int lw6msg_utils_parse_key_value_to_ptr (lw6sys_context_t
          * SYS_CONTEXT, char ** KEY, char ** VALUE, const char * LINE)
     SYS_CONTEXT: global system context

     KEY: will contain the key detected

     VALUE: will contain the value detected

     LINE: the line to analyse

     Analyses a trivial "KEY value" line and returns the key and the
     value in the passed pointers.

     *Return value:* 1 if line OK (and in this case 'key' and 'value'
     are set), 0 if not.

 -- Function: int lw6msg_utils_parse_key_value_to_assoc
          (lw6sys_context_t * SYS_CONTEXT, lw6sys_assoc_t ** ASSOC,
          const char * LINE)
     SYS_CONTEXT: global system context

     ASSOC: an assoc object which will contain the result

     LINE: the line to analyse

     Analyses a trivial "KEY value" line and sets the 'assoc' parameter
     according to detected values.  Note that 'assoc' must be set to
     contain string, and free them automatically with
     'lw6sys_free_callback' for instance.

     *Return value:* 1 if line OK (and in this case 'assoc' is updated),
     0 if not.

 -- Function: char * lw6msg_utils_get_assoc_str_with_default
          (lw6sys_context_t * SYS_CONTEXT, lw6sys_assoc_t * ASSOC, const
          char * KEY, const char * DEFAULT_VALUE)
     SYS_CONTEXT: global system context

     ASSOC: the string assoc to query

     KEY: the key to find in the assoc

     DEFAULT_VALUE: the default value to return

     Queries a string assoc for a given value, and if not available,
     returns default value.  Not that default value (nor the assoc
     value) is copied, so you must take care all remain valid until
     usage of returned value is over.

     *Return value:* a string, must not be freed.

 -- Function: int lw6msg_utils_get_assoc_int_with_default
          (lw6sys_context_t * SYS_CONTEXT, lw6sys_assoc_t * ASSOC, const
          char * KEY, int DEFAULT_VALUE)
     SYS_CONTEXT: global system context

     ASSOC: the string assoc to query

     KEY: the key to find in the assoc

     DEFAULT_VALUE: the default value to return

     Queries a string assoc for a given value, and if not available,
     returns default value.  Not that default value (nor the assoc
     value) is copied, so you must take care all remain valid until
     usage of returned value is over.  This one will returned an int
     converted with 'lw6sys_atoi'.

     *Return value:* a string, must not be freed.

 -- Function: int lw6msg_word_first (lw6sys_context_t * SYS_CONTEXT,
          lw6msg_word_t * WORD, char ** NEXT, const char * MSG)
     SYS_CONTEXT: global system context

     WORD: will contain the parsed word

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message and gets the first word.  This word is put in
     'buf' member with its length.  'next' is usefull if you want to
     parse the rest of the message, it points at the beginning of it.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_x (lw6sys_context_t * SYS_CONTEXT,
          lw6msg_word_t * WORD, char ** NEXT, const char * MSG)
     SYS_CONTEXT: global system context

     WORD: will contain the parsed word

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message and gets the first word.  This word is put in
     'buf' member with its length.  'next' is usefull if you want to
     parse the rest of the message, it points at the beginning of it.
     This special 'x' function will consider slash ("/") as valid
     separator.  It can't be used all the time but for almost every
     field but URLs, it's fine.  Internally, this one is used to parse
     integers, IDs, etc.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_base64 (lw6sys_context_t *
          SYS_CONTEXT, lw6msg_word_t * WORD, char ** NEXT, const char *
          MSG)
     SYS_CONTEXT: global system context

     WORD: will contain the parsed word

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message and gets the first word.  This word is put in
     'buf' member with its length.  'next' is usefull if you want to
     parse the rest of the message, it points at the beginning of it.
     The word is expected to be base64 encoded and is decoded
     on-the-fly.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_int_32 (lw6sys_context_t *
          SYS_CONTEXT, int32_t * PARSED_VALUE, char ** NEXT, const char
          * MSG)
     SYS_CONTEXT: global system context

     PARSED_VALUE: will contain the parsed value

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message, gets the first word and interpret it as an int.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_int_32_ge0 (lw6sys_context_t *
          SYS_CONTEXT, int32_t * PARSED_VALUE, char ** NEXT, const char
          * MSG)
     SYS_CONTEXT: global system context

     PARSED_VALUE: will contain the parsed value

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message, gets the first word and interpret it as an int.
     The value must be strictly greater than 0.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_int_32_gt0 (lw6sys_context_t *
          SYS_CONTEXT, int32_t * PARSED_VALUE, char ** NEXT, const char
          * MSG)
     SYS_CONTEXT: global system context

     PARSED_VALUE: will contain the parsed value

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message, gets the first word and interpret it as an int.
     The value must be strictly greater than 0.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_int_64 (lw6sys_context_t *
          SYS_CONTEXT, int64_t * PARSED_VALUE, char ** NEXT, const char
          * MSG)
     SYS_CONTEXT: global system context

     PARSED_VALUE: will contain the parsed value

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message, gets the first word and interpret it as an int.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_int_64_ge0 (lw6sys_context_t *
          SYS_CONTEXT, int64_t * PARSED_VALUE, char ** NEXT, const char
          * MSG)
     SYS_CONTEXT: global system context

     PARSED_VALUE: will contain the parsed value

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message, gets the first word and interpret it as an int.
     The value must be strictly greater than 0.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_int_64_gt0 (lw6sys_context_t *
          SYS_CONTEXT, int64_t * PARSED_VALUE, char ** NEXT, const char
          * MSG)
     SYS_CONTEXT: global system context

     PARSED_VALUE: will contain the parsed value

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message, gets the first word and interpret it as an int.
     The value must be strictly greater than 0.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_id_16 (lw6sys_context_t *
          SYS_CONTEXT, u_int16_t * PARSED_VALUE, char ** NEXT, const
          char * MSG)
     SYS_CONTEXT: global system context

     PARSED_VALUE: will contain the parsed value

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message, gets the first word and interpret it as an
     16-bit id.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_id_32 (lw6sys_context_t *
          SYS_CONTEXT, u_int32_t * PARSED_VALUE, char ** NEXT, const
          char * MSG)
     SYS_CONTEXT: global system context

     PARSED_VALUE: will contain the parsed value

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message, gets the first word and interpret it as an
     32-bit id.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_id_64 (lw6sys_context_t *
          SYS_CONTEXT, u_int64_t * PARSED_VALUE, char ** NEXT, const
          char * MSG)
     SYS_CONTEXT: global system context

     PARSED_VALUE: will contain the parsed value

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message, gets the first word and interpret it as an
     64-bit id.

     *Return value:* 1 on success, 0 on failure.

 -- Function: char * lw6msg_z_encode (lw6sys_context_t * SYS_CONTEXT,
          const char * MSG, int LIMIT)
     SYS_CONTEXT: global system context

     MSG: message to encode

     LIMIT: if under this limit (length in bytes), do not encode, return
     as is

     Z-encode a message, by "Z-encoding" we mean pass the string through
     1) zlib then 2) base64 encoding, this way we get a string without
     any blank and/or special character, and of reasonnable length.
     There's an optional limit *not* to encode anything, just when we
     know there are no special characters to escape and string is small,
     it's useless to fire this big artillery.

     *Return value:* newly allocated string, 0 terminated, NULL on
     error.

 -- Function: char * lw6msg_z_decode (lw6sys_context_t * SYS_CONTEXT,
          const char * MSG)
     SYS_CONTEXT: global system context

     MSG: message to decode

     Z-decode a message, by "Z-encoding" we mean pass the string through
     1) zlib then 2) base64 encoding, this way we get a string without
     any blank and/or special character, and of reasonnable length.
     This decode string does it the reverse way, un64-encode the string
     then uncompress it back to a readable string.

     *Return value:* newly allocated string, 0 terminated, NULL on
     error.

 -- Struct: lw6msg_meta_array_item_s

 -- Member of lw6msg_meta_array_item_s: node_id
     *Type:* 'u_int64_t'

     *Definition:* 'u_int64_t lw6msg_meta_array_item_s::node_id'

 -- Member of lw6msg_meta_array_item_s: serial_0
     *Type:* 'int'

     *Definition:* 'int lw6msg_meta_array_item_s::serial_0'

 -- Member of lw6msg_meta_array_item_s: seq_0
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6msg_meta_array_item_s::seq_0'

 -- Struct: lw6msg_meta_array_s

 -- Member of lw6msg_meta_array_s: logical_from
     *Type:* 'u_int64_t'

     *Definition:* 'u_int64_t lw6msg_meta_array_s::logical_from'

 -- Member of lw6msg_meta_array_s: items
     *Type:* 'lw6msg_meta_array_item_t'

     *Definition:* 'lw6msg_meta_array_item_t
     lw6msg_meta_array_s::items[LW6MSG_NB_META_ARRAY_ITEMS]'

 -- Struct: lw6msg_word_s

     This structure is used to retrieve words from messages.  We use a
     structure here with a fixed sized buffer and a len member, this is
     to avoid mallocating too often when parsing.

 -- Member of lw6msg_word_s: len
     *Type:* 'int'

     *Definition:* 'int lw6msg_word_s::len'

     Length of word, in bytes.

 -- Member of lw6msg_word_s: buf
     *Type:* 'char'

     *Definition:* 'char lw6msg_word_s::buf[LW6MSG_MAX_WORD_SIZE+1]'

     Word data, containing a 0 char at the end, so it is safe to call
     standard C string functions on it.


File: liquidwar6.info,  Node: libnet,  Next: libnod,  Prev: libmsg,  Up: C API

5.34 libnet
===========

5.34.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/net/index.html>.

5.34.2 API
----------

 -- Function: int lw6net_is_connectable (lw6sys_context_t * SYS_CONTEXT,
          const char * IP, int PORT)
     SYS_CONTEXT: global system context

     IP: IP address

     PORT: IP port

     Tells wether we're likely to be able to connect on a given host and
     port.  This is to save ressources, any call to connect which fails
     will register an entry that says "OK this is rotten, don't try it
     before some time, you'll waste your ressources trying to do this".

     *Return value:* 1 if connectable, 0 if not.

 -- Function: void lw6net_set_connectable (lw6sys_context_t *
          SYS_CONTEXT, const char * IP, int PORT, int STATUS)
     SYS_CONTEXT: global system context

     IP: IP address

     PORT: IP port

     STATUS: status, set to 1 if connectable, 0 if not

     *Registers a destination ip:* port as connectable or not.
     Connectable means, there are chances that a connect on this might
     return true.  The information will be kept in a cache.  This is to
     avoid too many low-level calls to connect, the information will be
     kept in cache "for some time", and this way connect will return
     "can't connect" right away and not even try to connect, therefore
     saving ressources.

     *Return value:* none.

 -- Function: int lw6net_dns_is_ip (lw6sys_context_t * SYS_CONTEXT,
          const char * IP)
     IP: the string to check

     Tests if a given string is a valid IP (IPV4).  Test is only
     syntaxic, it's just to know if we're likely to need to query the
     DNS, it does not mean the IP is *really* valid.

     *Return value:* 1 if it's an IP, O if not.

 -- Function: char * lw6net_dns_gethostbyname (lw6sys_context_t *
          SYS_CONTEXT, const char * NAME)
     NAME: name of the host

     A wrapper over the standard gethostbyname function, will even
     accept an IP as an input (in this case, will copy it...)  and
     allocate a new string for the result.

     *Return value:* an IP if success, NULL on error.

 -- Function: int lw6net_dns_lock (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Locks access to dns function 'lw6net_dns_gethostbyname'.  This is
     because 'gethostbyname' isn't reentrant plus, even if we didn't use
     it but its multithreadable equivalent (which is however not
     standard and always available) other libs (such as 'libcurl' not to
     name it) might use this function too so in a general manner it's a
     good idea to use a mutex to protect multiple accesses to this.

     *Return value:* an IP if success, 0 on error.

 -- Function: int lw6net_dns_unlock (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Unlocks access to dns function 'lw6net_dns_gethostbyname'.

     *Return value:* an IP if success, 0 on error.

 -- Function: int lw6net_last_error (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Reports the last network error.  This is basically a debug
     function, designed mostly for Microsoft Winsock API, but can be
     safely called on any platform.

     *Return value:* the last error code, has no universal meaning,
     depends on the platform you're working on.

 -- Function: char * lw6net_if_guess_local (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Guess the local IP address.  This is not fool-proof, and it
     probably cannot be as we can't handle all user-specific configs
     involving multiple IP addresses, virtual private networks, and so
     on.  But this is just to provide a default public IP address when
     starting a network game, saavy users can always specify the right
     interface/address if needed.  Will return NULL if interface can't
     be guessed.

     *Return value:* the IP as a string, dynamically allocated

 -- Function: char * lw6net_if_guess_public_url (lw6sys_context_t *
          SYS_CONTEXT, const char * BIND_IP, int BIND_PORT)
     SYS_CONTEXT: global system context

     BIND_IP: the IP address used to bind on

     BIND_PORT: the IP port used to bind on

     Guess the server public url, based on 'lw6net_if_guess_local' which
     tries to find a valid local IP address which is not loopback.  This
     is only in case 'bind_ip' is 0.0.0.0 (listen on all addresses) else
     it will just use 'bind_ip' as you would expect.  Function isn't
     foolproof, that's why one can override its default with a user
     settings.

     *Return value:* the IP as a string, dynamically allocated

 -- Function: char * lw6net_recv_line_tcp (lw6sys_context_t *
          SYS_CONTEXT, int * SOCK)
     SYS_CONTEXT: global system context

     SOCK: the socket descriptor

     Receives a line terminated by LF ("\n", chr(10)) or CR/LF ("\r\n",
     chr(10)chr(13)) on a TCP socket, that is, stream oriented.  If
     there's no complete line available, function returns immediately
     with NULL. Same if socket is closed, broken, whatever.  Only if
     there's something consistent will the function return non-NULL.
     Socket descriptor is closed on the fly on connection problem.

     *Return value:* a dynamically allocated string with the content
     received.  The tailing (CR)/LF is stripped.

 -- Function: int lw6net_send_line_tcp (lw6sys_context_t * SYS_CONTEXT,
          int * SOCK, const char * LINE)
     SYS_CONTEXT: global system context

     SOCK: the socket descriptor

     LINE: the line to be sent, without the "\n" at the end

     Sends a line terminated by LF ("\n", chr(10)) on a TCP socket, that
     is, stream oriented.  The "\n" is automatically added, do not
     bother sending it.  Socket descriptor is closed on the fly on
     connection problem.

     *Return value:* non-zero if success

 -- Function: char * lw6net_recv_line_udp (lw6sys_context_t *
          SYS_CONTEXT, int SOCK, char ** INCOMING_IP, int *
          INCOMING_PORT)
     SYS_CONTEXT: global system context

     SOCK: the socket descriptor

     INCOMING_IP: the IP address of the sender (returned)

     INCOMING_PORT: the IP port of the sender (returned)

     Receives a line terminated by LF ("\n", chr(10)) or CR/LF ("\r\n",
     chr(10)chr(13)) on a UDP socket, that is, datagram oriented.  If
     there's no complete line available, function returns immediately
     with NULL. Same if socket is closed, broken, whatever.  Only if
     there's something consistent will the function return non-NULL.
     By-value parameters allow the caller to know where the data come
     from.

     *Return value:* a dynamically allocated string with the content
     received.  The tailing (CR)/LF is stripped.

 -- Function: lw6sys_list_t * lw6net_recv_lines_udp (lw6sys_context_t *
          SYS_CONTEXT, int SOCK, char ** INCOMING_IP, int *
          INCOMING_PORT)
     SYS_CONTEXT: global system context

     SOCK: the socket descriptor

     INCOMING_IP: the IP address of the sender (returned)

     INCOMING_PORT: the IP port of the sender (returned)

     Receives several lines terminated by LF ("\n", chr(10)) or CR/LF
     ("\r\n", chr(10)chr(13)) on a UDP socket, that is, datagram
     oriented.  If there's no complete line available, function returns
     immediately with NULL. Same if socket is closed, broken, whatever.
     Only if there's something consistent will the function return
     non-NULL. By-value parameters allow the caller to know where the
     data come from.  This variant of 'lw6net_recv_line_tcp' will return
     a list of lines, this is mandatory since in UDP we can't call recv
     several times.

     *Return value:* a list of dynamically allocated strings.  The
     tailing (CR)/LF is stripped from strings.

 -- Function: int lw6net_send_line_udp (lw6sys_context_t * SYS_CONTEXT,
          int SOCK, const char * LINE, const char * IP, int PORT)
     SYS_CONTEXT: global system context

     SOCK: the socket descriptor

     LINE: the line to be sent, without the "\n" at the end

     IP: the IP address of the target

     PORT: the IP port of the target

     Sends a line terminated by LF ("\n", chr(10)) on a UDP socket, that
     is, datagram oriented.  The "\n" is automatically added, do not
     bother sending it.

     *Return value:* the number of bytes sent, 0 if failure

 -- Function: int lw6net_init (lw6sys_context_t * SYS_CONTEXT, int ARGC,
          const char * [] ARGV, int NET_LOG)
     SYS_CONTEXT: global system context

     ARGC: argc as passed to 'main'

     ARGV: argv as passed to 'main'

     NET_LOG: 1 if you want to enable net log, 0 if not

     Initializes the low-level network API, you must call this before
     calling any other network related function, for it allocates a
     dynamic context which is in turn used by every function.

     *Return value:* non-zero if success

 -- Function: void lw6net_quit (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Frees memory, joins active threads, and releases everything set up
     by network code.

     *Return value:* void

 -- Function: int lw6net_socket_set_blocking_mode (lw6sys_context_t *
          SYS_CONTEXT, int SOCK, int MODE)
     SYS_CONTEXT: global system context

     SOCK: the socket to modify

     MODE: the mode to use (1 -> blocking mode, 0 -> non-blocking)

     Sets the blocking mode of a socket, the reason we use this is that
     'ioctl' isn't portable ('ioctlsocket' on MS-Windows).

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6net_socket_is_valid (lw6sys_context_t *
          SYS_CONTEXT, int SOCK)
     SYS_CONTEXT: global system context

     SOCK: the socket to test

     Tells if a socket is valid or not.  This does not mean the socket
     is opened/connected and/or the peer is reachable, it just checks
     the socket is a valid descriptor.  In practice it's just to avoid
     copy/pasting if (sock>=0)" everywhere.

     *Return value:* 1 if valid, 0 if not

 -- Function: void lw6net_socket_close (lw6sys_context_t * SYS_CONTEXT,
          int * SOCK)
     SYS_CONTEXT: global system context

     SOCK: the socket to close

     Closes a socket, that is, stop activity and free its descriptor.
     This function will take a pointer on the socket, this is done on
     purpose, the idea is to make sure once the socket is closed it's
     never used again within the code, so we modify the pointed value in
     place.

     *Return value:* none.

 -- Function: int lw6net_tcp_listen (lw6sys_context_t * SYS_CONTEXT,
          const char * IP, int PORT)
     SYS_CONTEXT: global system context

     IP: IP address to bind to

     PORT: IP port to listen on

     Listens in TCP on a given port.

     *Return value:* >=0 on success, -1 on failure.

 -- Function: int lw6net_tcp_accept (lw6sys_context_t * SYS_CONTEXT,
          char ** INCOMING_IP, int * INCOMING_PORT, int LISTENING_SOCK,
          int DELAY_MSEC)
     SYS_CONTEXT: global system context

     INCOMING_IP: address of remote peer (out param, dynamically
     allocated)

     INCOMING_PORT: port of remote peer (out param)

     LISTENING_SOCK: socket to listen on

     DELAY_MSEC: delay, in msec, after which we stop accepting

     Accepts for a connexion on the given socket.

     *Return value:* the new socket (>=0) if accepted, else -1

 -- Function: int lw6net_tcp_connect (lw6sys_context_t * SYS_CONTEXT,
          const char * IP, int PORT, int DELAY_MSEC)
     SYS_CONTEXT: global system context

     IP: address to connect to

     PORT: port to connect to

     DELAY_MSEC: delay before we consider it's too late

     Tries to connect on a given socket.

     *Return value:* socket (>=0) on success, else -1

 -- Function: int lw6net_tcp_send (lw6sys_context_t * SYS_CONTEXT, int *
          SOCK, const char * BUF, int LEN, int DELAY_MSEC, int LOOP)
     SYS_CONTEXT: global system context

     SOCK: socket to use

     BUF: data buffer

     LEN: data buffer length

     DELAY_MSEC: delay after which we give up

     LOOP: accept to do several calls if needed

     Will send data, possibly looping until all is send, and waiting for
     a maximum time of delay_msec.  If the send reveals a socket closed
     by peer or other serious problem, socket is closed and sock set to
     -1.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6net_tcp_peek (lw6sys_context_t * SYS_CONTEXT, int *
          SOCK, char * BUF, int LEN, int DELAY_MSEC)
     SYS_CONTEXT: global system context

     SOCK: socket to use

     BUF: data buffer

     LEN: data buffer length

     DELAY_MSEC: maximum time to wait

     Tells wether data is available.  Will actually fill the buffer with
     the data, but not remove it from the fifo list.  If the peel
     reveals a socket closed by peer or other serious problem, socket is
     closed and sock set to -1.

     *Return value:* number of bytes available, 0 when nothing

 -- Function: int lw6net_tcp_recv (lw6sys_context_t * SYS_CONTEXT, int *
          SOCK, char * BUF, int LEN, int DELAY_MSEC, int LOOP)
     SYS_CONTEXT: global system context

     SOCK: socket to use

     BUF: data buffer

     LEN: data buffer length

     DELAY_MSEC: maximum time to wait

     LOOP: wether to loop or not

     If data is available, put it in buffer.  If needed, will loop until
     'delay_msec' is elapsed.  Data is removed from queue.  If the peel
     reveals a socket closed by peer or other serious problem, socket is
     closed and sock set to -1.

     *Return value:* number of bytes received, 0 when nothing

 -- Function: int lw6net_tcp_is_alive (lw6sys_context_t * SYS_CONTEXT,
          int * SOCK)
     SYS_CONTEXT: global system context

     SOCK: socket to test

     Tells wether a socket is alive and able to send data.  This
     function will attempt a write to test if it's really usable.  If
     not, will close in on the fly.

     *Return value:* 1 if alive, 0 if not.

 -- Function: int lw6net_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libnet module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6net_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'net' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6net_udp_client (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates an UDP client socket, that is, creates it and does not bind
     it to any address.

     *Return value:* socket (>=0) on success, else -1

 -- Function: int lw6net_udp_server (lw6sys_context_t * SYS_CONTEXT,
          const char * IP, int PORT)
     SYS_CONTEXT: global system context

     IP: IP address to bind to

     PORT: IP port to listen on

     Creates an UDP listening socket, that is, creates it and binds it
     on a given address.

     *Return value:* socket (>=0) on success, else -1

 -- Function: int lw6net_udp_send (lw6sys_context_t * SYS_CONTEXT, int
          SOCK, const char * BUF, int LEN, const char * IP, int PORT)
     SYS_CONTEXT: global system context

     SOCK: socket to use

     BUF: data buffer

     LEN: data buffer length

     IP: IP address to send data to

     PORT: IP port to send data to

     Sends an UDP datagram.  Size can't be longer than about 1400 bytes,
     see problems about MTU, in practice all values arround 1000 are
     quite safe, 500 is pretty much garanteed to work everywhere, and
     for various reasons 1452 is a good maximum bet.

     *Return value:* number of bytes sent

 -- Function: int lw6net_udp_peek (lw6sys_context_t * SYS_CONTEXT, int
          SOCK, char * BUF, int LEN, char ** INCOMING_IP, int *
          INCOMING_PORT)
     SYS_CONTEXT: global system context

     SOCK: socket to use

     BUF: data buffer

     LEN: data buffer length

     Peeks for a UDP datagram.  Will not remove the data from queue.

     *Return value:* number of bytes received

 -- Function: int lw6net_udp_recv (lw6sys_context_t * SYS_CONTEXT, int
          SOCK, char * BUF, int LEN, char ** INCOMING_IP, int *
          INCOMING_PORT)
     SYS_CONTEXT: global system context

     SOCK: socket to use

     BUF: data buffer

     LEN: data buffer length

     Receives a UDP datagram.  Will remove the data from queue.

     *Return value:* number of bytes received


File: liquidwar6.info,  Node: libnod,  Next: libp2p,  Prev: libnet,  Up: C API

5.35 libnod
===========

5.35.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/nod/index.html>.

5.35.2 API
----------

 -- Function: int lw6nod_info_community_add (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, u_int64_t ID, const char *
          URL)
     SYS_CONTEXT: global system context

     INFO: node info object to modify

     ID: ID of the new member

     URL: URL of the new member, can be NULL

     Adds a new member to the community.

     *Return value:* 1 if new member could be added, 0 if not.

 -- Function: int lw6nod_info_community_is_member (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, u_int64_t ID, const char *
          URL)
     SYS_CONTEXT: global system context

     INFO: node info object to test

     ID: ID of the member we want to check

     URL: URL of the member we want to check

     Tells wether a member is already in the community.  Note that if
     there's a member with the same URL but with a different ID, or a
     member with the same ID but a different URL, the function will
     fail, we need URLs and IDs to both be different for the peer to be
     added.  Not respecting this would lead to confusion, while sharing
     an ID is conceivable over the whole network, it can't be tolerated
     within a community.  Same for the URL.

     *Return value:* 1 if new member could be added, 0 if not.

 -- Function: int lw6nod_info_community_has_id (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, u_int64_t ID)
     SYS_CONTEXT: global system context

     INFO: node info object to test

     ID: ID of the member we want to check

     Tells wether a member exists with this ID. Will test both ourselves
     and remote peers.

     *Return value:* 1 if ID is already taken, 0 if available.

 -- Function: int lw6nod_info_community_has_id_without_url
          (lw6sys_context_t * SYS_CONTEXT, lw6nod_info_t * INFO,
          u_int64_t ID)
     SYS_CONTEXT: global system context

     INFO: node info object to test

     ID: ID of the member we want to check

     Tells wether a member exists with this ID, but for which we don't
     know the URL, that is, url is NULL.

     *Return value:* 1 if ID is already taken and has NULL url, 0 else.

 -- Function: int lw6nod_info_community_has_url (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, const char * URL)
     SYS_CONTEXT: global system context

     INFO: node info object to test

     URL: URL of the member we want to check

     Tells wether a member exists with this URL. Will test both
     ourselves and remote peers.

     *Return value:* 1 if URL is already taken, 0 if available.

 -- Function: int64_t lw6nod_info_community_get_id_from_url
          (lw6sys_context_t * SYS_CONTEXT, lw6nod_info_t * INFO, const
          char * URL)
     SYS_CONTEXT: global system context

     INFO: node info object to test

     URL: URL of the member we want to check

     Returns the id of the node with this URL, if it's known to us.

     *Return value:* id if it's the community, else 0

 -- Function: char * lw6nod_info_community_get_url_from_id
          (lw6sys_context_t * SYS_CONTEXT, lw6nod_info_t * INFO, int64_t
          ID)
     SYS_CONTEXT: global system context

     INFO: node info object to test

     ID: ID of the member we want to check

     Returns the id of the node with this URL, if it's known to us.

     *Return value:* url if it's the community else NULL, must be freed

 -- Function: int lw6nod_info_community_remove_by_id (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, u_int64_t ID)
     SYS_CONTEXT: global system context

     INFO: node info object to modify

     ID: ID of the member we want to remove

     Removes a community member by ID.

     *Return value:* 1 if successfully removed, 0 if was not present.

 -- Function: int lw6nod_info_community_remove_by_url (lw6sys_context_t
          * SYS_CONTEXT, lw6nod_info_t * INFO, const char * URL)
     SYS_CONTEXT: global system context

     INFO: node info object to modify

     URL: URL of the member we want to remove

     Removes a community member by URL.

     *Return value:* 1 if successfully removed, 0 if was not present.

 -- Function: int lw6nod_info_community_count (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: node info object to modify

     Tells how many members there are in a community.  This include
     ourselves so this can never be 0, should at least be 1.  Note that
     this is pretty much the same as the nb_nodes member of dyn_info,
     but this one is calculated dynamically from peer list, while the
     other one is updated from time to time from game_state information.

     *Return value:* number of community members, including this node
     (us).

 -- Function: void lw6nod_info_community_reset (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: node info object to modify

     Resets all peers, set community to only one member, ourselves.

     *Return value:* none.

 -- Function: char * lw6nod_info_community_get_peer_id_list_str
          (lw6sys_context_t * SYS_CONTEXT, lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: node to query

     Builds a string containing all peer ids, separated by a separator.

     *Return value:* newly allocated string

 -- Function: void lw6nod_info_community_set_peer_id_list_str
          (lw6sys_context_t * SYS_CONTEXT, lw6nod_info_t * INFO, const
          char * PEER_ID_LIST_STR)
     SYS_CONTEXT: global system context

     INFO: node to modify

     PEER_ID_LIST_STR: new value

     Interprets a peer_id_list_str and puts it into the node data
     structures.  Note that this function won't really copy the list,
     instead it will populate the dyn_info struct with the right values.

     *Return value:* none

 -- Function: void lw6nod_info_community_id_without_url_map
          (lw6sys_context_t * SYS_CONTEXT, lw6nod_info_t * INFO,
          lw6nod_id_callback_func_t FUNC, void * FUNC_DATA)
     SYS_CONTEXT: global system context

     INFO: node to process

     FUNC: function to use as a callback

     FUNC_DATA: data passed along with the function

     Applies function func to all the members of the community which
     have an id but not an URL...

     *Return value:* none.

 -- Function: void lw6nod_dyn_info_free (lw6sys_context_t * SYS_CONTEXT,
          lw6nod_dyn_info_t * DYN_INFO)
     SYS_CONTEXT: global system context

     DYN_INFO: the dyn info struct to free

     Frees a dyn info object, to be used after a call to
     'lw6nod_info_dup_dyn' for instance.

     *Return value:* none

 -- Function: lw6nod_info_t * lw6nod_info_new (lw6sys_context_t *
          SYS_CONTEXT, const char * PROGRAM, const char * VERSION, const
          char * CODENAME, int STAMP, u_int64_t ID, const char * URL,
          const char * TITLE, const char * DESCRIPTION, const char *
          PASSWORD, int BENCH, int OPEN_RELAY, int UPTIME, int
          IDLE_SCREENSHOT_SIZE, void * IDLE_SCREENSHOT_DATA)
     SYS_CONTEXT: global system context

     PROGRAM: the program (normally it's liquidwar6)

     VERSION: the version

     CODENAME: the codename

     STAMP: the stamp

     ID: the node id

     URL: the node public url

     TITLE: the node title

     DESCRIPTION: the node description

     PASSWORD: the node password

     BENCH: the node bench

     OPEN_RELAY: open relay or not

     UPTIME: uptime in seconds

     IDLE_SCREENSHOT_SIZE: the size (bytes) of the image to display when
     game is idle

     IDLE_SCREENSHOT_DATA: the data (jpeg) of the image to display when
     game is idle

     Creates a node info object.  The arguments correspond to the
     immutable node attributes, other properties such as how many
     players are connected or set in other functions like
     'lw6nod_info_update' which can be called later.

     *Return value:* newly allocated object, NULL on error.

 -- Function: void lw6nod_info_free (lw6sys_context_t * SYS_CONTEXT,
          lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: the node info to free

     Frees a node info object.

     *Return value:* none

 -- Function: int lw6nod_info_lock (lw6sys_context_t * SYS_CONTEXT,
          lw6nod_info_t * INFO)
     INFO: the node info to lock

     Locks a node info object, this is usefull for some members,
     typically list of servers, can be accessed by separated threads,
     one reading, many writing, and these objects (chained lists)
     certainly do not want to be modified while being read.

     *Return value:* 1 if ok, 0 if not.

 -- Function: int lw6nod_info_unlock (lw6sys_context_t * SYS_CONTEXT,
          lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: the node info to unlock

     Unlocks a node info object, this is the compation of the
     'lw6nod_info_lock' function.

     *Return value:* 1 if ok, 0 if not.

 -- Function: void lw6nod_info_idle (lw6sys_context_t * SYS_CONTEXT,
          lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: the node info to modify

     Clears a node info object and sets all its variable attributes to
     NULL/default values.  This is what we want when the node is idle,
     not playing.

     *Return value:* none.

 -- Function: int lw6nod_info_update (lw6sys_context_t * SYS_CONTEXT,
          lw6nod_info_t * INFO, u_int64_t COMMUNITY_ID, int ROUND, const
          char * LEVEL, int REQUIRED_BENCH, int NB_COLORS, int
          MAX_NB_COLORS, int NB_CURSORS, int MAX_NB_CURSORS, int
          NB_NODES, int MAX_NB_NODES, const char * PEER_ID_LIST, int
          GAME_SCREENSHOT_SIZE, void * GAME_SCREENSHOT_DATA)
     SYS_CONTEXT: global system context

     INFO: the node info to update

     COMMUNITY_ID: the id of the community the node belongs to

     ROUND: the current round (can have an offset with real round
     number)

     LEVEL: the name of the current level (map)

     REQUIRED_BENCH: the bench required to connect

     NB_COLORS: number of colors playing

     MAX_NB_COLORS: max number of colors allowed

     NB_CURSORS: number of cursors playing

     MAX_NB_CURSORS: max number of cursors allowed

     NB_NODES: number of nodes playing

     MAX_NB_NODES: max number of nodes allowed

     PEER_ID_LIST: list of peers ids, can be NULL

     GAME_SCREENSHOT_SIZE: size of screenshot (bytes)

     GAME_SCREENSHOT_DATA: screenshot data (byte buffer, contains JPEG)

     Set a node info object variable attributes.  Call this whenever the
     node has changed some parameter.  Not too often for it's not needed
     and some operations such as modying the screenshot, can be time
     consuming.

     *Return value:* 1 if OK, 0 if error.

 -- Function: lw6nod_dyn_info_t * lw6nod_info_dup_dyn (lw6sys_context_t
          * SYS_CONTEXT, lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: the node info containing the dyn info to duplicate

     Extracts the dynamic part of an info struct and duplicates it, this
     is to avoid protection fault error when concurrent threads access
     this info.

     *Return value:* newly allocated object, must be freed.

 -- Function: lw6sys_hash_t * lw6nod_info_new_discovered_nodes
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a new hash, to be used as a discovered nodes list.  Using
     this function has the advantage of setting the hash options to
     their defaults.  We use a hash to avoid having uselessly long lists
     containing always the same node due to multiple detections.

     *Return value:* an empty hash

 -- Function: int lw6nod_info_add_discovered_node (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, const char * PUBLIC_URL)
     SYS_CONTEXT: global system context

     INFO: the node info to update

     PUBLIC_URL: the address of the discovered node

     Registers a new server, and queues it as something that should be
     checked later because it's interesting.  We can't insert in the
     database all the servers we suspect to exist so network threads
     should use this, then main thread will process discovered servers
     afterwards.  This is also a good way to avoid trivial DOS attacks.

     *Return value:* 1 if OK, O if error.

 -- Function: lw6sys_list_t * lw6nod_info_pop_discovered_nodes
          (lw6sys_context_t * SYS_CONTEXT, lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: the node info to query

     Returns a list of all discovered nodes (their public URL) and
     empties the current queue as well.

     *Return value:* a list of dynamically allocated strings.

 -- Function: lw6sys_list_t * lw6nod_info_new_verified_nodes
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a new list, to be filled with nodes and typically passed to
     'lw6nod_info_set_verified_nodes'.  Using this function has the
     advantage of setting the listh options to their defaults.

     *Return value:* an empty list

 -- Function: int lw6nod_info_set_verified_nodes (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, lw6sys_list_t * LIST)
     SYS_CONTEXT: global system context

     INFO: the node info to modify

     LIST: the list of verified nodes, will be freed by this function

     Sets the list of verified nodes, that is, the list of nodes we are
     sure to exist, this is typically the list we will display later on
     a web page.  We can't directly display any discovered node, one
     needs to filter them through main thread.  Something very important
     about this function is that 'list' will be freed by function, that
     is, if you call this, then you can (you should) forget your object,
     it will disappear any time soon.

     *Return value:* 1 if OK, 0 on error.

 -- Function: void lw6nod_info_map_verified_nodes (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, lw6sys_list_callback_func_t
          FUNC, void * FUNC_DATA)
     SYS_CONTEXT: global system context

     INFO: the node info concerned

     FUNC: the function to apply

     FUNC_DATA: arbitrary pointer holding data to pass to function

     Calls 'lw6sys_hash_map' with 'func' on every member of the list of
     verified nodes.  The reason there's a function for this is that it
     is very important that list object is locked when doing this.  This
     function does perform a lock/unlock so it is safe.

     *Return value:* none.

 -- Function: int lw6nod_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libnod module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6nod_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'nod' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6nod_const_info_s

     Constant informations about a node, these are informations that do
     not vary through the node's life, so they are set object creation
     then left unchanged.

 -- Member of lw6nod_const_info_s: program
     *Type:* 'char *'

     *Definition:* 'char* lw6nod_const_info_s::program'

     Program, this should be set to liquidwar6.

 -- Member of lw6nod_const_info_s: version
     *Type:* 'char *'

     *Definition:* 'char* lw6nod_const_info_s::version'

     The version of the program.

 -- Member of lw6nod_const_info_s: codename
     *Type:* 'char *'

     *Definition:* 'char* lw6nod_const_info_s::codename'

     The codename of the program.

 -- Member of lw6nod_const_info_s: stamp
     *Type:* 'int'

     *Definition:* 'int lw6nod_const_info_s::stamp'

     The stamp of the program.

 -- Member of lw6nod_const_info_s: ref_info
     *Type:* 'lw6nod_ref_info_t'

     *Definition:* 'lw6nod_ref_info_t lw6nod_const_info_s::ref_info'

     Reference information, how to uniquely identify node.

 -- Member of lw6nod_const_info_s: title
     *Type:* 'char *'

     *Definition:* 'char* lw6nod_const_info_s::title'

     The title of the node, its readable short name.

 -- Member of lw6nod_const_info_s: description
     *Type:* 'char *'

     *Definition:* 'char* lw6nod_const_info_s::description'

     More details about the node.

 -- Member of lw6nod_const_info_s: has_password
     *Type:* 'int'

     *Definition:* 'int lw6nod_const_info_s::has_password'

     Wether the node is password protected or not.

 -- Member of lw6nod_const_info_s: password
     *Type:* 'char *'

     *Definition:* 'char* lw6nod_const_info_s::password'

     The password used, cleartext.

 -- Member of lw6nod_const_info_s: bench
     *Type:* 'int'

     *Definition:* 'int lw6nod_const_info_s::bench'

     The node bench.

 -- Member of lw6nod_const_info_s: open_relay
     *Type:* 'int'

     *Definition:* 'int lw6nod_const_info_s::open_relay'

     Wether the node acts as an open relay or not.

 -- Member of lw6nod_const_info_s: creation_timestamp
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6nod_const_info_s::creation_timestamp'

     The node creation timestamp.

 -- Member of lw6nod_const_info_s: idle_screenshot_size
     *Type:* 'int'

     *Definition:* 'int lw6nod_const_info_s::idle_screenshot_size'

     Size of the screenshot (in bytes) when in idle mode.

 -- Member of lw6nod_const_info_s: idle_screenshot_data
     *Type:* 'void *'

     *Definition:* 'void* lw6nod_const_info_s::idle_screenshot_data'

     Idle mode screenshot data.  This is just a plain JPEG buffer, which
     will be used as a fallback if there's no real screenshot available.

 -- Struct: lw6nod_dyn_info_s

     Dynamic informations about a node, these are informations that vary
     through the node's life, so they are unset at object creation and
     can then be updated from game context.

 -- Member of lw6nod_dyn_info_s: community_id_int
     *Type:* 'u_int64_t'

     *Definition:* 'u_int64_t lw6nod_dyn_info_s::community_id_int'

     The ID of the community this node belongs to, as a 64-bit unsigned
     integer.

 -- Member of lw6nod_dyn_info_s: community_id_str
     *Type:* 'char *'

     *Definition:* 'char* lw6nod_dyn_info_s::community_id_str'

     The ID of the community this node belongs to, as a string (64-bit
     integer converted to hexa).

 -- Member of lw6nod_dyn_info_s: community_peers
     *Type:* 'lw6nod_ref_info_t'

     *Definition:* 'lw6nod_ref_info_t
     lw6nod_dyn_info_s::community_peers[LW6NOD_MAX_NB_PEERS]'

     The list of community members, you need to refer to the nb_nodes
     member to know quickly how many members they are but actually, in
     practice, there can be holes in this array, you need to check each
     slot, for instance 0 can be filled, 2 can be filled too, but 1 be
     empty.  Note that we don't count ourselves in this list.

 -- Member of lw6nod_dyn_info_s: round
     *Type:* 'int'

     *Definition:* 'int lw6nod_dyn_info_s::round'

     The current round.

 -- Member of lw6nod_dyn_info_s: level
     *Type:* 'char *'

     *Definition:* 'char* lw6nod_dyn_info_s::level'

     The current level.

 -- Member of lw6nod_dyn_info_s: required_bench
     *Type:* 'int'

     *Definition:* 'int lw6nod_dyn_info_s::required_bench'

     The required bench to connect to this node.

 -- Member of lw6nod_dyn_info_s: nb_colors
     *Type:* 'int'

     *Definition:* 'int lw6nod_dyn_info_s::nb_colors'

     Number of colors playing.

 -- Member of lw6nod_dyn_info_s: max_nb_colors
     *Type:* 'int'

     *Definition:* 'int lw6nod_dyn_info_s::max_nb_colors'

     Maximum number of colors allowed to play.

 -- Member of lw6nod_dyn_info_s: nb_cursors
     *Type:* 'int'

     *Definition:* 'int lw6nod_dyn_info_s::nb_cursors'

     Number of cursors playing.

 -- Member of lw6nod_dyn_info_s: max_nb_cursors
     *Type:* 'int'

     *Definition:* 'int lw6nod_dyn_info_s::max_nb_cursors'

     Maximum number of cursors allowed to play.

 -- Member of lw6nod_dyn_info_s: nb_nodes
     *Type:* 'int'

     *Definition:* 'int lw6nod_dyn_info_s::nb_nodes'

     Number of nodes playing.

 -- Member of lw6nod_dyn_info_s: max_nb_nodes
     *Type:* 'int'

     *Definition:* 'int lw6nod_dyn_info_s::max_nb_nodes'

     Maximum number of nodes allowed to play.

 -- Member of lw6nod_dyn_info_s: game_screenshot_size
     *Type:* 'int'

     *Definition:* 'int lw6nod_dyn_info_s::game_screenshot_size'

     Size of the screenshot, in bytes.

 -- Member of lw6nod_dyn_info_s: game_screenshot_data
     *Type:* 'void *'

     *Definition:* 'void* lw6nod_dyn_info_s::game_screenshot_data'

     Game screenshot data.  This is just a plain JPEG buffer, which will
     be served when peers and/or web clients want to gather informations
     about the game.  This can be NULL, in that the fallback constant
     data will be used.

 -- Struct: lw6nod_info_s

     Informations about a node.  Note that in practice this structure is
     just used to describe our current node, there might be several
     instances of this if a program instanciates several nodes, but
     another data structure is used to store information about
     peers.typedef struct lw6nod_info_s

 -- Member of lw6nod_info_s: mutex
     *Type:* 'lw6sys_mutex_t *'

     *Definition:* 'lw6sys_mutex_t* lw6nod_info_s::mutex'

     Mutex used to access dynamic informations.

 -- Member of lw6nod_info_s: const_info
     *Type:* 'lw6nod_const_info_t'

     *Definition:* 'lw6nod_const_info_t lw6nod_info_s::const_info'

     Constant informations, never changes.

 -- Member of lw6nod_info_s: dyn_info
     *Type:* 'lw6nod_dyn_info_t'

     *Definition:* 'lw6nod_dyn_info_t lw6nod_info_s::dyn_info'

     Dynamic informations, can be updated.  Do not modify this directly,
     instead use appropriate functions which will use mutexes properly.

 -- Member of lw6nod_info_s: discovered_nodes
     *Type:* 'lw6sys_hash_t *'

     *Definition:* 'lw6sys_hash_t* lw6nod_info_s::discovered_nodes'

     List of discovered nodes, do not access this directly, instead use
     proper query functions which, in turn, will use mutexes properly.

 -- Member of lw6nod_info_s: verified_nodes
     *Type:* 'lw6sys_list_t *'

     *Definition:* 'lw6sys_list_t* lw6nod_info_s::verified_nodes'

     List of verified nodes, do not access this directly, instead use
     proper query functions which, in turn, will use mutexes properly.

 -- Struct: lw6nod_ref_info_s

     Reference information about a node, this is all you need to
     uniquely identify a node.  In theory, only the ID are only the URL
     are enough, in practice it's not that bad to have some redundancy,
     plus it makes it easier and faster to connect to them and transmit
     informations.

 -- Member of lw6nod_ref_info_s: id_int
     *Type:* 'u_int64_t'

     *Definition:* 'u_int64_t lw6nod_ref_info_s::id_int'

     The id of the node, as an integer (64-bit unsigned).

 -- Member of lw6nod_ref_info_s: id_str
     *Type:* 'char *'

     *Definition:* 'char* lw6nod_ref_info_s::id_str'

     The id of the node, as a string (64-bit converted to hexa).

 -- Member of lw6nod_ref_info_s: url
     *Type:* 'char *'

     *Definition:* 'char* lw6nod_ref_info_s::url'

     The public URL of the node.


File: liquidwar6.info,  Node: libp2p,  Next: libpil,  Prev: libnod,  Up: C API

5.36 libp2p
===========

5.36.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/p2p/index.html>.

5.36.2 API
----------

 -- Function: lw6p2p_db_t * lw6p2p_db_open (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV, const char *
          NAME)
     SYS_CONTEXT: global system context

     ARGC: number of args, as passed to 'main'

     ARGV: args array, as passed to 'main'

     NAME: the database name

     Creates a new database object.  Normally there's only one object
     like this at a given time, it can be shared among various nodes.
     The database name is appended to user directory path, this allows
     different databases to be created, in theory.

     *Return value:* a pointer on the newly created object.

 -- Function: void lw6p2p_db_close (lw6sys_context_t * SYS_CONTEXT,
          lw6p2p_db_t * DB)
     SYS_CONTEXT: global system context

     DB: the db to close

     Closes a db object, memory ressources will be freed.

     *Return value:* none.

 -- Function: char * lw6p2p_db_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6p2p_db_t * DB)
     SYS_CONTEXT: global system context

     DB: the db to work on

     Gives a readable representation of the db

     *Return value:* a dynamically allocated string

 -- Function: int lw6p2p_db_reset (lw6sys_context_t * SYS_CONTEXT, int
          ARGC, const char * [] ARGV, const char * NAME)
     SYS_CONTEXT: global system context

     ARGC: number of args, as passed to 'main'

     ARGV: args array, as passed to 'main'

     NAME: the database name

     Clears the database.  Simply removes the db file, in fact.  Do not
     call while database is used...

     *Return value:* 1 on success, 0 if failed.

 -- Function: char * lw6p2p_db_default_name (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the default database name, should be p2p.db (this is a
     relative path, not an absolute path, will be appended to user dir).

     *Return value:* the default database name, need not (must not) be
     freed.

 -- Function: int _lw6p2p_db_timestamp (lw6sys_context_t * SYS_CONTEXT,
          _lw6p2p_db_t * DB, int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     DB: the db object concerned (used to calculate time origin)

     TIMESTAMP: the timestamp as returned by lw6sys_get_timestamp

     Returns a timestamp suitable for db usage (seconds since object
     creation), set to the timestamp passed as an argument
     (milliseconds).  The reason we don't use regular timestamps is that
     they are 1) too accurate (msec is useless for what's involved here)
     and 2) too big and likely to be negative in signed mode even if
     converted to seconds.

     *Return value:* a timestamp, 0 means "beginning of program" (think
     of it as uptime)

 -- Function: int _lw6p2p_db_now (lw6sys_context_t * SYS_CONTEXT,
          _lw6p2p_db_t * DB)
     SYS_CONTEXT: global system context

     DB: the db object concerned (used to calculate time origin)

     Returns a timestamp suitable for db usage, (seconds since object
     creation) set to the current moment.  The reason we don't use
     regular timestamps is that they are 1) too accurate (msec is
     useless for what's involved here) and 2) too big and likely to be
     negative in signed mode even if converted to seconds.

     *Return value:* a timestamp, 0 means "beginning of program" (think
     of it as uptime)

 -- Function: lw6p2p_entry_t * lw6p2p_entry_new (lw6sys_context_t *
          SYS_CONTEXT, int CREATION_TIMESTAMP, char * VERSION, char *
          CODENAME, int STAMP, char * ID, char * URL, char * TITLE, char
          * DESCRIPTION, int HAS_PASSWORD, int BENCH, int OPEN_RELAY,
          char * COMMUNITY_ID, int ROUND, char * LEVEL, int
          REQUIRED_BENCH, int NB_COLORS, int MAX_NB_COLORS, int
          NB_CURSORS, int MAX_NB_CURSORS, int NB_NODES, int
          MAX_NB_NODES, char * IP, int PORT, int LAST_PING_TIMESTAMP,
          int PING_DELAY_MSEC, int AVAILABLE)
     SYS_CONTEXT: global system context

     CREATION_TIMESTAMP: when it has been created, UNIX timestamp

     VERSION: version of the node

     CODENAME: codename of the node

     STAMP: stamp of the node

     ID: id of the node (string representation)

     URL: public url of the node

     TITLE: title of the node

     DESCRIPTION: description of the node

     HAS_PASSWORD: wether node is password protected or not

     BENCH: node bench

     OPEN_RELAY: wether the node is in open relay mode or not

     ROUND: current round

     LEVEL: current level played

     REQUIRED_BENCH: current bench

     NB_COLORS: number of colors playing

     MAX_NB_COLORS: maximum number of colors

     NB_CURSORS: number of cursors playing

     MAX_NB_CURSORS: maximum number of cursors

     NB_NODES: number of nodes playing

     MAX_NB_NODES: maximum number of nodes

     IP: node ip (string representation)

     PORT: node port

     LAST_PING_TIMESTAMP: UNIX timestamp of last contact with node

     PING_DELAY_MSEC: ping delay, in milliseconds

     AVAILABLE: wether node is available, wether we can connect to it

     Creates a new p2p entry.  Will accept NULL parameters for strings
     as well as arbitrary long strings, will simply cut them short if
     there aren't already limited to max size.

     *Return value:* newly allocated object

 -- Function: void lw6p2p_entry_free (lw6sys_context_t * SYS_CONTEXT,
          lw6p2p_entry_t * ENTRY)
     SYS_CONTEXT: global system context

     ENTRY: entry to free

     Frees a p2p entry.

     *Return value:* none.

 -- Function: char * lw6p2p_entry_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6p2p_entry_t * ENTRY)
     SYS_CONTEXT: global system context

     ENTRY: entry to represent

     Gives a human-readable representation of the entry

     *Return value:* dynamically allocated string

 -- Function: lw6p2p_node_t * lw6p2p_node_new (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV, lw6p2p_db_t * DB,
          char * CLIENT_BACKENDS, char * SERVER_BACKENDS, char *
          BIND_IP, int BIND_PORT, int BROADCAST, u_int64_t NODE_ID, char
          * PUBLIC_URL, char * TITLE, char * DESCRIPTION, char *
          PASSWORD, int BENCH, int OPEN_RELAY, char * KNOWN_NODES, int
          NETWORK_RELIABILITY, int TROJAN)
     SYS_CONTEXT: global system context

     ARGC: number of args, as passed to 'main'

     ARGV: args array, as passed to 'main'

     DB: the database to use

     CLIENT_BACKENDS: the list of client backends to use

     SERVER_BACKENDS: the list of server backends to use

     BIND_IP: the IP address to bind on

     BIND_PORT: the IP port to listen on

     BROADCAST: wether broadcast is allowed on this node

     NODE_ID: the node id

     PUBLIC_URL: the public URL we want to show

     TITLE: the title of the node

     DESCRIPTION: the description of the node

     PASSWORD: the password to use

     BENCH: the bench of the node (its power)

     OPEN_RELAY: act as an open relay or not

     KNOWN_NODES: list of already known nodes

     NETWORK_RELIABILITY: drop 1 packet out of X

     TROJAN: act as a stupid trojan to test out automatic kick-off

     Creates a new "pear to pear" node.  This will fire the server and
     allow client access, on demand.  A lot of stuff can be done in the
     background once this is called.

     *Return value:* a pointer on the newly created objects.

 -- Function: void lw6p2p_node_free (lw6sys_context_t * SYS_CONTEXT,
          lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: the node to free

     Frees a node object, all network communications will be shut.

     *Return value:* none.

 -- Function: char * lw6p2p_node_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: the node to work on

     Gives a readable representation of the node

     *Return value:* a dynamically allocated string

 -- Function: int lw6p2p_node_poll (lw6sys_context_t * SYS_CONTEXT,
          lw6p2p_node_t * NODE, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     NODE: the node to poll

     PROGRESS: progress indicator to show the advancement

     Polls a p2p node.  This must be called on a regular basis, else
     network communication is stalled.

     *Return value:* 1 on success, 0 on error.

 -- Function: void lw6p2p_node_close (lw6sys_context_t * SYS_CONTEXT,
          lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: the node to close

     Closes a p2p node.  Closing is necessary in some contexts, for
     instance scheme/smob instanciation when you want to release the
     object ressources (sockets, ports, threads...)  *before* it is
     deleted by, for instance, a garbage collector.

     *Return value:* 1 on success, 0 on error.

 -- Function: u_int64_t lw6p2p_node_get_id (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: the node to query

     Returns the node id, an id which is supposed to uniquely identify
     the node at run-time.

     *Return value:* numerical id.

 -- Function: lw6sys_list_t * lw6p2p_node_get_entries (lw6sys_context_t
          * SYS_CONTEXT, lw6p2p_node_t * NODE, int SKIP_LOCAL)
     SYS_CONTEXT: global system context

     NODE: node to query

     SKIP_LOCAL: wether to skip local node, 1 to skip, 0 to keep

     Returns a list of all known nodes, this is a plain table dump,
     sorted so that the most likely to be interesting to connect oneself
     to are listed *last*, this is just a (little) optimization, since
     we know we'll need to parse this list to construct a Guile object,
     we reverse the order.

     *Return value:* list object containing 'lw6p2p_entry_t' objects

 -- Function: int lw6p2p_node_server_start (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE, int64_t SEQ_0)
     SYS_CONTEXT: global system context

     NODE: node to start

     SEQ_0: seq when starting the server

     Starts a node in server mode, if node was previously connected to
     other nodes, disconnect it from any peer.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6p2p_node_client_join (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE, u_int64_t REMOTE_ID, const
          char * REMOTE_URL, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     NODE: node to use

     REMOTE_ID: id of remote node to join

     REMOTE_URL: url of remote node to join

     PROGRESS: progress indicator to show end-user the advancement of
     process

     Starts a node in client mode, joins the given node, if node was
     previously connected to other nodes, disconnect it from any peer.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6p2p_node_refresh_peer (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE, u_int64_t REMOTE_ID, const
          char * REMOTE_URL)
     SYS_CONTEXT: global system context

     NODE: node to use

     REMOTE_ID: id of remote node to refresh

     REMOTE_URL: url of remote node to refresh

     Forces a refresh of a remote node, that is, try and get more
     up-to-date informations from it, not waiting for the standard
     update schedule.

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6p2p_node_disconnect (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: node to disconnect

     Disconnects a node, if node was previously connected to other
     nodes, disconnect it from any peer.  Note that this does not affect
     out-of-band connections, only real game-related links.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6p2p_node_update_info (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE, int ROUND, const char *
          LEVEL, int NB_COLORS, int MAX_NB_COLORS, int NB_CURSORS, int
          MAX_NB_CURSORS, int NB_NODES, int MAX_NB_NODES, int
          GAME_SCREENSHOT_SIZE, void * GAME_SCREENSHOT_DATA)
     SYS_CONTEXT: global system context

     NODE: node to update

     ROUND: the current round (can have an offset with real round
     number)

     LEVEL: the name of the current level (map)

     NB_COLORS: number of colors playing

     MAX_NB_COLORS: max number of colors allowed

     NB_CURSORS: number of cursors playing

     MAX_NB_CURSORS: max number of cursors allowed

     NB_NODES: number of nodes playing

     MAX_NB_NODES: max number of nodes allowed

     GAME_SCREENSHOT_SIZE: size of screenshot (bytes)

     GAME_SCREENSHOT_DATA: screenshot data (byte buffer, contains JPEG)

     Updates node info, that is, all the data/metadata which can be
     displayed to other peers and are, by nature, dynamic.

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6p2p_node_calibrate (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE, int64_t TIMESTAMP, int64_t
          SEQ)
     SYS_CONTEXT: global system context

     NODE: the object to calibrate

     TIMESTAMP: the current ticks setting (1000 ticks per second)

     SEQ: the round expected to be returned with this ticks value

     Calibrates the node, so that sequence numbering is consistent
     accross nodes.

     *Return value:* none.

 -- Function: int64_t lw6p2p_node_get_local_seq_0 (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: the object to query

     Gets the reference local seq_0 for this node, the information is
     taken from the warehouse, even if node->calibrate_seq should
     probably return the same value.

     *Return value:* the seq.

 -- Function: int64_t lw6p2p_node_get_local_seq_last (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: the object to query

     Gets the local seq_last for this node, the information is taken
     from the warehouse, which has parsed the messages and this
     information can in return be used to avoid maintaining outside of
     the node the information about what was the last seq used for a
     local message.

     *Return value:* the seq.

 -- Function: int64_t lw6p2p_node_get_seq_min (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: the object to query

     Gets the minimum seq registered, not of utmost importance but
     interesting for debugging purpose, to check what's in the
     warehouse.

     *Return value:* the seq.

 -- Function: int64_t lw6p2p_node_get_seq_max (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: the object to query

     Gets the maximum seq registered, this is typically used for
     guessing which seq might make sense for this node, but in a real
     example one should rely on algorithm/ker-side kept values.

     *Return value:* the seq.

 -- Function: int64_t lw6p2p_node_get_seq_draft (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: the object to query

     Gets the seq of the current draft as the warehouse understands it.
     Note that it's the responsibility of the caller to update the pilot
     according to this, this information is just about what is in the
     warehouse, not necessarly what is in the pilot / game_state.

     *Return value:* the seq.

 -- Function: int64_t lw6p2p_node_get_seq_reference (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: the object to query

     Gets the seq of the current reference as the warehouse understands
     it.  Note that it's the responsibility of the caller to update the
     pilot according to this, this information is just about what is in
     the warehouse, not necessarly what is in the pilot / game_state.

     *Return value:* the seq.

 -- Function: int lw6p2p_node_is_peer_connected (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE, u_int64_t PEER_ID)
     SYS_CONTEXT: global system context

     NODE: the object to query

     PEER_ID: id of the peer we want to check

     Tests wether the node is connected to us.  This is a different
     question from being registered, being connected means there's a
     tentacle connected to the peer, but it does not necessarly means
     this peer actively takes part in the game.

     *Return value:* 1 if connected, 0 if not.

 -- Function: int lw6p2p_node_is_peer_registered (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE, u_int64_t PEER_ID)
     SYS_CONTEXT: global system context

     NODE: the object to query

     PEER_ID: id of the peer we want to check

     Tests wether the node is registered within the warehouse.  This is
     a different question from being connected, being registered means
     we received a message (possibly from another peer) that means "this
     peer is part of the game" regardless of the fact it's connected or
     not.  Returns true if test is performed with the local id.

     *Return value:* 1 if registered, 0 if not.

 -- Function: int lw6p2p_node_is_seed_needed (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: node to query

     Returns true (1) if the local node needs to send a SEED message.  A
     SEED message will basically be sent at the beginning of a session
     when a client connects to a server.  Basically this message is of
     no use but it's interesting to have a short message (not DUMP) to
     start with.

     *Return value:* 1 if SEED must be sent.

 -- Function: int lw6p2p_node_is_dump_needed (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: node to query

     Returns true (1) if the local node needs to send a DUMP message.  A
     DUMP message will basically reset level, game struct, game state,
     it's typically sent when a new player is connected.  This function
     will return true once then always 0 so one should really act and do
     something whenever it's called and returns 1.

     *Return value:* 1 if DUMP must be sent.

 -- Function: int lw6p2p_node_put_local_msg (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE, const char * MSG)
     SYS_CONTEXT: global system context

     NODE: node object to use

     MSG: message

     Puts a message in the object.  The message will be splitted into
     several atoms if needed, it can be arbitrary long.

     *Return value:* 1 on success, 0 on error

 -- Function: char * lw6p2p_node_get_next_reference_msg
          (lw6sys_context_t * SYS_CONTEXT, lw6p2p_node_t * NODE,
          lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     NODE: node to query

     PROGRESS: progress indicator (read/write)

     Get the next waiting reference msg.  This is used to maintain the
     stable reference game state we can rely upon.  One is supposed to
     call this until it returns NULL, then switch draft messages.

     *Return value:* newly allocated string, must be freed.

 -- Function: char * lw6p2p_node_get_next_draft_msg (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE, lw6sys_progress_t *
          PROGRESS)
     SYS_CONTEXT: global system context

     NODE: node to query

     PROGRESS: progress indicator (read/write)

     Get the next waiting draft msg.  This is used to maintain the
     anticipated draft game state we use for drawing.  One is supposed
     to call this after all reference messages have been treated.

     *Return value:* newly allocated string, must be freed.

 -- Function: int lw6p2p_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libp2p module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6p2p_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'p2p' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6p2p_db_s

     Handler on a database connection, this must be used to pass order
     to store/retrieve persistent informations about peers.

 -- Member of lw6p2p_db_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6p2p_db_s::id'

     The first member, id, is the same as the internal _lw6p2p_db_t
     structure.  The rest of it is hidden.  The program will cast from
     lw6p2p_db_t to _lw6p2p_db_t internally.

 -- Struct: lw6p2p_entry_s

     This entry object matches as close as possible the corresponding
     (node) entry in the database.

 -- Member of lw6p2p_entry_s: creation_timestamp
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::creation_timestamp'

     Node creation timestamp.

 -- Member of lw6p2p_entry_s: version
     *Type:* 'char'

     *Definition:* 'char lw6p2p_entry_s::version[LW6P2P_VERSION_SIZE+1]'

     Node version.

 -- Member of lw6p2p_entry_s: codename
     *Type:* 'char'

     *Definition:* 'char
     lw6p2p_entry_s::codename[LW6P2P_CODENAME_SIZE+1]'

     Node codename.

 -- Member of lw6p2p_entry_s: stamp
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::stamp'

     Node stamp.

 -- Member of lw6p2p_entry_s: id
     *Type:* 'char'

     *Definition:* 'char lw6p2p_entry_s::id[LW6P2P_ID_SIZE+1]'

     Node id, 64-bit integer as an hexa string.

 -- Member of lw6p2p_entry_s: url
     *Type:* 'char'

     *Definition:* 'char lw6p2p_entry_s::url[LW6P2P_URL_SIZE+1]'

     Node URL, the public URL it displays to others.

 -- Member of lw6p2p_entry_s: title
     *Type:* 'char'

     *Definition:* 'char lw6p2p_entry_s::title[LW6P2P_TITLE_SIZE+1]'

     Node title, the short readable name for the node.

 -- Member of lw6p2p_entry_s: description
     *Type:* 'char'

     *Definition:* 'char
     lw6p2p_entry_s::description[LW6P2P_DESCRIPTION_SIZE+1]'

     Node description, mode details about this node.

 -- Member of lw6p2p_entry_s: has_password
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::has_password'

     Wether it requires a password or not.

 -- Member of lw6p2p_entry_s: bench
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::bench'

     Node bench, reflects how powerfull it is.

 -- Member of lw6p2p_entry_s: open_relay
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::open_relay'

     Wether this node acts as an open relay or not.

 -- Member of lw6p2p_entry_s: community_id
     *Type:* 'char'

     *Definition:* 'char
     lw6p2p_entry_s::community_id[LW6P2P_COMMUNITY_ID_SIZE+1]'

     Community id, 64-bit integer as an hexa string.

 -- Member of lw6p2p_entry_s: round
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::round'

     Current round.

 -- Member of lw6p2p_entry_s: level
     *Type:* 'char'

     *Definition:* 'char lw6p2p_entry_s::level[LW6P2P_LEVEL_SIZE+1]'

     Level used.

 -- Member of lw6p2p_entry_s: required_bench
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::required_bench'

     Required bench to connect to this community.

 -- Member of lw6p2p_entry_s: nb_colors
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::nb_colors'

     Number of colors playing.

 -- Member of lw6p2p_entry_s: max_nb_colors
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::max_nb_colors'

     Maximum number of colors allowed to play.

 -- Member of lw6p2p_entry_s: nb_cursors
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::nb_cursors'

     Number of cursors playing.

 -- Member of lw6p2p_entry_s: max_nb_cursors
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::max_nb_cursors'

     Maximum number of cursors allowed to play.

 -- Member of lw6p2p_entry_s: nb_nodes
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::nb_nodes'

     Number of nodes playing.

 -- Member of lw6p2p_entry_s: max_nb_nodes
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::max_nb_nodes'

     Maximum number of nodes playing.

 -- Member of lw6p2p_entry_s: ip
     *Type:* 'char'

     *Definition:* 'char lw6p2p_entry_s::ip[LW6P2P_IP_SIZE+1]'

     IP addess of node.

 -- Member of lw6p2p_entry_s: port
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::port'

     IP port of node.

 -- Member of lw6p2p_entry_s: last_ping_timestamp
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::last_ping_timestamp'

     Last time this node has been pinged.

 -- Member of lw6p2p_entry_s: ping_delay_msec
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::ping_delay_msec'

     Ping delay, in milliseconds.

 -- Member of lw6p2p_entry_s: available
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::available'

     Wether this node is ready to accept connections.

 -- Struct: lw6p2p_node_s

     Node object, the main network object, this one will encaspulate
     everything else, the node can connect to other peers, listen on the
     network, it's the high-level interface.

 -- Member of lw6p2p_node_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6p2p_node_s::id'

     The first member, id, is the same as the internal _lw6p2p_node_t
     structure.  The rest of it is hidden.  The program will cast from
     lw6p2p_node_t to _lw6p2p_node_t internally.


File: liquidwar6.info,  Node: libpil,  Next: libscm,  Prev: libp2p,  Up: C API

5.37 libpil
===========

5.37.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/pil/index.html>.

5.37.2 API
----------

 -- Function: int lw6pil_bench (lw6sys_context_t * SYS_CONTEXT, int
          ARGC, const char * [] ARGV, float * BENCH_RESULT,
          lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     ARGC: number of args as passed to main

     ARGV: args passed to main

     BENCH_RESULT: pointer to float, will contain the bench result

     PROGRESS: to inform the caller of the process advancement

     Runs a standard, normalized bench on a default map.  Results can be
     interpreted as an estimated speed/power of your computer.

     *Return value:* 1 on success, 0 if failure

 -- Function: lw6pil_command_t * lw6pil_command_new (lw6sys_context_t *
          SYS_CONTEXT, const char * COMMAND_TEXT, int64_t SEQ_0, int
          ROUND_0)
     SYS_CONTEXT: global system context

     COMMAND_TEXT: readable text of the command

     SEQ_0: sequence offset reference (to calculate difference between
     sequence and rounds)

     ROUND_0: round offset reference (to calculate difference between
     sequence and rounds)

     Creates a new command from its text representation.

     *Return value:* newly allocated object

 -- Function: lw6pil_command_t * lw6pil_command_dup (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_command_t * COMMAND)
     SYS_CONTEXT: global system context

     COMMAND: object to duplicate

     Creates a copy of a command struct.

     *Return value:* newly allocated object.

 -- Function: void lw6pil_command_free (lw6sys_context_t * SYS_CONTEXT,
          lw6pil_command_t * COMMAND)
     SYS_CONTEXT: global system context

     COMMAND: command to free

     Frees a command struct, with all its members.

     *Return value:* none.

 -- Function: char * lw6pil_command_repr (lw6sys_context_t *
          SYS_CONTEXT, const lw6pil_command_t * COMMAND)
     SYS_CONTEXT: global system context

     COMMAND: command to represent

     Gives a readable representation of a command.

     *Return value:* dynamically allocated string.

 -- Function: int lw6pil_command_execute (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_dump_t * DUMP, int64_t TIMESTAMP,
          lw6ker_game_state_t * GAME_STATE, lw6pil_command_t * COMMAND)
     SYS_CONTEXT: global system context

     DUMP: pointer on dump structure (out param, can be NULL)

     TIMESTAMP: current timestamp (can be 0 if dump is NULL)

     GAME_STATE: game state to work on, can be NULL (usefull for DUMP)

     COMMAND: command to process

     Interprets a command and runs it against game_state.  If dump and
     timestamp are set, then any DUMP command will fill the dump
     structure with the right values.  If not running from a pilot
     context, this is useless, use NULL and 0LL.

     *Return value:* 1 if ok, 0 if failed.

 -- Function: int lw6pil_command_execute_text (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_dump_t * DUMP, int64_t TIMESTAMP,
          lw6ker_game_state_t * GAME_STATE, const char * COMMAND_TEXT,
          int64_t SEQ_0)
     SYS_CONTEXT: global system context

     DUMP: pointer on dump structure (out param, can be NULL)

     TIMESTAMP: current timestamp (can be 0 if dump is NULL)

     GAME_STATE: game state to work on, can be NULL (typically for DUMP)

     COMMAND_TEXT: command text to process

     SEQ_0: reference seq_0, used to genereate consistent dumps if
     needed

     Interprets a command text and runs it against game_state.  If dump
     and timestamp are set, then any DUMP command will fill the dump
     structure with the right values.  If not running from a pilot
     context, this is useless, use NULL and 0LL.

     *Return value:* 1 if ok, 0 if failed.

 -- Function: int lw6pil_command_execute_local (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_local_cursors_t * LOCAL_CURSORS,
          lw6pil_command_t * COMMAND)
     SYS_CONTEXT: global system context

     LOCAL_CURSORS: local cursors information

     COMMAND: command to execute

     Executes a local command, typically a cursor move, on the
     local_cursor struct, without changing any game state.

     *Return value:* 1 if success, 0 if failure.

 -- Function: int lw6pil_command_execute_local_text (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_local_cursors_t * LOCAL_CURSORS, const
          char * COMMAND_TEXT)
     SYS_CONTEXT: global system context

     LOCAL_CURSORS: local cursors information

     COMMAND_TEXT: command text to execute

     Executes a local command text, typically a cursor move, on the
     local_cursor struct, without changing any game state.

     *Return value:* 1 if success, 0 if failure.

 -- Function: void lw6pil_coords_fix (lw6sys_context_t * SYS_CONTEXT,
          lw6map_rules_t * RULES, lw6sys_whd_t * SHAPE, float * X, float
          * Y, float * Z)
     SYS_CONTEXT: global system context

     RULES: the set of rules to use (defines polarity)

     SHAPE: the shape of the map (logical part)

     X: the x coord to fix

     Y: the y coord to fix

     Z: the z coord to fix

     Similar to 'lw6map_coords_fix' but using floats, this function can
     be used to check cursor position boundaries.  Any float pointer can
     be NULL.

     *Return value:* none.

 -- Function: void lw6pil_coords_fix_x10 (lw6sys_context_t *
          SYS_CONTEXT, lw6map_rules_t * RULES, lw6sys_whd_t * SHAPE,
          float * X, float * Y, float * Z)
     SYS_CONTEXT: global system context

     RULES: the set of rules to use (defines polarity)

     SHAPE: the shape of the map (logical part)

     X: the x coord to fix

     Y: the y coord to fix

     Z: the z coord to fix

     Similar to 'lw6pil_coords_fix' but does use a wider range, say 10
     times the actual size of the map, this is not to contain the cursor
     within the map but just to avoid overflow errors.

     *Return value:* none.

 -- Function: void lw6pil_dump_zero (lw6sys_context_t * SYS_CONTEXT,
          lw6pil_dump_t * DUMP)
     SYS_CONTEXT: global system context

     DUMP: object to initialize

     Fills a dump object with zero, regardless of what was there before.

     *Return value:* none.

 -- Function: void lw6pil_dump_clear (lw6sys_context_t * SYS_CONTEXT,
          lw6pil_dump_t * DUMP)
     SYS_CONTEXT: global system context

     DUMP: object to clear

     Clears a dump object, that is, frees all existing object if they
     are here, and sets pointers to NULL.

     *Return value:* none.

 -- Function: int lw6pil_dump_exists (lw6sys_context_t * SYS_CONTEXT,
          const lw6pil_dump_t * DUMP)
     SYS_CONTEXT: global system context

     DUMP: object to test

     Tests wether there's actually a dump in the structure, or if it's
     empty.

     *Return value:* 1 if there's a dump, 0 if all fields set to NULL.

 -- Function: char * lw6pil_dump_command_generate (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_pilot_t * PILOT, u_int64_t SERVER_ID,
          int64_t SEQ)
     SYS_CONTEXT: global system context

     PILOT: the pilot to transform as a DUMP.

     SERVER_ID: ID of server issuing the command

     SEQ: seq at which the dump should be generated

     Creates the DUMP command for a given pilot, that is, a command that
     describes the whole data and state.  One must give a sequence
     number since the dump would otherwise typically be *always* late by
     at least one round (or seq).  We give the seq as we would for any
     message generated, to make it fit well within the standard message
     queue.

     *Return value:* newly allocated string

 -- Function: int lw6pil_dump_command_execute (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_dump_t * DUMP, int64_t TIMESTAMP,
          lw6pil_command_t * COMMAND, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     DUMP: will contain the dump data, pilot and game state, struct, and
     level

     TIMESTAMP: current timestamp

     COMMAND: the command to execute

     PROGRESS: progress object to show the advancement of process

     Interprets a DUMP command.  A new pilot will be returned, along
     with game state, game struct and level.  Old objects won't be
     deleted, but you could (should) get rid of them at they are useless
     now.

     *Return value:* newly allocated string

 -- Function: void lw6pil_local_cursors_reset (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_local_cursors_t * LOCAL_CURSORS)
     SYS_CONTEXT: global system context

     LOCAL_CURSORS: the structure to reset

     Resets a local cursors struct.  Note that this need not be called
     very often, in fact the local cursors can cope with "dead" cursors
     easily.  In practise, in a local game, there are only 4 of them,
     great maximum.

     *Return value:* none.

 -- Function: lw6pil_local_cursor_t * lw6pil_local_cursors_get_cursor
          (lw6sys_context_t * SYS_CONTEXT, lw6pil_local_cursors_t *
          LOCAL_CURSORS, u_int16_t CURSOR_ID)
     SYS_CONTEXT: global system context

     LOCAL_CURSORS: the structure to query

     CURSOR_ID: the id of the cursor to query

     Returns a pointer on the cursor with the given id.

     *Return value:* a pointer (must *not* be freed) which is NULL is
     cursor does not exist.

 -- Function: int lw6pil_local_cursors_get_info (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_local_cursors_t * LOCAL_CURSORS, int * X,
          int * Y, int * MOUSE_CONTROLLED, u_int16_t CURSOR_ID)
     LOCAL_CURSORS: the structure to query

     X: a pointer to the x position, may be NULL

     Y: a pointer to the y position, may be NULL

     MOUSE_CONTROLLED: a pointer to the mouse_controlled flag, may be
     NULL

     CURSOR_ID: the id of the cursor to query

     Gets the x,y position of the cursor, and tells if it's mouse
     controlled.

     *Return value:* 1 on success (cursor exists), 0 on failure (no such
     cursor).

 -- Function: int lw6pil_local_cursors_set_xy (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_local_cursors_t * LOCAL_CURSORS, u_int16_t
          CURSOR_ID, int X, int Y)
     SYS_CONTEXT: global system context

     LOCAL_CURSORS: the structure to modify

     CURSOR_ID: the id of the cursor to modify

     X: the x position

     Y: the y position

     Sets the position of a cursor in the local cursors struct.  If
     cursor does not exists, it's appended to the list.

     *Return value:* 1 on success (cursor exists), 0 on failure (no such
     cursor).

 -- Function: int lw6pil_local_cursors_set_mouse_controlled
          (lw6sys_context_t * SYS_CONTEXT, lw6pil_local_cursors_t *
          LOCAL_CURSORS, u_int16_t CURSOR_ID, int MOUSE_CONTROLLED)
     SYS_CONTEXT: global system context

     LOCAL_CURSORS: the structure to modify

     CURSOR_ID: the id of the cursor to modify

     MOUSE_CONTROLLED: the mouse_controlled attribute

     Sets which cursor is mouse controlled.  If mouse_controlled is 1,
     the flag is set for this cursor and cleared for all others.  If set
     to 0, only this cursor's flag is cleared.

     *Return value:* 1 on success (cursor exists), 0 on failure (no such
     cursor).

 -- Function: int lw6pil_local_cursors_get_main_info (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_local_cursors_t * LOCAL_CURSORS, u_int16_t
          * CURSOR_ID, int * X, int * Y, int * MOUSE_CONTROLLED)
     SYS_CONTEXT: global system context

     LOCAL_CURSORS: the structure to query

     CURSOR_ID: the id of the main cursor, may be NULL

     X: a pointer to the x position, may be NULL

     Y: a pointer to the y position, may be NULL

     MOUSE_CONTROLLED: a pointer to the mouse_controlled flag, may be
     NULL

     Gets the x,y position of the main cursor, and tells if it's mouse
     controlled.

     *Return value:* 1 on success (cursor exists), 0 on failure (no such
     cursor).

 -- Function: int lw6pil_local_cursors_set_main (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_local_cursors_t * LOCAL_CURSORS, u_int16_t
          CURSOR_ID)
     SYS_CONTEXT: global system context

     LOCAL_CURSORS: the structure to modify

     CURSOR_ID: the id of the cursor to be labelled as main cursor

     Sets the main cursor attribute, the main cursor is later used, for
     instance, to decide how to display the map (centered on it, for
     instance).

     *Return value:* 1 on success (cursor exists), 0 on failure (no such
     cursor).

 -- Function: int lw6pil_nopilot_poll_dump (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_dump_t * DUMP, const char * COMMAND_TEXT,
          int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     DUMP: will contain the dump information if needed, can be NULL

     COMMAND_TEXT: the command received from the network.

     TIMESTAMP: timestamp, used to initialize the pilot

     Normally, it's the commit function of the pilot which will
     automatically return a dump if needed.  But...  when a client
     connects, at first, it has absolutely no pilot/map whatsoever yet,
     so this is just to bootstrap the process, this function will take
     network messages, any message, and if it's about a dump -> it will
     create the dump.

     *Return value:* 1 on success, 0 on failure.

 -- Function: lw6pil_pilot_t * lw6pil_pilot_new (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, int64_t SEQ_0,
          int64_t TIMESTAMP, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     GAME_STATE: the game state we're going to work on

     SEQ_0: the start sequence to use, that is, the seq at round=0

     TIMESTAMP: the current ticks (1000 ticks per sec, used to
     calibrate)

     PROGRESS: object used to show the advancement of the process

     Initializes a 'pilot' object, this object is responsible for
     interpreting messages, transform them into low-level 'ker' module
     function calls, and handle all the thread-spooky stuff.

     *Return value:* a working pilot object.  May be NULL on memory
     failure.

 -- Function: void lw6pil_pilot_free (lw6sys_context_t * SYS_CONTEXT,
          lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: the object to free.

     Frees a 'pilot' object, note that this might involve joining some
     threads, so it can 'take some time'.

     *Return value:* none.

 -- Function: int lw6pil_pilot_send_command (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_pilot_t * PILOT, const char *
          COMMAND_TEXT, int VERIFIED)
     SYS_CONTEXT: global system context

     PILOT: the object to send commands to.

     COMMAND_TEXT: the text of the command, as received form network

     VERIFIED: wether we're sure this message is valid.

     Sends a command and handles it internally.

     *Return value:* 1 if OK, 0 if not.

 -- Function: int lw6pil_pilot_local_command (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_pilot_t * PILOT, const char *
          COMMAND_TEXT)
     SYS_CONTEXT: global system context

     PILOT: the object to apply the local command on

     COMMAND_TEXT: the command text

     This function is used to fix the annoying fact that by only sending
     commands a limited number of times per sec to the game state, the
     display always reflect an outdated position for cursors.  But
     players do not want to see this, they want to see the cursor in the
     right place.  So what we do is that the pilot can process "local"
     commands which have absolutely no effect on the game but simply
     update a local cursor state, only used for display.  It's here in
     the pil module for it's where the command interpreting code is, and
     the fact that there's this lag is directly linked with the pilot
     way of doing things.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6pil_pilot_commit (lw6sys_context_t * SYS_CONTEXT,
          lw6pil_dump_t * DUMP, lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     DUMP: will contain the dump information if needed, can be NULL

     PILOT: the object to commit.

     Commits all commands sent and actually send them to the
     corresponding threads.  This commit system allows better
     performance by sending, for instance, all the commands for a given
     round together.

     *Return value:* none.

 -- Function: int lw6pil_pilot_make_backup (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: the object to perform the backup on

     Makes a new backup in the pilot, that is, copy 'reference' to
     'backup'.

     *Return value:* 1 if OK, 0 if not.

 -- Function: int lw6pil_pilot_can_sync (lw6sys_context_t * SYS_CONTEXT,
          lw6ker_game_state_t * TARGET, lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     TARGET: the target game_state we would sync on

     PILOT: the object to perform the backup on

     Tests wether sync functions are callable with a given game state.
     It verifies if the internal game_state and the target look the
     same.

     *Return value:* 1 if sync functions can be called, 0 if not.

 -- Function: int lw6pil_pilot_sync_from_backup (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * TARGET, lw6pil_pilot_t *
          PILOT)
     SYS_CONTEXT: global system context

     TARGET: the game_state structure which will get the informations.

     PILOT: the object to get informations from.

     Gets the backup from the pilot object.  This is the last snapshot
     taken by 'make_backup' or, by default, the game_state the pilot was
     constructed with.

     *Return value:* 1 if OK, 0 if not.

 -- Function: int lw6pil_pilot_sync_from_reference (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * TARGET, lw6pil_pilot_t *
          PILOT)
     SYS_CONTEXT: global system context

     TARGET: the game_state structure which will get the informations.

     PILOT: the object to get informations from.

     Gets the latest reference game_state, that is, a stable snapshot of
     the game, with no inconsistency, a game position that exists and
     that we can rely on.  Note that getting this can take time since a
     global mutex is required, and computations must end before you get
     the data.

     *Return value:* 1 if OK, 0 if not.

 -- Function: int lw6pil_pilot_sync_from_draft (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * TARGET, lw6pil_pilot_t *
          PILOT, int DIRTY_READ)
     SYS_CONTEXT: global system context

     TARGET: the game_state structure which will get the informations.

     PILOT: the object to get informations from.

     DIRTY_READ: wether to allow dirty read or not

     Gets the informations from the pilot object, not being worried
     about game consistency, this one will just return the latest
     version available.  It might even be in an inconsistent state, the
     position could reflect a position which will never exist.  Still,
     the data returned will not correspond to a half-spread or
     half-moved game_state if dirty_read is set to 0.  In this case the
     data has at least some basic consistency and getting this does
     require some mutex lock, however wait time should be fairly small
     (max.  a round).  But, in a general manner, this function is only
     used for display, and we do not care much if there's a small
     glitch, we prefer fast & smooth display.

     *Return value:* 1 if OK, 0 if not.

 -- Function: lw6ker_game_state_t * lw6pil_pilot_dirty_read
          (lw6sys_context_t * SYS_CONTEXT, lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: the object to get informations from.

     Returns a direct access to the most up-to-date game_state, without
     locking anything whatsoever.  This is clearly to implement a dirty
     read mode as the name of the function suggests.

     *Return value:* 1 if OK, 0 if not.

 -- Function: char * lw6pil_pilot_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     Returns a string describing the pilot.  This is a very short
     description, use it for logs, and to debug stuff.  By no means it's
     a complete exhaustive description.  Still, the string returned
     should be unique.

     *Return value:* a dynamically allocated string.

 -- Function: void lw6pil_pilot_calibrate (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_pilot_t * PILOT, int64_t TIMESTAMP,
          int64_t SEQ)
     SYS_CONTEXT: global system context

     PILOT: the object to calibrate

     TIMESTAMP: the current ticks setting (1000 ticks per second)

     SEQ: the round expected to be returned with this ticks value

     Calibrates the pilot, that is, initializes it so that subsequent
     calls to 'lw6pil_pilot_get_round' return consistent values.

     *Return value:* none.

 -- Function: void lw6pil_pilot_speed_up (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_pilot_t * PILOT, int SEQ_INC)
     SYS_CONTEXT: global system context

     PILOT: the pilot to speed up

     SEQ_INC: the number of seqs

     Re-calibrates the pilot so that it speeds up a bit.  This will
     basically increase next_seq by seq_inc.

     *Return value:* none.

 -- Function: void lw6pil_pilot_slow_down (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_pilot_t * PILOT, int SEQ_DEC)
     SYS_CONTEXT: global system context

     PILOT: the pilot to speed up

     SEQ_DEC: the number of seqs

     Re-calibrates the pilot so that it slows down a bit.  This will
     basically decrease next_seq by seq_inc.

     *Return value:* none.

 -- Function: int lw6pil_pilot_get_round_0 (lw6sys_context_t *
          SYS_CONTEXT, const lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: pilot object to query

     Get the initial round (the one passed at object construction) which
     says what the round was at object creation, it's just an offset.

     *Return value:* 64-bit integer

 -- Function: int64_t lw6pil_pilot_get_seq_0 (lw6sys_context_t *
          SYS_CONTEXT, const lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: pilot object to query

     Get the initial seq (the one passed at object construction) which
     says what the seq was at round=0, it's just an offset.

     *Return value:* 64-bit integer

 -- Function: int lw6pil_pilot_seq2round (lw6sys_context_t *
          SYS_CONTEXT, const lw6pil_pilot_t * PILOT, int64_t SEQ)
     SYS_CONTEXT: global system context

     PILOT: pilot object to work on

     SEQ: the seq to convert

     Converts a seq (64-bit) to a round (32-bit).  64-bit seqs are used
     to avoid out-of-range errors on very long games, OTOH a round is
     32-bit to garantee the atomicity of its affection, even on
     platforms which are not native 64-bit.

     *Return value:* the round (32-bit integer)

 -- Function: int64_t lw6pil_pilot_round2seq (lw6sys_context_t *
          SYS_CONTEXT, const lw6pil_pilot_t * PILOT, int ROUND)
     SYS_CONTEXT: global system context

     PILOT: pilot object to work on

     ROUND: the round to convert

     Converts a round (32-bit) to a seq (64-bit).  64-bit seqs are used
     to avoid out-of-range errors on very long games, OTOH a round is
     32-bit to garantee the atomicity of its affection, even on
     platforms which are not native 64-bit.

     *Return value:* the seq (64-bit integer)

 -- Function: int64_t lw6pil_pilot_get_next_seq (lw6sys_context_t *
          SYS_CONTEXT, const lw6pil_pilot_t * PILOT, int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     PILOT: the object to query

     TIMESTAMP: the current ticks setting (1000 ticks per second)

     Returns the seq one should use to generate new events/commands at a
     given time (given in ticks).

     *Return value:* none.

 -- Function: int64_t lw6pil_pilot_get_last_commit_seq (lw6sys_context_t
          * SYS_CONTEXT, const lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: the object to query

     Returns the seq of the last commit (reference game_state) for this
     object.

     *Return value:* the commit seq (reference object)

 -- Function: int64_t lw6pil_pilot_get_reference_target_seq
          (lw6sys_context_t * SYS_CONTEXT, const lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: the object to query

     Returns the seq which is targetted in the reference game_state,
     this is 'how far computation will go in the reference game_state if
     no new commands are issued'.  Note that there can always be some
     commands which are not yet processed, so you should not rely on
     this too heavily, however it gives a good idea of how things are
     going.

     *Return value:* the target seq (reference object)

 -- Function: int64_t lw6pil_pilot_get_reference_current_seq
          (lw6sys_context_t * SYS_CONTEXT, const lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: the object to query

     Returns the current seq in the reference game_state.  There's no
     lock on this call so don't rely on this too heavily, it just gives
     you an idea of wether the pilot is very late on its objectives or
     just on time.

     *Return value:* the current seq (reference object)

 -- Function: int64_t lw6pil_pilot_get_max_seq (lw6sys_context_t *
          SYS_CONTEXT, const lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: the object to query

     Returns the max current seq in the reference or draft game states.
     No lock on this call so don't rely on this too heavily, it just
     gives you an idea of computation state.

     *Return value:* the current seq (reference object)

 -- Function: int lw6pil_pilot_is_over (lw6sys_context_t * SYS_CONTEXT,
          const lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: the object to query

     Tells wether the game is over or not.

     *Return value:* 1 if over, 0 if not

 -- Function: int lw6pil_pilot_did_cursor_win (lw6sys_context_t *
          SYS_CONTEXT, const lw6pil_pilot_t * PILOT, u_int16_t
          CURSOR_ID)
     SYS_CONTEXT: global system context

     PILOT: the object to query

     CURSOR_ID: the cursor_id concerned

     Tells wether a given cursor was winner or not.

     *Return value:* 1 if over, 0 if not

 -- Function: int lw6pil_pilot_get_winner (lw6sys_context_t *
          SYS_CONTEXT, const lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: the object to query

     Gets the winner color.

     *Return value:* a team color, -1 if no winner and/or error.

 -- Function: int lw6pil_pilot_get_looser (lw6sys_context_t *
          SYS_CONTEXT, const lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: the object to query

     Gets the looser color.

     *Return value:* a team color, -1 if no looser and/or error.

 -- Function: lw6pil_local_cursors_t * lw6pil_pilot_get_local_cursors
          (lw6sys_context_t * SYS_CONTEXT, lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: object to query

     Returns a pointer on the local_cursors struct used within the
     object.  Beware, this is the *real* pointer, not a copy...

     *Return value:* pointer on internal object

 -- Function: void lw6pil_pilot_checksum_log_set_interval
          (lw6sys_context_t * SYS_CONTEXT, lw6pil_pilot_t * PILOT, int
          CHECKSUM_LOG_INTERVAL)
     SYS_CONTEXT: global system context

     PILOT: the pilot to track

     CHECKSUM_LOG_INTERVAL: dump interval, if 0, feature is disabled

     Debugging function used to set automatically an interval at which
     engine will log a checksum automatically.  This is typically to
     track down where and when there starts to be a difference between
     two game_states that have evolved separately.  This function will
     propagate the parameter to all the game_states handled by the
     pilot, each will log its informations separately.

     *Return value:* none

 -- Function: char * lw6pil_seed_command_generate (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_pilot_t * PILOT, u_int64_t SERVER_ID,
          int64_t SEQ)
     SYS_CONTEXT: global system context

     PILOT: the pilot to transform as a SEED.

     SERVER_ID: ID of server issuing the command

     SEQ: seq at which the dump should be generated

     Creates the SEED command for a given pilot, that is, a command that
     contains macro informations about the game state such as current
     seq.  It should be followed by a dump.

     *Return value:* newly allocated string

 -- Function: int64_t lw6pil_seq_random_0 (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Gets a pseudo-random start seq, why do we use this?  Just to make
     sure even in non-network situations, seq are always very high and
     random, this way this is one less bug to check in networked
     context.

     *Return value:* random integer value, always greater than INT_MAX

 -- Function: int lw6pil_suite_init (lw6sys_context_t * SYS_CONTEXT,
          lw6pil_dump_t * DUMP, int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     DUMP: dump to use as a base to init the suite (out param)

     TIMESTAMP: timestamp used for pilot creation (should be "now")

     Build the objects used by the test suite.  The idea is to wrap all
     this in a single function since it requires to be exactly the same
     every time as the test suite is very pedantic about checksums.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int64_t lw6pil_suite_get_seq_0 (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Get the base seq_0 for the reference test suite.

     *Return value:* 64-bit integer.

 -- Function: u_int64_t lw6pil_suite_get_node_id (lw6sys_context_t *
          SYS_CONTEXT, int NODE_INDEX)
     SYS_CONTEXT: global system context

     NODE_INDEX: index of the node we want informations about

     Get the node_id associated to an index, typically a 64-bit unique.
     The index is just a simple integer which is 0 for node A, 1 for
     node B, etc.

     *Return value:* the node id, as an unsigned 64-bit integer

 -- Function: const char * lw6pil_suite_get_command_by_node_index
          (lw6sys_context_t * SYS_CONTEXT, int NODE_INDEX, int STAGE,
          int STEP)
     SYS_CONTEXT: global system context

     NODE_INDEX: index of the node (not its id)

     STAGE: major stage of the test suite

     STEP: minor step of the test suite

     Get the reference test suite message by node_index, stage and step.

     *Return value:* static string, must not be freed.

 -- Function: const char * lw6pil_suite_get_command_by_stage
          (lw6sys_context_t * SYS_CONTEXT, int STAGE, int STEP)
     SYS_CONTEXT: global system context

     STAGE: major stage of the test suite

     STEP: minor step of the test suite

     Get the reference test suite message by stage and step.  Messages
     from various nodes are mixed and sorted.

     *Return value:* static string, must not be freed.

 -- Function: const char * lw6pil_suite_get_command_by_step
          (lw6sys_context_t * SYS_CONTEXT, int STEP)
     SYS_CONTEXT: global system context

     STEP: minor step of the test suite

     Get the reference test suite message by step.  Messages from
     various nodes and stages are mixed and sorted.

     *Return value:* static string, must not be freed.

 -- Function: void lw6pil_suite_get_checkpoint (lw6sys_context_t *
          SYS_CONTEXT, u_int32_t * GAME_STATE_CHECKSUM, int64_t * SEQ,
          int * ROUND, int STAGE)
     SYS_CONTEXT: global system context

     GAME_STATE_CHECKSUM: expected checksum for the given checkpoint
     (out param)

     SEQ: expected seq for the given checkpoint (out param)

     ROUND: expected round for the given checkpoint (out param)

     STAGE: stage to query checksum and other info about

     Gives the values which are expected for a given checkpoint.  If the
     right messages have been feeded, then these values are expected.

     *Return value:* none, everything in out params

 -- Function: int lw6pil_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libpil module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6pil_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'pil' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6pil_add_args_s

     Arguments passed to the ADD command.

 -- Member of lw6pil_add_args_s: cursor_id
     *Type:* 'u_int16_t'

     *Definition:* 'u_int16_t lw6pil_add_args_s::cursor_id'

     Cursor ID (16-bit non-zero unsigned int).

 -- Member of lw6pil_add_args_s: team_color
     *Type:* 'int'

     *Definition:* 'int lw6pil_add_args_s::team_color'

     Team color (0 to 9).

 -- Struct: lw6pil_command_s

     Command structure, contains both full-text version and parsed
     information.

 -- Member of lw6pil_command_s: seq
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6pil_command_s::seq'

     The sequence number, a very large 64-bit integer.  The sequence is
     here because the round wouldn't be able to stand multiple games for
     long as it is only 32-bit.  OTOH making round a 64-bit would cause
     multithread problems because of non-atomicity of 64-bit affectation
     on truely 32-bit platforms.

 -- Member of lw6pil_command_s: round
     *Type:* 'int'

     *Definition:* 'int lw6pil_command_s::round'

     The game round.

 -- Member of lw6pil_command_s: node_id
     *Type:* 'u_int64_t'

     *Definition:* 'u_int64_t lw6pil_command_s::node_id'

     The node ID issuing that command.

 -- Member of lw6pil_command_s: code
     *Type:* 'lw6pil_command_code_t'

     *Definition:* 'lw6pil_command_code_t lw6pil_command_s::code'

     The command code.

 -- Member of lw6pil_command_s: args
     *Type:* 'lw6pil_command_args_t'

     *Definition:* 'lw6pil_command_args_t lw6pil_command_s::args'

     The command arguments, parsed.

 -- Member of lw6pil_command_s: text
     *Type:* 'char *'

     *Definition:* 'char* lw6pil_command_s::text'

     The original full text of the command.

 -- Struct: lw6pil_dump_args_s

     Arguments passed to the DUMP command.

 -- Member of lw6pil_dump_args_s: level_hexa
     *Type:* 'char *'

     *Definition:* 'char* lw6pil_dump_args_s::level_hexa'

     Hexa dump of level.

 -- Member of lw6pil_dump_args_s: game_struct_hexa
     *Type:* 'char *'

     *Definition:* 'char* lw6pil_dump_args_s::game_struct_hexa'

     Hexa dump of game struct.

 -- Member of lw6pil_dump_args_s: game_state_hexa
     *Type:* 'char *'

     *Definition:* 'char* lw6pil_dump_args_s::game_state_hexa'

     Hexa dump of game state.

 -- Struct: lw6pil_dump_s

     Stores the information contained in a dump, this is just an utility
     struct used to hold all the data (level, game struct, game state
     and pilot) together

 -- Member of lw6pil_dump_s: level
     *Type:* 'lw6map_level_t *'

     *Definition:* 'lw6map_level_t* lw6pil_dump_s::level'

     Will hold the new level if a dump is received.

 -- Member of lw6pil_dump_s: game_struct
     *Type:* 'lw6ker_game_struct_t *'

     *Definition:* 'lw6ker_game_struct_t* lw6pil_dump_s::game_struct'

     Will hold the new game struct if a dump is received.

 -- Member of lw6pil_dump_s: game_state
     *Type:* 'lw6ker_game_state_t *'

     *Definition:* 'lw6ker_game_state_t* lw6pil_dump_s::game_state'

     Will hold the new game state if a dump is received.

 -- Member of lw6pil_dump_s: pilot
     *Type:* 'lw6pil_pilot_p'

     *Definition:* 'lw6pil_pilot_p lw6pil_dump_s::pilot'

     Will hold the new pilot if a dump is received.

 -- Struct: lw6pil_local_cursors_s

     Contains information about all local cursors, which will override
     information from game state.

 -- Member of lw6pil_local_cursors_s: main_cursor_id
     *Type:* 'u_int16_t'

     *Definition:* 'u_int16_t lw6pil_local_cursors_s::main_cursor_id'

     Main cursor ID (16-bit non-zero unsigned int).  By main, we usually
     mean the mouse-driven one but necessarily.  But still, this is a
     cursor which will have a special role, it will be used to center
     the map if needed, among other things.

 -- Member of lw6pil_local_cursors_s: main_i
     *Type:* 'int'

     *Definition:* 'int lw6pil_local_cursors_s::main_i'

     Main cursor index.

 -- Member of lw6pil_local_cursors_s: nb_cursors
     *Type:* 'int'

     *Definition:* 'int lw6pil_local_cursors_s::nb_cursors'

     Number of cursors.

 -- Member of lw6pil_local_cursors_s: cursors
     *Type:* 'lw6pil_local_cursor_t'

     *Definition:* 'lw6pil_local_cursor_t
     lw6pil_local_cursors_s::cursors[LW6MAP_MAX_NB_CURSORS]'

     The cursors array.

 -- Struct: lw6pil_local_cursor_s

     Stores informations about local cursors.  This is usefull for user
     feedback.  Indeed there can be some delay between, for instance, a
     mouse move or a keyboard press, and the time this information makes
     it through the whole pipeline.  Players wouldn't understand such a
     lag so for local cursors we override the information from the game
     state with that information we get right from the GUI.

 -- Member of lw6pil_local_cursor_s: cursor_id
     *Type:* 'u_int16_t'

     *Definition:* 'u_int16_t lw6pil_local_cursor_s::cursor_id'

     Cursor ID (16-bit non-zero unsigned int).

 -- Member of lw6pil_local_cursor_s: x
     *Type:* 'int'

     *Definition:* 'int lw6pil_local_cursor_s::x'

     X position (map coords).

 -- Member of lw6pil_local_cursor_s: y
     *Type:* 'int'

     *Definition:* 'int lw6pil_local_cursor_s::y'

     Y position (map coords).

 -- Member of lw6pil_local_cursor_s: mouse_controlled
     *Type:* 'int'

     *Definition:* 'int lw6pil_local_cursor_s::mouse_controlled'

     Wether this cursor is mouse controlled.  If yes, then information
     will be taken directly from the mouse driver.

 -- Member of lw6pil_local_cursor_s: is_main
     *Type:* 'int'

     *Definition:* 'int lw6pil_local_cursor_s::is_main'

     Wether this cursor is the main cursor.

 -- Struct: lw6pil_pilot_s

     Pilot is a container for several game states, a reference state
     which we can rely upon and a draft state which is anticipated to
     provide interactive feedback but reflects non-validated
     informations.  The first member, id, is the same as the internal
     _lw6pil_pilot_t structure.  The rest of it is hidden.  The program
     will cast from lw6pil_pilot_t to _lw6pil_pilot_t internally.

 -- Member of lw6pil_pilot_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6pil_pilot_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Struct: lw6pil_remove_args_s

     Arguments passed to the REMOVE command.

 -- Member of lw6pil_remove_args_s: cursor_id
     *Type:* 'u_int16_t'

     *Definition:* 'u_int16_t lw6pil_remove_args_s::cursor_id'

     Cursor ID (16-bit non-zero unsigned int).

 -- Struct: lw6pil_set_args_s

     Arguments passed to the SET command.

 -- Member of lw6pil_set_args_s: cursor_id
     *Type:* 'u_int64_t'

     *Definition:* 'u_int64_t lw6pil_set_args_s::cursor_id'

     Cursor ID (16-bit non-zero unsigned int).

 -- Member of lw6pil_set_args_s: x
     *Type:* 'int'

     *Definition:* 'int lw6pil_set_args_s::x'

     X position (map coords).

 -- Member of lw6pil_set_args_s: y
     *Type:* 'int'

     *Definition:* 'int lw6pil_set_args_s::y'

     Y position (map coords).

 -- Member of lw6pil_set_args_s: fire
     *Type:* 'int'

     *Definition:* 'int lw6pil_set_args_s::fire'

     Wether to activate primary weapon.

 -- Member of lw6pil_set_args_s: fire2
     *Type:* 'int'

     *Definition:* 'int lw6pil_set_args_s::fire2'

     Wether to activate secondary weapon.

 -- Struct: lw6pil_worker_s

     Worker thread data, used to calculate stuff in a separate thread.
     The principle is simple, it tries to keep up with a given target
     round, whenever this round isn't reached, it computes more and more
     rounds.

 -- Member of lw6pil_worker_s: run
     *Type:* 'int'

     *Definition:* 'volatile int lw6pil_worker_s::run'

     Wether this thread should run, 0 will stop it.

 -- Member of lw6pil_worker_s: verified
     *Type:* 'int'

     *Definition:* 'int lw6pil_worker_s::verified'

     Wether this is running in verified mode or not.

 -- Member of lw6pil_worker_s: current_round
     *Type:* 'int'

     *Definition:* 'volatile int lw6pil_worker_s::current_round'

     Current game round.

 -- Member of lw6pil_worker_s: target_round
     *Type:* 'int'

     *Definition:* 'volatile int lw6pil_worker_s::target_round'

     Round up to which we should compute stuff.

 -- Member of lw6pil_worker_s: computed_rounds
     *Type:* 'int'

     *Definition:* 'volatile int lw6pil_worker_s::computed_rounds'

     How many rounds where computed since object creation.

 -- Member of lw6pil_worker_s: over
     *Type:* 'int'

     *Definition:* 'volatile int lw6pil_worker_s::over'

     Wether the game is over or not.

 -- Member of lw6pil_worker_s: compute_thread
     *Type:* 'lw6sys_thread_handler_t *'

     *Definition:* 'lw6sys_thread_handler_t*
     lw6pil_worker_s::compute_thread'

     The thread that does the job.

 -- Member of lw6pil_worker_s: global_mutex
     *Type:* 'lw6sys_mutex_t *'

     *Definition:* 'lw6sys_mutex_t* lw6pil_worker_s::global_mutex'

     Global data mutex.

 -- Member of lw6pil_worker_s: compute_mutex
     *Type:* 'lw6sys_mutex_t *'

     *Definition:* 'lw6sys_mutex_t* lw6pil_worker_s::compute_mutex'

     Mutex used for the computing thread.

 -- Member of lw6pil_worker_s: game_state
     *Type:* 'lw6ker_game_state_t *'

     *Definition:* 'lw6ker_game_state_t* lw6pil_worker_s::game_state'

     Game state the computing thread is working on.

 -- Member of lw6pil_worker_s: commands
     *Type:* 'lw6sys_list_r_t *'

     *Definition:* 'lw6sys_list_r_t* lw6pil_worker_s::commands'

     List of commands to be processed.

 -- Member of lw6pil_worker_s: dump
     *Type:* 'lw6pil_dump_t'

     *Definition:* 'lw6pil_dump_t lw6pil_worker_s::dump'

     Dump information.

 -- Struct: lw6pil_command_args_u

     Arguments passed to various commands.

 -- Member of lw6pil_command_args_u: add
     *Type:* 'lw6pil_add_args_t'

     *Definition:* 'lw6pil_add_args_t lw6pil_command_args_u::add'

     Arguments when command is ADD.

 -- Member of lw6pil_command_args_u: remove
     *Type:* 'lw6pil_remove_args_t'

     *Definition:* 'lw6pil_remove_args_t lw6pil_command_args_u::remove'

     Arguments when command is REMOVE.

 -- Member of lw6pil_command_args_u: set
     *Type:* 'lw6pil_set_args_t'

     *Definition:* 'lw6pil_set_args_t lw6pil_command_args_u::set'

     Arguments when command is SET.

 -- Member of lw6pil_command_args_u: dump
     *Type:* 'lw6pil_dump_args_t'

     *Definition:* 'lw6pil_dump_args_t lw6pil_command_args_u::dump'

     Arguments when command is DUMP.

